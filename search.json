[{"title":"markdown语法测试","url":"//docs/markdown语法测试/","content":"\n# Welcome to Arachnid‘s blog!\n\n## 排版\n\n**粗体** *斜体* \n\n~~这是一段错误的文本。~~\n\n引用:\n\n> 引用鲁迅的话：我以为“别人尊重我，是因为我很优秀”，后来才明白，“别人尊重我，是因为别人很优秀。\n\n有序列表:\n\n  1. 支持 Vim\n  2. 支持 Emacs\n\n无序列表:\n\n - 项目1\n - 项目2\n\n\n\n## 图片与链接\n\n图片:\n\n![test Image](https://avatars.githubusercontent.com/u/48347583?v=4 \"test Image\")\n\n\n链接:\n\n[这是去往 Arachnid 博客的链接](https://arachnid.cc)\n\n\n\n## 标题\n\n以下是各级标题, 最多支持5级标题\n\n```\n# h1\n## h2\n### h3\n#### h4\n##### h4\n###### h5\n```\n\n\n\n## 代码\n\n示例:\n\n    function get(key) {\n        return m[key];\n    }\n\n代码高亮示例:\n\n``` javascript\n/**\n* nth element in the fibonacci series.\n* @param n >= 0\n* @return the nth element, >= 0.\n*/\nfunction fib(n) {\n  var a = 1, b = 1;\n  var tmp;\n  while (--n >= 0) {\n    tmp = a;\n    a += b;\n    b = tmp;\n  }\n  return a;\n}\n \ndocument.write(fib(10));\n```\n\n```python\nclass Employee:\n   empCount = 0\n \n   def __init__(self, name, salary):\n        self.name = name\n        self.salary = salary\n        Employee.empCount += 1\n```\n\n\n\n# Markdown 扩展\n\nMarkdown 扩展支持:\n\n* 表格\n* 定义型列表\n* Html 标签\n* 脚注\n* 目录\n* 时序图与流程图\n* MathJax 公式\n\n\n\n## 表格\n\n| Item     | Value  |\n| -------- | ------ |\n| Computer | \\$1600 |\n| Phone    | \\$12   |\n| Pipe     | \\$1    |\n\n可以指定对齐方式, 如Item列左对齐, Value列右对齐, Qty列居中对齐\n\n| Item     |  Value | Qty  |\n| :------- | -----: | :--: |\n| Computer | \\$1600 |  5   |\n| Phone    |   \\$12 |  12  |\n| Pipe     |    \\$1 | 234  |\n\n\n\n## 定义型列表\n\n名词 1\n:   定义 1（左侧有一个可见的冒号和四个不可见的空格）\n\n代码块 2\n:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）\n\n        代码块（左侧有八个不可见的空格）\n\n\n\n## Html 标签\n\n支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格，最后使用 `{% raw %}` `{% endraw %}` 把 Html 代码包裹起来应该就可以了：\n\n    <table>\n        <tr>\n            <th rowspan=\"2\">值班人员</th>\n            <th>星期一</th>\n            <th>星期二</th>\n            <th>星期三</th>\n        </tr>\n        <tr>\n            <td>李强</td>\n            <td>张明</td>\n            <td>王平</td>\n        </tr>\n    </table>\n\n\n{% raw %}\n\n<table>\n    <tr>\n        <th rowspan=\"2\">值班人员</th>\n        <th>星期一</th>\n        <th>星期二</th>\n        <th>星期三</th>\n    </tr>\n    <tr>\n        <td>李强</td>\n        <td>张明</td>\n        <td>王平</td>\n    </tr>\n</table>\n\n\n{% endraw %}\n\n\n\n**提示**, 如果想对图片的宽度和高度进行控制, 你也可以通过 img标签, 如:\n\n{% raw %}\n\n<img src=\"https://avatars.githubusercontent.com/u/48347583?v=4\" width=\"50px\" />\n\n{% endraw %}\n\n\n\n## 脚注\n\nMarkdown[^footnote]来创建一个脚注\n\n[^footnote]: Markdown是一种轻量级标记语言.\n\n## 目录\n\n通过 `[TOC]` 在文档中插入目录, 如:\n\n[TOC]\n\n## 时序图与流程图\n\n```mermaid\nsequenceDiagram\n    Alice->Bob: Hello Bob, how are you?\n    Note right of Bob: Bob thinks\n    Bob-->Alice: I am good thanks!\n```\n\n流程图:\n\n```mermaid\ngraph TB\n    A[Hard] -->|Text| B(Round)\n    B --> C{Decision}\n    C -->|One| D[Result 1]\n    C -->|Two| E[Result 2]\n```\n\n\n> **提示:** 更多关于时序图与流程图的语法请参考:\n>\n> - [Mermaid](https://github.com/mermaid-js/mermaid/blob/develop/README.zh-CN.md)\n\n\n\n## KaTex 数学公式\n\n$ 表示行内公式： \n\n质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。\n\n`$$` 表示整行公式：\n\n$$\\sum_{i=1}^n a_i=0 $$\n\n$$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$\n\n$$\\sum^{j-1}_{k=0}{\\widehat{\\gamma}_{kj} z_k} $$\n\n更复杂的公式：\n\n$$\\begin{eqnarray}\\vec\\nabla \\times (\\vec\\nabla f) & = & 0  \\cdots\\cdots梯度场必是无旋场\\\\\n\\vec\\nabla \\cdot(\\vec\\nabla \\times \\vec F) & = & 0\\cdots\\cdots旋度场必是无散场\\\\\n\\vec\\nabla \\cdot (\\vec\\nabla f) & = & {\\vec\\nabla}^2f\\\\\n\\vec\\nabla \\times(\\vec\\nabla \\times \\vec F) & = & \\vec\\nabla(\\vec\\nabla \\cdot \\vec F) - {\\vec\\nabla}^2 \\vec F\\\\\\end{eqnarray} $$\n\n访问 [KaTex](https://katex.org/) 参考更多使用方法。"},{"title":"X/YModem传输协议","url":"//docs/通讯协议/XYModem传输协议/","content":"\n\n# 文件传输\n\n最常用的几种文件传输协议有：XModem、YModem、ZModem等。\n\n- XModem是最早的文件传输协议之一，由于出现较早，几乎大部分的通讯程序所支持的文件传输都使用该协议，通常是传输 128字节的信息块；这种古老的传输协议速度虽然较慢，但由于使用了 CRC错误校验方法，传输的准确率可高达 99.6%。\n\n- YModem协议是 XModem的改进版，它最早用于调制解调器之间的文件传输，具有快速，稳定传输的优点。它的传输速度比 XModem快，这是由于它可以一次传输 1024字节的信息块，同时它还支持传输多个文件，也就是常说的批文件传输。\n\n- ZModem协议的处理速度快于 XModem和 YModem，这是因为它采用了串流式（streaming）传输方式，而且还具有自动改变区段大小和断点续传、快速错误侦测等功能，可以很好地进行断开后恢复传输。这是目前最流行的文件传输协议。\n\n- 除开上面介绍的三种 X / Y / ZModem协议，还有个常见的传输协议 --- ASCII协议，这是最快的传输协议，但只能传送文本文件。\n\n\n\nX / Ymodem协议：\nhttp://pauillac.inria.fr/~doligez/zmodem/ymodem.txt\n\nZmodem协议：\nhttp://gallium.inria.fr/~doligez/zmodem/zmodem.txt\n\n\n\n# 控制字符定义\n\n```\n<SOH> 01H       // 传输 128Byte 启动标志\n<STX> 02H \t\t// 传输 1024Byte 启动标志\n<EOT> 04H       // 传输结束\n<ACK> 06H       // 应答\n<NAK> 15H       // 没应答\n<CAN> 18H       // 取消传输\n<C> 43H         // ASCII 'C' CRC校验请求\n\n<NUL> 00H       // 空符填充\n<CPMEOF> 1AH    // 数据填充 (^Z)\n```\n\n\n\n# XModem通讯\n\nXmodem 是使用最广泛的文件传输协议之一。原始的 Xmodem 协议使用 128字节数据包和一个简单的 “校验和\" 错误检测方法。后面增强为 Xmodem-CRC，使用了更安全的循环冗余校验 (CRC) 用于错误检测方法。Xmodem 协议总是首先尝试使用 CRC。如果发件人不确认对 CRC 的请求，接收器将转移到 ”校验和“ 模式并继续其传输请求。\n\n增强型 Xmodem-1K 本质上是 Xmodem CRC 模式传输 1K (1024字节) 数据包。在某些系统和通报上它也可以称为 Ymodem。\n\n\n\nXmodem 协议传输由接收程序和发送程序完成，先由接收程序发送协商字符，协商校验方式，协商通过之后发送程序就开始发送数据包，接收程序接收到完整的一个数据包之后按照协商的方式对数据包进行校验。校验通过之后发送确认字符，然后发送程序继续发送下一包；如果校验失败，则发送否认字符，发送程序重传此数据包。**信息报中如果剩余的数据不足 128字节，不足的部分将以 `0x1A` 填充。**\n\n## 校验和模式\n\n### 帧包格式\n\n|        Byte1         |      Byte2      |       Byte3        |    Byte4~131     | Byte132  |\n| :------------------: | :-------------: | :----------------: | :--------------: | :------: |\n| Start Of Header(SOH) | Packet NumberID | ~(Packet NumberID) | Packet Data[128] | CheckSUM |\n\n### 传输方式\n\n|                        Sender                        | Flow |             Receiver             |\n| :--------------------------------------------------: | :--: | :------------------------------: |\n|                                                      | <--- |               NAK                |\n|                                                      |      |     Time out after 3 Second      |\n|                                                      | <--- |               NAK                |\n| \\<SOH\\> \\<0x01\\> \\<0xFE\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> |            Packet OK             |\n|                                                      | <--- |               ACK                |\n| \\<SOH\\> \\<0x02\\> \\<0xFD\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> | **Line hit during transmission** |\n|                                                      | <--- |             **NAK**              |\n| \\<SOH\\> \\<0x02\\> \\<0xFD\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> |            Packet OK             |\n|                                                      | <--- |               ACK                |\n| \\<SOH\\> \\<0x03\\> \\<0xFC\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> |            Packet OK             |\n|                 **ACK get garbaged**                 | <--- |               ACK                |\n| \\<SOH\\> \\<0x03\\> \\<0xFC\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> |       **Duplicate packet**       |\n|                                                      | <--- |             **NAK**              |\n| \\<SOH\\> \\<0x04\\> \\<0xFB\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> | **UART Framing err on any byte** |\n|                                                      | <--- |             **NAK**              |\n| \\<SOH\\> \\<0x04\\> \\<0xFB\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> |            Packet OK             |\n|                                                      | <--- |               ACK                |\n| \\<SOH\\> \\<0x05\\> \\<0xFA\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> | **UART Overrun err on any byte** |\n|                                                      | <--- |             **NAK**              |\n| \\<SOH\\> \\<0x05\\> \\<0xFA\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> |            Packet OK             |\n|                                                      | <--- |               ACK                |\n|                         EOT                          | ---> |            Packet OK             |\n|                 **ACK get garbaged**                 | <--- |               ACK                |\n|                         EOT                          | ---> |            Packet OK             |\n|                       Finished                       | <--- |               ACK                |\n\n## CRC模式\n\n计算 16位 CRC 校验的除数多项式为：`X ^ 16 + X ^ 12 + X ^ 5 + 1`，信息报中的 128数据字节将参加 CRC 校验的计算，在发送端 CRC-16 的高字节在前，低字节在后。\n\n### 帧包格式\n\n|        Byte1         |      Byte2      |       Byte3        |    Byte4~131     | Byte132~133 |\n| :------------------: | :-------------: | :----------------: | :--------------: | :---------: |\n| Start Of Header(SOH) | Packet NumberID | ~(Packet NumberID) | Packet Data[128] | 16-Bit CRC  |\n\n### 传输方式\n\n传输流程：接收方要求发送方以 CRC 校验方式发送时以 ‘C’ 来请求，发送方将对此作出应答。\n\n|                       Sender                        | Flow |             Receiver             |\n| :-------------------------------------------------: | :--: | :------------------------------: |\n|                                                     | <--- |               'C'                |\n|                                                     |      |     Time out after 3 Second      |\n|                                                     | <--- |               'C'                |\n| \\<SOH\\> \\<0x01\\> \\<0xFE\\> \\<Data[0-127]\\> \\<CRC16\\> | ---> |            Packet OK             |\n|                                                     | <--- |               ACK                |\n| \\<SOH\\> \\<0x02\\> \\<0xFD\\> \\<Data[0-127]\\> \\<CRC16\\> | ---> | **Line hit during transmission** |\n|                                                     | <--- |             **NAK**              |\n| \\<SOH\\> \\<0x02\\> \\<0xFD\\> \\<Data[0-127]\\> \\<CRC16\\> | ---> |            Packet OK             |\n|                                                     | <--- |               ACK                |\n| \\<SOH\\> \\<0x03\\> \\<0xFC\\> \\<Data[0-127]\\> \\<CRC16\\> | ---> |            Packet OK             |\n|                                                     | <--- |               ACK                |\n|                         EOT                         | ---> |            Packet OK             |\n|                  ACK get garbaged                   | <--- |               ACK                |\n|                         EOT                         | ---> |            Packet OK             |\n|                      Finished                       | <--- |               ACK                |\n\n## 扩展\n\n关于校验和和 CRC 校验可以看以前的文章《[常用校验算法](https://blog.csdn.net/qq_42992084/article/details/116466029)》\n\n[XModem Protocol with CRC](https://web.mit.edu/6.115/www/amulet/xmodem.htm)\n\n\n\n# YModem通讯\n\nYmodem 本质上是允许多个批处理文件传输的 Xmodem-1K，也可表示为 YModem-1K。\n\nYmodem 在 Xmodem-1K 基础上发展，沿用了 `TeLink` 协议的添加空头块的做法，也就是增加 `block 0`。该 block 标识即将发送文件的 `文件名`，`文件大小` 和  `文件创建时间戳(一般不填写)`\n\nYmodem-g 是 Ymodem 的变体。它设计用于支持错误控制的调制解调器。该协议不提供软件纠错或恢复，但期望调制解调器提供服务。它是一种流式传输协议，以连续流的形式发送和接收 1K 个数据包，直到指示停止。YModem-g 传输形式与 YModem-1K 差不多，同时在发送完一个数据块后，它不会等待应答确认，而是快速连续地发送下一个数据块；如果有任何块不成功转移，整个转移被取消。\n\n## 起始帧（block 0）\n\nYModem 的起始帧并不直接传输文件的数据，而是将文件名与文件的大小放在数据帧中传输，它的帧长 = 3字节数据首部 + 128字节数据 + 2字节 CRC16 校验码 = 33字节。\n\n|        Byte1         | Byte2 | Byte3 |                 Byte4~131                 | Byte132~133 |\n| :------------------: | :---: | :---: | :---------------------------------------: | :---------: |\n| Start Of Header(SOH) | 0x00  | 0xFF  | [ \\<`filename`\\> \\<`filezise`\\> \\<NUL\\> ] | 16-Bit CRC  |\n\n说明：\n\n- Byte 1~3：头标志是 SOH，起始帧序固定为 0x00，帧序取反为 0xFF。\n- Byte 4~131：\n  - `filename` 是传输的文件名字，如文件名 `foo.c`，它在起始帧中的格式为：`66 6F 6F 2E 63 00`，也就是把 ASCII 码转成十六进制，最后的 0x00 代表文件名结束。\n  - `filesize` 是要传输的文件的大小，比如文件大小为 120 KByte，转换为 `120 * 1024 = 122880` Byte，转化为十六进制为 `0x1E00`，它在起始帧中的格式为：`31 45 30 30 00`，对应 ASCII 为 `1E00`，最后的 0x00 代表文件长度结束。\n  - 最后 `NUL` 代表剩余不足 128 Byte 部分用 0x00 填充。\n- Byte 132~133：CRCH、CRCL分别表示 16位 CRC 校验码的高 8位与低 8位，高字节在前，低字节在后。\n\n## 数据帧（block n）\n\n|        Byte1         |      Byte2      |       Byte3        |    Byte4~1027     | Byte1028~1029 |\n| :------------------: | :-------------: | :----------------: | :---------------: | :-----------: |\n| Start Of Header(STX) | Packet NumberID | ~(Packet NumberID) | Packet Data[1024] |  16-Bit CRC   |\n\n注意：有一种特殊的情况是，如果文件总大小小于等于 128字节或者文件数据最后剩余的数据小于 128字节，则 YModem 会选择 SOH 数据帧格式用 128 字节来传输数据，而数据不满 128 字节，剩余的数据用 `0x1A` 填充。\n\n这时数据帧的结构就变成了：\n\n文件大小小于 128字节：`<SOH> <01> <FE> <data1> <data2> ... <datan>  <CPMEOF> ... <CRCH> <CRCL>`\n\n文件最后剩余数据小于 128字节：`<SOH> <ID> <~ID> <data1> <data2> ... <datan> <CPMEOF> ... <CRCH> <CRCL>`\n\n## 结束帧（block n+1）\n\nYModem 的结束帧数据也采用 SOH 的 128字节数据帧\n\n|        Byte1         | Byte2 | Byte3 | Byte4~131 | Byte132~133 |\n| :------------------: | :---: | :---: | :-------: | :---------: |\n| Start Of Header(SOH) | 0x00  | 0xFF  |  \\<NUL\\>  | 16-Bit CRC  |\n\n## 传输流程\n\n以把 foo.c，大小为 4196Byte（16进制为 0x1064）的文件作为传输的对象：\n\n|                            Sender                            | Flow |        Receiver         |\n| :----------------------------------------------------------: | :--: | :---------------------: |\n|                                                              | <--- |           'C'           |\n|                                                              |      | Time out after 3 Second |\n|                                                              | <--- |           'C'           |\n| \\<SOH\\> \\<0x00\\> \\<0xFF\\> \\<Data[ `<foo.c>` \\| `<0x1064>` \\| \\<NUL\\> ]\\> \\<CRC16\\> | ---> |        Packet OK        |\n|                                                              | <--- |           ACK           |\n|                                                              | <--- |           'C'           |\n|     \\<STX\\> \\<0x01\\> \\<0xFE\\> \\<Data[0-1023]\\> \\<CRC16\\>     | ---> |        Packet OK        |\n|                                                              | <--- |           ACK           |\n|     \\<STX\\> \\<0x02\\> \\<0xFD\\> \\<Data[0-1023]\\> \\<CRC16\\>     | ---> |        Packet OK        |\n|                                                              | <--- |           ACK           |\n|     \\<STX\\> \\<0x03\\> \\<0xFC\\> \\<Data[0-1023]\\> \\<CRC16\\>     | ---> |        Packet OK        |\n|                                                              | <--- |           ACK           |\n|     \\<STX\\> \\<0x04\\> \\<0xFB\\> \\<Data[0-1023]\\> \\<CRC16\\>     | ---> |        Packet OK        |\n|                                                              | <--- |           ACK           |\n| \\<SOH\\> \\<0x05\\> \\<0xFA\\> \\<Data[0-99]\\> \\<CPMEOF[0-27]\\> \\<CRC16\\> | ---> |        Packet OK        |\n|                                                              | <--- |           ACK           |\n|                             EOT                              | ---> |        Packet OK        |\n|                                                              | <--- |         **NAK**         |\n|                             EOT                              | ---> |        Packet OK        |\n|                                                              | <--- |           ACK           |\n|                                                              | <--- |           'C'           |\n|      \\<SOH\\> \\<0x00\\> \\<0xFF\\> \\<NUL[0-127]\\> \\<CRC16\\>      | ---> |        Packet OK        |\n|                           Finished                           | <--- |           ACK           |\n\n\n\n# 参考\n\nhttps://en.wikipedia.org/wiki/XMODEM\n\nhttps://en.wikipedia.org/wiki/YMODEM\n\nhttps://en.wikipedia.org/wiki/ZMODEM\n\n[XMODEM, YMODEM, and ZMODEM](http://web.cecs.pdx.edu/~rootd/catdoc/guide/TheGuide_toc.html#SEC237)\n\n[Transmisja modemowa - Xmodem, Ymodem, Zmodem](https://slideplayer.pl/slide/434572/)\n\n[lrzsz: free x/y/zmodem implementation](https://www.ohse.de/uwe/software/lrzsz.html)\n\n\n\n# 附录\n\nCRC校验计算：\n\n```c\nint calcrc(char *ptr, int count)\n{\n    int  crc;\n    char i;\n    crc = 0;\n    while (--count >= 0)\n    {\n        crc = crc ^ (int) *ptr++ << 8;\n        i = 8;\n        do\n        {\n            if (crc & 0x8000)\n                crc = crc << 1 ^ 0x1021;\n            else\n                crc = crc << 1;\n        } while(--i);\n    }\n    return (crc);\n}\n```\n\n","tags":["history","Modem"],"categories":["传输协议"]},{"title":"Modbus家族之 ASCII","url":"//docs/Modbus/Modbus家族之 ASCII/","content":"\n\n\n> 嗨，相信在上一篇经过我的兄弟 RTU的介绍之后，已经对 Modbus有了一定的了解了吧；那么本篇就跟紧我的脚步一起学习新的知识吧。\n>\n\n\n\n# 描述\n\nModbus在串行设备中通过实现主从模型结构，解决了电子设备之间的数据通讯问题；在采用 Modbus协议时，它有两种主要的原始传输方式 ---- Modbus RTU 和 Modbus ASCII。而 Modbus RTU已经在上一篇介绍了，那么就在本篇中瞅瞅 ASCII吧。\n\n\n\n# 通讯方式\n\n## 帧格式\n\n|   Name   | Length (bytes) |                         Description                          |\n| :------: | :------------: | :----------------------------------------------------------: |\n|  Start   |       1        | Starts with colon : (ASCII hex value is 3A)<br/>（以冒号 `:` 开头，ASCII十六进制值为 3A） |\n| Address  |       2        |    Node address in hex<br/>（十六进制节点地址，字符表示）    |\n| Function |       2        |    Function code in hex<br/>（十六进制功能码，字符表示）     |\n|   Data   |     n x 2      | n is the number of data bytes, it depends on function<br/>（n是数据字节数，它取决于功能码） |\n|   LRC    |       2        |       Longitudinal redundancy check<br/>（LRC校验码）        |\n|   End    |       2        |                           CR / LF                            |\n\n注：地址、功能、数据和 LRC都是表示 8位值 (0-255) 的**大写**十六进制可读字符对；即：在 Modbus ASCII中，每个数据字节被分割成表示十六进制值中的两个 ASCII字符的两个字节。\n\n在 ASCII模式下，消息以冒号 `:` 字符开头（ASCII表示为 0x3A），以回车换行对 `\\r\\n` （ASCII表示为 0x0D和 0x0A）结尾；所有其他字段传输的数据所允许的十六进制表示字符为的 `0-9`、`A-F`。\n\n|    START     | ADDRESS | FUNCTION |  DATA   | LRC CHECK |       END        |\n| :----------: | :-----: | :------: | :-----: | :-------: | :--------------: |\n| 1 CHAR<br/>: | 2 CHARS | 2 CHARS  | n CHARS |  2 CHARS  | 2 CHARS<br/>CRLF |\n\n![image-20220326235527004](image-20220326235527004.png)\n\n## 功能码\n\nASCII最常用的功能代码跟 RTU的功能代码定义是一样的，这里就不多说了，可以去查看 《[Modbus家族之 RTU](https://blog.csdn.net/qq_42992084/article/details/123605912)》篇章的功能码部分，这里只是格式上有所不同而已，~~下一篇会对这两个原始传输方式进行对比的。~~ 嘛，还是直接合并到本篇，对 RTU和 ASCII进行对比分析吧，顺便回顾一下 RTU协议。\n\n| 访问地址：address |   映射地址    |       描述        |   功能   | R/W  |\n| :---------------: | :-----------: | :---------------: | :------: | :--: |\n|     1 ~ 10000     |   address-1   |       Coils       | 01/05/15 | R/W  |\n|   10001 ~ 20000   | address-10001 |  Discrete Inputs  |    02    |  R   |\n|   30001 ~ 40000   | address-30001 |  Input Registers  |    04    |  R   |\n|   40001 ~ 50000   | address-40001 | Holding Registers | 03/06/16 | R/W  |\n\n在这里，简单的举个 ASCII传输例子：\n\n例如，要读取 VAR1，你需要从地址 0x20C1读取 2个寄存器，所以你需要发送以下 ASCII消息：\n\n`:010420C1000218<CRLF>`\n\n- 请求：\n\n  |      Name       |                      Description                       |\n  | :-------------: | :----------------------------------------------------: |\n  |       ‘:’       |                Start of message - 0x3A                 |\n  |     ‘0’ ‘1’     |                  Node address – 0x01                   |\n  |     ‘0’ ‘4’     |      Function code (Read Input Registers) – 0x04       |\n  | ‘2’ ‘0’ ‘C’ ‘1’ |       Register address for reading VAR1 – 0x20C1       |\n  | ‘0’ ‘0’ ‘0’ ‘2’ |  Length of registers to be read (must be 2) – 0x0002   |\n  |     ‘1’ ‘8’     |                          LRC                           |\n  |    \\<CRLF\\>     | End of message, carriage return and line feed – 0x0D0A |\n\n此消息的响应如下：\n\n`:01040400001234B1<CRLF>`\n\n- 响应：\n\n  |              Name               |                      Description                       |\n  | :-----------------------------: | :----------------------------------------------------: |\n  |               ‘:’               |                Start of message - 0x3A                 |\n  |             ‘0’ ‘1’             |                  Node address – 0x01                   |\n  |             ‘0’ ‘4’             |      Function code (Read Input Registers) – 0x04       |\n  |             ‘0’ ‘4’             |           Read data length (4 bytes) – 0x04            |\n  | ‘0’ ‘0’ ‘0’ ‘0’ ‘1’ ‘2’ ‘3’ ‘4’ |           Value read from VAR1 – 0x00001234            |\n  |             ‘B’ ‘1’             |                          LRC                           |\n  |            \\<CRLF\\>             | End of message, carriage return and line feed – 0x0D0A |\n\n好了，那么就直入主题吧，常用功能码部分依然是如下几个：\n\n### 功能 01（01H）读线圈\n\n- 请求\n\n  读取从机中线圈的 ON/OFF 状态。不支持广播。请求消息指定了开始线圈和要读取的线圈数量。\n\n  下面是一个请求读取线圈的例子：19 - 55（Coil 20 to 56），37个线圈，从设备节点 3（注意起始地址是 19或 0x13，比线圈 20小 1）：\n\n  ![image-20220327151916968](image-20220327151916968.png)\n\n- 响应\n\n  线圈状态响应消息被打包为数据字段的每比特表示一个线圈。状态表示为：1 = ON，0 = OFF。第一个数据字节的 LSB包含请求中寻址的线圈。其他线圈跟随这个字节的高阶末端，并在随后的字节中从低阶到高阶。\n\n  例如，当线圈 20 - 27的状态显示 `ON - ON - OFF - OFF - ON - OFF - ON - OFF - ON - OFF` 时，以字节值二进制 `0101 0011 (0x53)` 表示。一个字节包含八个线圈的状态。如果返回的线圈数量不是 8的倍数，则最终数据字节中的剩余位将用 0填充(朝向字节的高阶末端)；字节计数字段指定数据的完整字节数。\n\n  > Figure 6 shows an example of a response to the query shown in Figure 5：\n\n  ![image-20220327152253123](image-20220327152253123.png)\n\n### 功能 02（02H）读离散输入\n\n- 请求\n\n  读取从机中离散输入的 ON/OFF 状态。不支持广播。请求消息指定起始输入和要读取的输入数量。\n\n  下面是一个从从设备节点 3读取离散输入 10101 - 10120，总共 20个输入的例子（注意起始地址是 100或 0x64，比输入 10101小 10001）：\n\n  ![image-20220327155421391](image-20220327155421391.png)\n\n- 响应\n\n  离散输入状态响应消息的构造与线圈状态(01H) 操作相同。\n\n  > Figure 8 shows an example of a response to the query shown in Figure 7：\n\n  ![image-20220327155851480](image-20220327155851480.png)\n\n### 功能 03（03H）读保持寄存器\n\n- 请求\n\n  读取从机中保持寄存器的二进制内容。不支持广播。请求消息指定起始寄存器和要读取的寄存器数量。\n\n  下面是一个从从设备节点 7读取保持寄存器 40201 - 40203，总共 3个寄存器的请求的例子（注意起始地址是 200或 0xC8，比寄存器 40201小 40001）：\n\n  ![image-20220327160332698](image-20220327160332698.png)\n\n- 响应\n\n  响应消息中的保持寄存器数据在每个寄存器中打包为两个字节，二进制内容在每个字节中右对齐；对于每个寄存器，第一个字节包含高阶位，第二个字节包含低阶位。\n\n  > Figure 10 shows an example of a response to the query shown in Figure 9：\n\n  ![image-20220327160607639](image-20220327160607639.png)\n\n### 功能 04（04H）读输入寄存器\n\n- 请求\n\n  读取从机中保持寄存器的二进制内容。不支持广播。请求消息指定起始寄存器和要读取的寄存器数量。\n\n  下面是一个从从设备节点 7读取输入寄存器 30301 - 30303，总共 3个寄存器的请求的例子（注意起始地址是300或0x12C，比寄存器 30301小 30001）：\n\n  ![image-20220327171629490](image-20220327171629490.png)\n\n- 响应\n\n  读输入寄存器数据的响应消息的构造与读取保持寄存器(03H) 操作相同。\n\n  > Figure 12 shows an example of a response to the query shown in Figure 11：\n\n  ![image-20220327171942458](image-20220327171942458.png)\n\n### 功能 05（05H）写单线圈\n\n- 请求\n\n  将单个线圈写入 ON或 OFF。当广播时，该函数强制所有附加的从机使用相同的线圈引用。请求消息指定要写入的线圈引用（启动线圈和状态）。\n\n  `FF 00` 的值要求线圈打开，值为 `00 00` 的请求为关闭，所有其他值都是非法的，不会影响线圈。\n\n  下面是一个在从设备节点 3中请求打开线圈 150的例子（注意起始地址是 149或 0x95，比线圈 150小 1）：\n\n  ![image-20220327172937327](image-20220327172937327.png)\n\n- 响应\n\n  正常的响应是请求的回显，在写入线圈状态之后返回。\n\n  > Figure 14 shows an example of a response to the query shown in Figure 13：\n\n  ![image-20220327173100544](image-20220327173100544.png)\n\n### 功能 06（06H）写单个保持寄存器\n\n- 请求\n\n  将一个值写入单个保持寄存器中。当广播时，该函数在所有附加的从机上设置相同的寄存器引用。请求消息指定要写入的寄存器引用（指定地址和数值）。\n\n  下面是一个请求从从设备节点 3中的保持寄存器 40150写入 1000数值的例子（注意起始地址为 149或 0x95，比寄存器 40150小 40001）：\n\n  ![image-20220327175033869](image-20220327175033869.png)\n\n- 响应\n\n  正常的响应是请求的回显，在写入保持寄存器内容之后返回。\n\n  > Figure 16 shows an example of a response to the query shown in Figure 15：\n\n  ![image-20220327175344005](image-20220327175344005.png)\n\n### 功能 15（0FH）写多个线圈\n\n- 请求\n\n  将一个线圈序列中的每个线圈写入 ON或 OFF。当广播时，该函数强制所有附加的从机使用相同的线圈引用。请求消息指定要写入的线圈引用（起始线圈和状态）。\n\n  下面的示例显示了从设备节点 5中的线圈 20开始写入一系列 10个线圈状态的请求。二进制位与线圈的对应方式如下（注意起始地址是 19或 0x13，比线圈 20小 1）：\n\n  | Bit  | 1    | 1    | 0    | 1    | 0    | 0    | 0    | 1    | 0    | 0    | 0    | 0    | 0    | 1    | 0    | 1    |\n  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n  | Coil | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | ...  | ...  | ...  | ...  | ...  | 30   | 29   | 28   |\n  \n  ![image-20220327182406708](image-20220327182406708.png)\n\n- 响应\n\n  正常响应返回从地址、功能代码、起始地址和写入的线圈数量，不包括字节数和对应写入的状态。\n\n  > Figure 24 shows an example of a response to the query shown in Figure 23：\n\n  ![image-20220327182618637](image-20220327182618637.png)\n\n### 功能 16（10H）写多个保持寄存器\n\n- 请求\n\n  将值写入到一个保持寄存器序列中。当广播时，该函数在所有附加的从机上设置相同的寄存器引用。请求消息指定要写入的寄存器引用（起始寄存器和数值）。\n\n  下面是一个请求从从设备节点 5中的保持寄存器 40020到 40022写入以下数据的示例（注意起始地址是 19或 0x13，比寄存器 40020小 40001）：\n\n  | address | data   |\n  | ------- | ------ |\n  | 40020   | 0x0164 |\n  | 40021   | 0x0165 |\n  | 40022   | 0x0166 |\n  \n  ![image-20220327184941057](image-20220327184941057.png)\n\n- 响应\n\n  正常响应返回从地址、功能代码、起始地址和写入的寄存器数量，不包括字节数和对应写入的数据。\n\n  > Figure 26 shows an example of a response to the query shown in Figure 25：\n\n  ![image-20220327185223421](image-20220327185223421.png)\n\n## LRC校验\n\n```c\nunsigned char\nucMBLRC( unsigned char * pucFrame, unsigned short usLen )\n{\n    unsigned char ucLRC = 0;  /* LRC char initialized */\n\n    while( usLen-- )\n    {\n        ucLRC += *pucFrame++;   /* Add buffer byte without carry */\n    }\n\n    /* Return twos complement */\n    ucLRC = ( UCHAR ) ( -( ( CHAR ) ucLRC ) );\n    return ucLRC;\n}\n```\n\n校验原理可看 [常用校验算法](https://blog.csdn.net/qq_42992084/article/details/116466029)-LRC章节","tags":["history","modbus"],"categories":["传输协议"]},{"title":"Modbus家族之 RTU","url":"//docs/Modbus/Modbus家族之 RTU/","content":"\n\n\n> 您好啊，我是 Modbus家族成员的 RTU，同时期诞生的还有我的兄弟，它就是 ASCII。本篇呢就来让大家熟悉一下我吧，下一篇则由我兄弟 ASCII进行介绍。好了，废话不多说，接下来就带你们来认识一下我吧。\n>\n\n\n\n# 描述\n\nModbus RTU（远程终端单元）是原始 Modbus规范中定义的两种传输模式之一。 这两种模式是 Modbus RTU和 ASCII，它们被设计用于支持 RS232，RS485和 RS422接口的串行设备。 Modbus RTU的一个显着特点是它使用二进制编码和强大的 CRC错误检查。 Modbus RTU是 Modbus协议的实现，最常用于工业应用和自动化生产设施。嘻嘻，我可是很受工业场景应用的哦。\n\n\n\n# 通讯方式\n\n## 帧格式\n\n|   Name   | Length (bytes) |                         Description                          |\n| :------: | :------------: | :----------------------------------------------------------: |\n| Address  |       1        |                   Node address（节点地址）                   |\n| Function |       1        |                  Function code（功能代码）                   |\n|   Data   |       n        | n is the number of data bytes, it depends on function<br/>（n是数据字节数，它取决于功能码） |\n|   CRC    |       2        |          Cyclic redundancy check<br/>（CRC校验码）           |\n\n在 RTU模式下，消息以至少 3.5个字符的静默间隔为开始，以至少 3.5个字符的类似间隔结束。这是最容易实现的以波特率在网络上使用的字符次数的倍数(如下图中所示的 T1 - T2 - T3 - T4)。\n\n| START             | ADDRESS | FUNCTION | DATA       | CRC CHECK | END               |\n| ----------------- | ------- | -------- | ---------- | --------- | ----------------- |\n| **\\*T1–T2–T3–T4** | 8 BITS  | 8 BITS   | n x 8 BITS | 16 BITS   | **\\*T1–T2–T3–T4** |\n\n**\\*T1-T2-T3-T4**：表示不通信时的 3.5个字符。\n\n所有其他字段都由 8位数据组成。\n\n![image-20220319201759692](image-20220319201759692.png)\n\n## 功能码\n\nModbus设备最常用的功能代码如下表所示：\n\n![image-20220319195917761](image-20220319195917761.png)\n\n### 功能 01（01H）读线圈\n\n- 请求：\n\n  | 名称      | 长度   | 说明              |\n  | --------- | ------ | ----------------- |\n  | 设备地址  | 1 字节 |                   |\n  | 功能码    | 1 字节 | **0x01**          |\n  | 开始地址  | 2 字节 | 0x0000 to 0xFFFF  |\n  | 线圈数量  | 2 字节 | 1 to 2000 (0x7D0) |\n  | CRC校验码 | 2 字节 |                   |\n  \n  指令：设备地址（1byte）+ **0x01**（1byte）+ 起始地址（2byte）+ 线圈数（2byte）+ CRC（2byte）\n  \n- 应答：\n\n  | 名称                 | 长度   | 说明         |\n  | -------------------- | ------ | ------------ |\n  | 设备地址             | 1 字节 |              |\n  | 功能码               | 1 字节 | **0x01**     |\n  | 线圈数量对应的字节数 | 1 字节 | **\\*N**      |\n  | 线圈数据1            | 1 字节 |              |\n  | 线圈数据2            | 1 字节 |              |\n  | 线圈数据n            | 1 字节 | n = N or N+1 |\n  | CRC校验码            | 2 字节 |              |\n\n  **\\*N** = 线圈数量 / 8，如果余数非 0，则 N = N+1\n  \n  指令：设备地址（1byte）+ **0x01**（1byte）+ 字节数（1byte）+ 线圈状态（Nbyte）+ CRC（2byte）\n  \n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x81**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n\n**流程图：**\n\n![image-20220319211327513](image-20220319211327513.png)\n\n### 功能 02（02H）读离散输入\n\n- 请求：\n\n  | 名称         | 长度   | 说明              |\n  | ------------ | ------ | ----------------- |\n  | 设备地址     | 1 字节 |                   |\n  | 功能码       | 1 字节 | **0x02**          |\n  | 开始地址     | 2 字节 | 0x0000 to 0xFFFF  |\n  | 离散状态数量 | 2 字节 | 1 to 2000 (0x7D0) |\n  | CRC校验码    | 2 字节 |                   |\n  \n  指令：设备地址（1byte）+ **0x02**（1byte）+ 起始地址（2byte）+ 离散数（2byte）+ CRC（2byte）\n\n- 应答：\n\n  | 名称                     | 长度   | 说明         |\n  | ------------------------ | ------ | ------------ |\n  | 设备地址                 | 1 字节 |              |\n  | 功能码                   | 1 字节 | **0x02**     |\n  | 离散状态数量对应的字节数 | 1 字节 | **\\*N**      |\n  | 离散数据1                | 1 字节 |              |\n  | 离散数据2                | 1 字节 |              |\n  | 离散数据n                | 1 字节 | n = N or N+1 |\n  | CRC校验码                | 2 字节 |              |\n  \n  **\\*N** = 离散状态数量 / 8，如果余数非 0，则 N = N+1\n  \n  指令：设备地址（1byte）+ **0x01**（1byte）+ 字节数（1byte）+ 离散状态（Nbyte）+ CRC（2byte）\n  \n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x82**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n  \n\n**流程图：**\n\n![image-20220319212623922](image-20220319212623922.png)\n\n### 功能 03（03H）读保持寄存器\n\n- 请求：\n\n  | 名称           | 长度   | 说明             |\n  | -------------- | ------ | ---------------- |\n  | 设备地址       | 1 字节 |                  |\n  | 功能码         | 1 字节 | **0x03**         |\n  | 开始地址       | 2 字节 | 0x0000 to 0xFFFF |\n  | 保持寄存器数量 | 2 字节 | 1 to 125 (0x7D)  |\n  | CRC校验码      | 2 字节 |                  |\n\n  指令：设备地址（1byte）+ **0x03**（1byte）+ 起始地址（2byte）+ 保持寄存器数（2byte）+ CRC（2byte）\n\n- 应答：\n\n  | 名称                       | 长度   | 说明     |\n  | -------------------------- | ------ | -------- |\n  | 设备地址                   | 1 字节 |          |\n  | 功能码                     | 1 字节 | **0x03** |\n  | 保持寄存器数量对应的字节数 | 1 字节 | 2 \\* N   |\n  | 寄存器数值1                | 2 字节 |          |\n  | 寄存器数值2                | 2 字节 |          |\n  | 寄存器数值n                | 2 字节 | n = N    |\n  | CRC校验码                  | 2 字节 |          |\n\n  指令：设备地址（1byte）+ **0x03**（1byte）+ 字节数（1byte）+ 保持寄存器值（2 \\* Nbyte）+ CRC（2byte）\n\n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x83**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n\n**流程图：**\n\n![image-20220319213419588](image-20220319213419588.png)\n\n### 功能 04（04H）读输入寄存器\n\n- 请求：\n\n  | 名称           | 长度   | 说明             |\n  | -------------- | ------ | ---------------- |\n  | 设备地址       | 1 字节 |                  |\n  | 功能码         | 1 字节 | **0x04**         |\n  | 开始地址       | 2 字节 | 0x0000 to 0xFFFF |\n  | 输入寄存器数量 | 2 字节 | 1 to 125 (0x7D)  |\n  | CRC校验码      | 2 字节 |                  |\n\n  指令：设备地址（1byte）+ **0x04**（1byte）+ 起始地址（2byte）+ 输入寄存器数（2byte）+ CRC（2byte）\n\n- 应答：\n\n  | 名称                       | 长度   | 说明     |\n  | -------------------------- | ------ | -------- |\n  | 设备地址                   | 1 字节 |          |\n  | 功能码                     | 1 字节 | **0x04** |\n  | 保持寄存器数量对应的字节数 | 1 字节 | 2 \\* N   |\n  | 寄存器数值1                | 2 字节 |          |\n  | 寄存器数值2                | 2 字节 |          |\n  | 寄存器数值n                | 2 字节 | n = N    |\n  | CRC校验码                  | 2 字节 |          |\n\n  指令：设备地址（1byte）+ **0x04**（1byte）+ 字节数（1byte）+ 输入寄存器值（2 \\* Nbyte）+ CRC（2byte）\n\n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x84**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n\n**流程图：**\n\n![image-20220319214513539](image-20220319214513539.png)\n\n### 功能 05（05H）写单线圈\n\n- 请求：\n\n  | 名称           | 长度   | 说明             |\n  | -------------- | ------ | ---------------- |\n  | 设备地址       | 1 字节 |                  |\n  | 功能码         | 1 字节 | **0x05**         |\n  | 输出地址       | 2 字节 | 0x0000 to 0xFFFF |\n  | **\\*线圈数值** | 2 字节 | 0x0000 or 0xFF00 |\n  | CRC校验码      | 2 字节 |                  |\n\n  ***线圈数值** ：0xFF00 -> 请求线圈状态为 ON\n\n  ​\t\t\t\t\t\t0x0000 -> 请求线圈状态为 OFF\n\n  ​\t\t\t\t\t\t其他值 -> 非法且对线圈不起作用\n\n  指令：设备地址（1byte）+ **0x05**（1byte）+ 输出地址（2byte）+ 线圈值（2byte）+ CRC（2byte）\n\n- 应答：\n\n  | 名称      | 长度   | 说明             |\n  | --------- | ------ | ---------------- |\n  | 设备地址  | 1 字节 |                  |\n  | 功能码    | 1 字节 | **0x05**         |\n  | 输出地址  | 2 字节 | 0x0000 to 0xFFFF |\n  | 线圈数值  | 2 字节 | 0x0000 or 0xFF00 |\n  | CRC校验码 | 2 字节 |                  |\n\n  指令：正常响应是请求的应答\n\n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x85**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n\n**流程图：**\n\n![image-20220319215633462](image-20220319215633462.png)\n\n### 功能 06（06H）写单个保持寄存器\n\n- 请求：\n\n  | 名称       | 长度   | 说明             |\n  | ---------- | ------ | ---------------- |\n  | 设备地址   | 1 字节 |                  |\n  | 功能码     | 1 字节 | **0x06**         |\n  | 寄存器地址 | 2 字节 | 0x0000 to 0xFFFF |\n  | 寄存器数值 | 2 字节 | 0x0000 to 0xFFFF |\n  | CRC校验码  | 2 字节 |                  |\n  \n  指令：设备地址（1byte）+ **0x06**（1byte）+ 保持寄存器地址（2byte）+ 保持寄存器值（2byte）+ CRC（2byte）\n\n- 应答：\n\n  | 名称       | 长度   | 说明             |\n  | ---------- | ------ | ---------------- |\n  | 设备地址   | 1 字节 |                  |\n  | 功能码     | 1 字节 | **0x06**         |\n  | 寄存器地址 | 2 字节 | 0x0000 to 0xFFFF |\n  | 寄存器数值 | 2 字节 | 0x0000 to 0xFFFF |\n  | CRC校验码  | 2 字节 |                  |\n\n  指令：正常响应是请求的应答\n\n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x86**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n\n**流程图：**\n\n![image-20220319220604204](image-20220319220604204.png)\n\n### 功能 15（0FH）写多个线圈\n\n- 请求：\n\n  | 名称                 | 长度   | 说明              |\n  | -------------------- | ------ | ----------------- |\n  | 设备地址             | 1 字节 |                   |\n  | 功能码               | 1 字节 | **0x0F**          |\n  | 开始地址             | 2 字节 | 0x0000 to 0xFFFF  |\n  | 线圈输出数量         | 2 字节 | 1 to 1968 (0x7B0) |\n  | 线圈数量对应的字节数 | 1 字节 | **\\*N**           |\n  | 线圈输出数据1        | 1 字节 |                   |\n  | 线圈输出数据2        | 1 字节 |                   |\n  | 线圈输出数据n        | 1 字节 | n = N or N+1      |\n  | CRC校验码            | 2 字节 |                   |\n\n  **\\*N** = 线圈输出数量 / 8，如果余数非 0，则 N = N+1\n\n  指令：设备地址（1byte）+ **0x0F**（1byte）+ 起始地址（2byte）+ 线圈输出数（2byte）+ 字节数（1byte）+ 线圈输出数据（Nbyte）+ CRC（2byte）\n\n- 应答：\n\n  | 名称         | 长度   | 说明              |\n  | ------------ | ------ | ----------------- |\n  | 设备地址     | 1 字节 |                   |\n  | 功能码       | 1 字节 | **0x0F**          |\n  | 开始地址     | 2 字节 | 0x0000 to 0xFFFF  |\n  | 线圈输出数量 | 2 字节 | 1 to 1968 (0x7B0) |\n  | CRC校验码    | 2 字节 |                   |\n\n  指令：设备地址（1byte）+ **0x0F**（1byte）+ 起始地址（2byte）+ 线圈输出数（2byte）+ CRC（2byte）\n\n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x8F**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n\n**流程图：**\n\n![image-20220319223636555](image-20220319223636555.png)\n\n### 功能 16（10H）写多个保持寄存器\n\n- 请求：\n\n  | 名称                   | 长度   | 说明             |\n  | ---------------------- | ------ | ---------------- |\n  | 设备地址               | 1 字节 |                  |\n  | 功能码                 | 1 字节 | **0x10**         |\n  | 开始地址               | 2 字节 | 0x0000 to 0xFFFF |\n  | 寄存器数量             | 2 字节 | 1 to 123 (0x7B)  |\n  | 寄存器数量对应的字节数 | 1 字节 | 2 * N            |\n  | 寄存器数值1            | 2 字节 |                  |\n  | 寄存器数值2            | 2 字节 |                  |\n  | 寄存器数值n            | 2 字节 | n = N            |\n  | CRC校验码              | 2 字节 |                  |\n\n  指令：设备地址（1byte）+ **0x10**（1byte）+ 起始地址（2byte）+ 寄存器数（2byte）+ 字节数（1byte）+ 寄存器数值（2 * Nbyte）+ CRC（2byte）\n\n- 应答：\n\n  | 名称       | 长度   | 说明             |\n  | ---------- | ------ | ---------------- |\n  | 设备地址   | 1 字节 |                  |\n  | 功能码     | 1 字节 | **0x10**         |\n  | 开始地址   | 2 字节 | 0x0000 to 0xFFFF |\n  | 寄存器数量 | 2 字节 | 1 to 123 (0x7B)  |\n  | CRC校验码  | 2 字节 |                  |\n\n  指令：设备地址（1byte）+ **0x10**（1byte）+ 起始地址（2byte）+ 保持寄存器数（2byte）+ CRC（2byte）\n\n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x90**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n\n**流程图：**\n\n![image-20220319224924985](image-20220319224924985.png)\n\n## CRC校验\n\n- CRC16_MODBUS查表法：\n\n    ```c\n    static const unsigned char aucCRCHi[] = {\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n        0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, \n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, \n        0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, \n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40\n    };\n\n    static const unsigned char aucCRCLo[] = {\n        0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,\n        0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,\n        0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,\n        0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,\n        0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,\n        0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,\n        0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,\n        0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, \n        0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,\n        0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,\n        0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,\n        0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,\n        0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, \n        0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,\n        0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,\n        0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,\n        0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,\n        0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,\n        0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,\n        0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,\n        0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,\n        0x41, 0x81, 0x80, 0x40\n    };\n\n    unsigned short\n    usMBCRC16( unsigned char * pucFrame, unsigned short usLen )\n    {\n        unsigned char   ucCRCHi = 0xFF;\n        unsigned char   ucCRCLo = 0xFF;\n        int             iIndex;\n\n        while( usLen-- )\n        {\n            iIndex = ucCRCLo ^ *( pucFrame++ );\n            ucCRCLo = ( unsigned char )( ucCRCHi ^ aucCRCHi[iIndex] );\n            ucCRCHi = aucCRCLo[iIndex];\n        }\n        return ( unsigned short )( ucCRCHi << 8 | ucCRCLo );\n    }\n    ```\n\n- CRC16_MODBUS运算法：\n\n  运算分析及计算，可看文章 [常用校验算法](https://blog.csdn.net/qq_42992084/article/details/116466029)-CRC章节\n\n\n\n# 实例应用\n\n测试应用可看以前的文章：\n\n[Nano130之 FreeModbus移植](https://blog.csdn.net/qq_42992084/article/details/107590803)","tags":["history","modbus"],"categories":["传输协议"]},{"title":"RT-Thread 应用总结","url":"//docs/RTOS/RT-Thread 应用总结/","content":"\n\n\n官方文档介绍：[RT-Thread文档中心](https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/README)\n\n\n\n# 各模块 API接口\n\n由于 RT-Thread实时操作系统跟各大类 RTOS应用原理大致相同，因此不再详述各模块功能的作用了（各模块功能的详细信息可参考以前的 《[FreeRTOS专栏](https://blog.csdn.net/qq_42992084/category_9684254.html)》），只总结各类功能接口的 API调用函数。\n\n\n\n官方 API参考手册：[RT-Thread API参考手册](https://www.rt-thread.org/document/api/index.html)\n\n\n\n![](04thread_sta.png)\n\n\n\n## 线程管理\n\n### A、线程使用\n\n![线程相关操作](04thread_ops.png)\n\n| 函数功能 | API 接口                                                     | 函数描述                                                     | 与 FreeRTOS相匹配的函数 |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------- |\n| 创建线程 | rt_thread_t rt_thread_create(const char \\*name, void (\\*entry)(void \\*parameter), void \\*parameter, rt_uint32_t stack_size, rt_uint8_t priority, rt_uint32_t tick); | 该函数将**从动态堆内存中**创建一个线程对象并分配线程对象内存和堆栈。 | xTaskCreate()           |\n| 删除线程 | rt_err_t rt_thread_delete(rt_thread_t thread);               | 调用该函数后，线程对象将会被移出线程队列并且从内核对象管理器中删除，线程占用的堆栈空间也会被释放，收回的空间将重新用于其他的内存分配。 | vTaskDelete()           |\n|          |                                                              |                                                              |                         |\n| 初始线程 | rt_err_t rt_thread_init(struct rt_thread \\*thread, const char \\*name, void (\\*entry)(void \\*parameter),  void \\*parameter, void \\*stack_start,  rt_uint32_t stack_size, rt_uint8_t priority,  rt_uint32_t tick); | 使用该函数创建的线程，线程句柄(或者说线程控制块指针) 、线程栈所占用的内存空间，均通过全局变量的方式进行分配，内核不负责动态分配内存空间（即由用户提供，**属于静态分配**，在编译时就被确定、被分配处理）。 | xTaskCreateStatic()     |\n| 脱离线程 | rt_err_t rt_thread_detach (rt_thread_t thread);              | 与 rt_thread_delete() 函数相对应，使线程对象在线程队列和内核对象管理器中被脱离。注：线程本身不应调用这个接口脱离线程本身 | vTaskDelete()           |\n|          |                                                              |                                                              |                         |\n| 启动线程 | rt_err_t rt_thread_startup(rt_thread_t thread);              | 当调用这个函数时，将把线程的状态更改为就绪状态，并放到相应优先级队列中等待调度。 |                         |\n|          |                                                              |                                                              |                         |\n| 线程睡眠 | rt_err_t rt_thread_sleep(rt_tick_t tick); rt_err_t rt_thread_delay(rt_tick_t tick); rt_err_t rt_thread_mdelay(rt_int32_t ms); | 这三个函数接口的作用相同，调用它们可以使当前线程挂起一段指定的时间，当这个时间过后，线程会被唤醒并再次进入就绪状态。 | vTaskDelay()            |\n\n对比：[FreeRTOS篇章之任务管理](https://blog.csdn.net/qq_42992084/article/details/104360962)\n\n\n\n### B、挂起和恢复\n\n- **线程挂起的函数接口：**\n\n  `rt_err_t rt_thread_suspend (rt_thread_t thread);`\n\n  线程挂起接口 rt_thread_suspend() 的参数和返回值见下表：\n\n  | **参数** | **描述**                                     |\n  | -------- | -------------------------------------------- |\n  | thread   | 线程句柄                                     |\n  | **返回** | ——                                           |\n  | RT_EOK   | 线程挂起成功                                 |\n  | RT_ERROR | 线程挂起失败，因为该线程的状态并不是就绪状态 |\n\n- [ ] 注：RT-Thread对此此函数有严格的使用限制，该函数只能使用来挂起当前线程（即自己挂起自己），不可以在线程A中尝试挂起线程B，而且在挂起线程自己后，需要立刻调用 `rt_schedule()` 函数进行手动的线程上下文切换。用户只需要了解该接口的作用即可，强烈不建议在程序中使用该接口，该接口可以视为是内部接口。这是因为A线程在尝试挂起B线程时，A线程并不清楚B线程正在运行什么程序，一旦B线程正在使用例如互斥量、信号量等影响、阻塞其他线程的内核对象，那么A线程尝试挂起B线程的操作将会引发连锁反应，严重危及系统的实时性（有些地方会将其描述为死锁，实际上这种现象不是死锁，但是也不比死锁好到哪去）。\n\n- **线程恢复的函数接口：**\n\n  `rt_err_t rt_thread_resume (rt_thread_t thread);`\n\n  线程恢复接口 rt_thread_resume() 的参数和返回值见下表：\n\n  | **参数** | **描述**                                                     |\n  | -------- | ------------------------------------------------------------ |\n  | thread   | 线程句柄                                                     |\n  | **返回** | ——                                                           |\n  | RT_EOK   | 线程恢复成功                                                 |\n  | RT_ERROR | 线程恢复失败，因为该个线程的状态并不是 RT_THREAD_SUSPEND 状态 |\n\n以上这两个函数类似于 [FreeRTOS篇章之临界区与调度器](https://blog.csdn.net/qq_42992084/article/details/104498558) 里面的调度器中的操作，但其要求并不一样。\n\n\n\n## 信号量\n\n![信号量相关接口](06sem_ops.png)\n\n| 函数功能         | API 接口                                                     | 函数描述                                                     | 与 FreeRTOS相匹配的函数                    |\n| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------ |\n| 创建信号量       | rt_sem_t rt_sem_create(const char \\*name, rt_uint32_t value, rt_uint8_t flag); | 系统**动态分配**一个 semaphore 对象，并初始化这个对象，然后初始化父类 IPC 对象以及与 semaphore 相关的部分。 | xSemaphoreCreateBinary()                   |\n| 删除信号量       | rt_err_t rt_sem_delete(rt_sem_t sem);                        | 通过删除信号量以释放系统资源，适用于动态创建的信号量。       | vSemaphoreDelete()                         |\n|                  |                                                              |                                                              |                                            |\n| 初始信号量       | rt_err_t rt_sem_init(rt_sem_t sem, const char \\*name, rt_uint32_t value, rt_uint8_t flag); | **属于静态分配**，它的内存空间在编译时期就被编译器分配出来，放在读写数据段或未初始化数据段上。 | xSemaphoreCreateBinaryStatic()             |\n| 脱离信号量       | rt_err_t rt_sem_detach(rt_sem_t sem);                        | 让信号量对象从内核对象管理器中脱离，适用于静态初始化的信号量。 | vSemaphoreDelete()                         |\n|                  |                                                              |                                                              |                                            |\n| 获取信号量       | rt_err_t rt_sem_take (rt_sem_t sem, rt_int32_t time);        | 通过获取信号量来获得信号量资源实例，当信号量值大于零时，线程将获得信号量，并且相应的信号量值会减 1。 | xSemaphoreTake() / xSemaphoreTakeFromISR() |\n| 无等待获取信号量 | rt_err_t rt_sem_trytake(rt_sem_t sem);                       | 与 `rt_sem_take(sem, RT_WAITING_NO)` 的作用相同，即当线程申请的信号量资源实例不可用的时候，它不会等待在该信号量上，而是直接返回 - `RT_ETIMEOUT`。 |                                            |\n|                  |                                                              |                                                              |                                            |\n| 释放信号量       | rt_err_t rt_sem_release(rt_sem_t sem);                       | 释放之前所获得的信号量资源实例。                             | xSemaphoreGive() / xSemaphoreGiveFromISR() |\n\n对比：[FreeRTOS篇章之二值信号量](https://blog.csdn.net/qq_42992084/article/details/104412659)\n\n\n\n## 互斥量\n\n![互斥量相关接口](06mutex_ops.png)\n\n| 函数功能         | API 接口                                                     | 函数描述                                                     | 与 FreeRTOS相匹配的函数       |\n| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------------- |\n| 创建互斥量       | rt_mutex_t rt_mutex_create (const char \\*name, rt_uint8_t flag); | 系统将先从对象管理器中**动态分配**一个 mutex 对象，并初始化这个对象，然后初始化父类 IPC 对象以及与 mutex 相关的部分。 | xSemaphoreCreateMutex()       |\n| 删除互斥量       | rt_err_t rt_mutex_delete (rt_mutex_t mutex);                 | 通过删除互斥量以释放系统资源，适用于动态创建的互斥量。       | vSemaphoreDelete()            |\n|                  |                                                              |                                                              |                               |\n| 初始互斥量       | rt_err_t rt_mutex_init (rt_mutex_t mutex, const char \\*name, rt_uint8_t flag); | **属于静态分配**，它的内存空间在编译时期就被编译器分配出来，放在读写数据段或未初始化数据段上。 | xSemaphoreCreateMutexStatic() |\n| 脱离互斥量       | rt_err_t rt_mutex_detach (rt_mutex_t mutex);                 | 把互斥量对象从内核对象管理器中脱离，适用于静态初始化的互斥量。 | vSemaphoreDelete()            |\n|                  |                                                              |                                                              |                               |\n| 获取互斥量       | rt_err_t rt_mutex_take (rt_mutex_t mutex, rt_int32_t time);  | 当线程获取了互斥量，那么线程就有了对该互斥量的所有权，即某一个时刻一个互斥量只能被一个线程持有。 | xSemaphoreTake()              |\n| 无等待获取互斥量 | rt_err_t rt_mutex_trytake(rt_mutex_t mutex);                 | 与 `rt_mutex_take(mutex, RT_WAITING_NO)` 的作用相同，即当线程申请的互斥量资源实例不可用的时候，它不会等待在该互斥量上，而是直接返回 - `RT_ETIMEOUT`。 |                               |\n|                  |                                                              |                                                              |                               |\n| 释放互斥量       | rt_err_t rt_mutex_release(rt_mutex_t mutex);                 | 使用该函数接口时，只有已经拥有互斥量控制权的线程才能释放它，每释放一次该互斥量，它的持有计数就减 1。 | xSemaphoreGive()              |\n\n对比：[FreeRTOS篇章之互斥量](https://blog.csdn.net/qq_42992084/article/details/104479069)\n\n\n\n## 事件集\n\n![事件相关接口](06event_ops.png)\n\n| 函数功能   | API 接口                                                     | 函数描述                                                     | 与 FreeRTOS相匹配的函数                            |\n| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------------- |\n| 创建事件集 | rt_event_t rt_event_create(const char \\*name, rt_uint8_t flag); | 系统从对象管理器中**动态分配**事件集对象，并初始化这个对象，然后初始化父类 IPC 对象。 | xEventGroupCreate()                                |\n| 删除事件集 | rt_err_t rt_event_delete(rt_event_t event);                  | 通过删除事件集对象控制块来释放系统资源，适用于动态创建的事件集。 | vEventGroupDelete()                                |\n|            |                                                              |                                                              |                                                    |\n| 初始事件集 | rt_err_t rt_event_init(rt_event_t event, const char \\*name, rt_uint8_t flag); | **属于静态分配**，它的内存空间在编译时期就被编译器分配出来，放在读写数据段或未初始化数据段上。 | xEventGroupCreateStatic()                          |\n| 脱离事件集 | rt_err_t rt_event_detach(rt_event_t event);                  | 将该事件集从内核对象管理器中脱离，适用于静态初始化的事件集。 | vEventGroupDelete()                                |\n|            |                                                              |                                                              |                                                    |\n| 发送事件   | rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set);   | 通过参数 set 指定的事件标志来设定 event 事件集对象的事件标志值，然后遍历等待在 event 事件集对象上的等待线程链表，判断是否有线程的事件激活要求与当前 event 对象事件标志值匹配，如果有，则唤醒该线程。 | xEventGroupSetBits() / xEventGroupSetBitsFromISR() |\n|            |                                                              |                                                              |                                                    |\n| 接收事件   | rt_err_t rt_event_recv(rt_event_t event, rt_uint32_t set, rt_uint8_t option, rt_int32_t timeout, rt_uint32_t \\*recved); | 系统首先根据 set 参数和接收选项 option 来判断它要接收的事件是否发生，如果已经发生，则根据参数 option 上是否设置有 `RT_EVENT_FLAG_CLEAR` 来决定是否重置事件的相应标志位，然后返回（其中 recved 参数返回接收到的事件）；如果没有发生，则把等待的 set 和 option 参数填入线程本身的结构中，然后把线程挂起在此事件上，直到其等待的事件满足条件或等待时间超过指定的超时时间。如果超时时间设置为零，则表示当线程要接受的事件没有满足其要求时就不等待，而直接返回 - `RT_ETIMEOUT`。 | xEventGroupWaitBits()                              |\n\n对比：[FreeRTOS篇章之事件位和事件组](https://blog.csdn.net/qq_42992084/article/details/104602274)\n\n\n\n## 邮箱\n\n![邮箱相关接口](07mb_ops.png)\n\n| 函数功能         | API 接口                                                     | 函数描述                                                     | 与 FreeRTOS相匹配的函数                      |\n| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------- |\n| 创建邮箱         | rt_mailbox_t rt_mb_create (const char \\*name, rt_size_t size, rt_uint8_t flag); | 创建邮箱对象时会先从对象管理器中分配一个邮箱对象，然后给邮箱**动态分配一块内存空间**用来存放邮件，这块内存的大小等于邮件大小（4 字节）与邮箱容量的乘积，接着初始化接收邮件数目和发送邮件在邮箱中的偏移量。 | xQueueCreate()                               |\n| 删除邮箱         | rt_err_t rt_mb_delete (rt_mailbox_t mb);                     | 释放相应的系统资源，当操作一旦完成，邮箱将被永久性的删除。   | vQueueDelete()                               |\n|                  |                                                              |                                                              |                                              |\n| 初始邮箱         | rt_err_t rt_mb_init(rt_mailbox_t mb, const char \\*name, void \\*msgpool, rt_size_t size, rt_uint8_t flag); | **属于静态分配**，与创建邮箱不同的是，静态邮箱对象的内存是在系统编译时由编译器分配的，一般放于读写数据段或未初始化数据段中，其余的初始化工作与创建邮箱时相同。 | xQueueCreateStatic()                         |\n| 脱离邮箱         | rt_err_t rt_mb_detach(rt_mailbox_t mb);                      | 把静态初始化的邮箱对象从内核对象管理器中脱离。               | vQueueDelete()                               |\n|                  |                                                              |                                                              |                                              |\n| 发送邮件         | rt_err_t rt_mb_send (rt_mailbox_t mb, rt_uint32_t value);    | 发送的邮件可以是 32 位任意格式的数据，一个整型值或者一个指向缓冲区的指针；当邮箱中的邮件已经满时，发送邮件的线程或者中断程序会收到 -`RT_EFULL` 的返回值。 | xQueueOverwrite() / xQueueOverwriteFromISR() |\n| 等待方式发送邮件 | rt_err_t rt_mb_send_wait (rt_mailbox_t mb, rt_uint32_t value, rt_int32_t timeout); | 与 rt_mb_send() 的区别在于有等待时间，如果邮箱已经满了，那么发送线程将根据设定的 timeout 参数等待邮箱中因为收取邮件而空出空间；如果设置的超时时间到达依然没有空出空间，这时发送线程将被唤醒并返回错误码。 |                                              |\n| 发送紧急邮件     | rt_err_t rt_mb_urgent (rt_mailbox_t mb, rt_ubase_t value);   | 与发送邮件几乎一样，唯一的不同是，当发送紧急邮件时，邮件被**直接插队放入了邮件队首**，这样，接收者就能够优先接收到紧急邮件，从而及时进行处理。 |                                              |\n|                  |                                                              |                                                              |                                              |\n| 接收邮件         | rt_err_t rt_mb_recv (rt_mailbox_t mb, rt_uint32_t \\*value, rt_int32_t timeout); | 只有当接收者接收的邮箱中有邮件时，接收者才能立即取到邮件并返回 `RT_EOK` 的返回值，否则接收线程会根据超时时间设置，或挂起在邮箱的等待线程队列上，或直接返回。 | xQueueReceive() / xQueueReceiveFromISR()     |\n\n对比：[FreeRTOS篇章之队列管理](https://blog.csdn.net/qq_42992084/article/details/104399531) 中的消息数目为 1的队列\n\n注：由于 FreeRTOS中并没有邮箱这一概念（邮箱这概念在 uCOS中有），但是其原理类似于利用队列发送单一数目的信息，由于在 32 系统上 4 字节（32 bit）的内容恰好可以放置一个指针，因此该信息通常为**数据指针**。\n\n\n\n## 消息队列\n\n![消息队列相关接口](07msg_ops.png)\n\n| 函数功能         | API 接口                                                     | 函数描述                                                     | 与 FreeRTOS相匹配的函数                                      |\n| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 创建队列         | rt_mq_t rt_mq_create(const char \\*name, rt_size_t msg_size, rt_size_t max_msgs, rt_uint8_t flag); | 从对象管理器中**动态分配**一个消息队列对象，然后给消息队列对象分配一块内存空间，组织成空闲消息链表，这块`内存的大小 = [消息大小 + 消息头（用于链表连接）的大小] x 消息队列最大个数`，接着再初始化消息队列，此时消息队列为空。 | xQueueCreate()                                               |\n| 删除队列         | rt_err_t rt_mq_delete(rt_mq_t mq);                           | 删除它以释放系统资源，一旦操作完成，消息队列将被永久性地删除。 | vQueueDelete()                                               |\n|                  |                                                              |                                                              |                                                              |\n| 初始队列         | rt_err_t rt_mq_init(rt_mq_t mq, const char \\*name, void \\*msgpool, rt_size_t msg_size, rt_size_t pool_size, rt_uint8_t flag); | **属于静态分配**，跟创建消息队列对象类似，只是静态消息队列对象的内存是在系统编译时由编译器分配的，一般放于读数据段或未初始化数据段中。 | xQueueCreateStatic()                                         |\n| 脱离队列         | rt_err_t rt_mq_detach(rt_mq_t mq);                           | 将使消息队列对象被从内核对象管理器中脱离。                   | vQueueDelete()                                               |\n|                  |                                                              |                                                              |                                                              |\n| 发送信息         | rt_err_t rt_mq_send (rt_mq_t mq, void \\*buffer, rt_size_t size); | 线程或者中断服务程序都可以给消息队列发送消息。当发送消息时，消息队列对象先从空闲消息链表上取下一个空闲消息块，把线程或者中断服务程序发送的消息内容复制到消息块上，然后把该消息块挂到消息队列的尾部。当且仅当空闲消息链表上有可用的空闲消息块时，发送者才能成功发送消息；当空闲消息链表上无可用消息块，说明消息队列已满，此时，发送消息的的线程或者中断程序会收到一个错误码（-`RT_EFULL`）。 | xQueueSend() / xQueueSendFromISR() xQueueSendToFront() / xQueueSendToFrontFromISR() |\n| 等待方式发送信息 | rt_err_t rt_mq_send_wait(rt_mq_t     mq, const void \\*buffer, rt_size_t size, rt_int32_t  timeout); | 与 rt_mq_send() 的区别在于有等待时间，如果消息队列已经满了，那么发送线程将根据设定的 timeout 参数进行等待。如果设置的超时时间到达依然没有空出空间，这时发送线程将被唤醒并返回错误码。 |                                                              |\n| 发送紧急信息     | rt_err_t rt_mq_urgent(rt_mq_t mq, void \\*buffer, rt_size_t size); | 与发送消息几乎一样，唯一的不同是，当发送紧急消息时，从空闲消息链表上取下来的消息块不是挂到消息队列的队尾，而是挂到队首，这样，接收者就能够优先接收到紧急消息，从而及时进行消息处理。 |                                                              |\n|                  |                                                              |                                                              |                                                              |\n| 接收信息         | rt_err_t rt_mq_recv (rt_mq_t mq, void \\*buffer, rt_size_t size, rt_int32_t timeout); | 当消息队列中有消息时，接收者才能接收消息，否则接收者会根据超时时间设置，或挂起在消息队列的等待线程队列上，或直接返回。 | xQueueReceive() / xQueueReceiveFromISR()                     |\n\n对比：[FreeRTOS篇章之队列管理](https://blog.csdn.net/qq_42992084/article/details/104399531)\n\n\n\n# 中断管理\n\n![中断相关接口](09interrupt_ops.png)\n\n对于上图，通常用的较多的是：\n\n## 全局中断开关\n\n**全局中断开关也称为**中断锁，是禁止多线程访问临界区最简单的一种方式，即通过关闭中断的方式，来保证当前线程不会被其他事件打断（因为整个系统已经不再响应那些可以触发线程重新调度的外部事件），也就是当前线程不会被抢占，除非这个线程主动放弃了处理器控制权。\n\n| 函数功能           | API 接口                                      | 函数描述                 | 与 FreeRTOS相匹配的函数                               |\n| ------------------ | --------------------------------------------- | ------------------------ | ----------------------------------------------------- |\n| 关闭整个系统的中断 | rt_base_t rt_hw_interrupt_disable(void);      | 关闭整个系统的中断       | taskENTER_CRITICAL() / taskENTER_CRITICAL_FROM_ISR()  |\n| 恢复整个系统的中断 | void rt_hw_interrupt_enable(rt_base_t level); | 恢复系统的上一个中断状态 | taskEXIT_CRITICAL() / taskEXIT_CRITICAL_FROM_ISR( x ) |\n\n**（1）rt_hw_interrupt_disable() API 函数**\n\n原型：`rt_base_t rt_hw_interrupt_disable(void);`\n\n返回参数：\n\n- rt_hw_interrupt_disable 函数运行前的中断状态\n\n\n\n**（2）rt_hw_interrupt_enable() API 函数**\n\n原型：`void rt_hw_interrupt_enable(rt_base_t level);`\n\n输入参数：\n\n- 前一次 rt_hw_interrupt_disable 返回的中断状态\n\n\n\n注：在这里就相当于 [FreeRTOS篇章之临界区与调度器](https://blog.csdn.net/qq_42992084/article/details/104498558) 里面的临界段中的操作。\n\n\n\n## 中断通知\n\n当整个系统被中断打断，进入中断处理函数时，需要通知内核当前已经进入到中断状态。\n\n针对这种情况，RT-Thread 提供如下两个接口：\n\n```c\nvoid rt_interrupt_enter(void);\t\t// 用于通知内核，当前已经进入了中断状态，并增加中断嵌套深度（执行 rt_interrupt_nest++）\nvoid rt_interrupt_leave(void);\t\t// 用于通知内核，当前已经离开了中断状态，并减少中断嵌套深度（执行 rt_interrupt_nest--）\n\n注：不要在应用程序中调用这两个接口函数。\n```\n\n其实这两个函数等同于 FreeRTOS中带 FromISR后缀的函数说明。\n\n\n\n# RT-Thread Studio上手\n\n安装及环境搭建过程可以直接参看官方的指导文档：[RT-Thread Studio使用文档](https://www.rt-thread.org/document/site/#/development-tools/rtthread-studio/um/studio-user-begin)\n\n**以下只是简单记录部分关键点：**\n\n## 控制台调试口修改\n\n在新建项目过程中，可从 GUI窗口中选择配置，如下图：\n\n![TIM截图20220226114622](TIM截图20220226114622.png)\n\n当后期需要重新分配时，则需要在代码和 RT-Thread setting中修改了，（以修改为 `UART 3` 为例）修改内容如下：\n\n![TIM截图20220226120341](TIM截图20220226120341.png)\n\n\n\n## 串口终端集成显示\n\n在 RT-Thread Studio上，是可以通过点击工具栏 `终端` 按钮，来打开对应的终端功能窗口查看输出信息的，并且同样支持与 RT-Thread特有的 `finsh` 命令进行交互，串口终端显示操作如下：\n\n![TIM截图20220226141345](TIM截图20220226141345.png)\n\n![TIM截图20220226142044](TIM截图20220226142044.png)\n\n\n\n## 与 CubeMX联合编程\n\n此操作的前提条件是已经安装了 STM32CubeMX\n\n### A、启动 CubeMX settings配置\n\n新建的工程，都是优先使用内部时钟源（如下图），但实际情况下，大部分是使用外部时钟的，因为其稳定性比较好；因此，以修改外部时钟为例。\n\n![TIM截图20220226115723](TIM截图20220226115723.png)\n\n由于 RT-Thread Studio支持与 CubeMX联合编程，所以我们只需在项目资源管理器中启动 `CubeMX settings` 进行配置就好（如下图），进入界面后，其操作实际等同于操作 STM32CubeMX。\n\n![image-20220226210308862](image-20220226210308862.png)\n\n### B、CubeMX settings配置生成注意点\n\n- 尽量生成 GCC工程，因为 RT-Thread Studio用的是 gcc编译器\n  ![image-20220226233830986](image-20220226233830986.png)\n\n- 选择生成独立的 .c .h文件\n  ![img](313583-20201110104753899-295524523.png)\n\n- 生成完成后返回界面，会提示替换了 `stm32xxx_hal_conf.h` 文件，因此，我们需要把原来的配置，同步过去，该哪些配置需要打开的，都一一打开。\n\n### C、添加编译规则\n\n在生成 CubeMX产生的工程后，打开 `drv_clk.c` 文件，你会发现 `clk_init()` 函数里面被自动更改了（如下图）；这也就意味着什么呢？记得备份啦，或者上 git / svn进行版本管理啦。\n\n![TIM截图20220226143627](TIM截图20220226143627.png)\n\n于是乎，对工程进行编译时，发现一堆报错，不禁怀疑 RT-Thread Studio是否支持与 CubeMX联合编程的。。。\n\n在这里就需要对编译做相关操作了：\n\n（1）在生成的 cubemx文件夹里，先检查 cubemx文件夹下有没有 `SConscript` 文件，如果有就跳过创建环节，检查内容。\n\n（2）核查并更改 `SConscript` 文件里面的内容。\n\n（3）有时候在生成 CubeMX产生的工程后，RT-Thread Studio会帮你生成一个 `SConscript` 文件，并写好了规则，如果是已有的，那么可以尝试先编译一下是否有新增的源码进行编译，如果没有，那么可以仿照如下的代码进行修改：\n\n![TIM截图20220226150650](TIM截图20220226150650.png)\n\n其中，上面规则里的 `src` 部分，需要根据实际内容增删需要编译的源文件（如下）：\n\n```markdown\nsrc = Split('''\nSrc/stm32g4xx_hal_msp.c\nSrc/main.c\nSrc/dma.c\nSrc/gpio.c\nSrc/usart.c\n''')\n```\n\n当然，为了一劳永逸，你也可以把它修改成这样子：\n\n```python\n# 引入 building 模块中所有的东西\nfrom building import *\n\n# 获取当前路径。\ncwd = GetCurrentDir()\n\n# 使能选择\nsearch_EN = 1\n\n# add cubemx drivers\n# search_EN为 0时，手动选择添加需要编译的源文件\n# search_EN为 1时，自动搜寻与 SrcRemove匹配以外的源文件\nif (0 == search_EN):\n\tsrc = Split('''\n\tSrc/stm32f4xx_hal_msp.c\n\tSrc/main.c\n\t''')\nelse:\n\tsrc = Glob('Src/*.c')\t\n\tSrcRemove(src, ['Src/stm32f4xx_it.c'])\n\tSrcRemove(src, ['Src/system_stm32f4xx.c'])\n\n# 创建头文件路径列表，并保存至 path中\npath = [cwd + '/Inc']\n\n# 这是 RT-Thread 基于 SCons 扩展的一个方法（函数）。\ngroup = DefineGroup('cubemx', src, depend = [''], CPPPATH = path)\n\nReturn('group')\n\n```\n\n通过上面，你可能发现，为什么文件中的 `stm32f4xx_it.c` 和 `system_stm32f4xx.c` 不加入构建；其实你可以尝试一下加入编译一下，你就会发现玄机了。\n\n更多的关于 SCons工具的使用可以观看如下链接：\n\n[https://www.rt-thread.org/document/site/#/development-tools/scons/scons?id=scons-%e7%ae%80%e4%bb%8b](https://www.rt-thread.org/document/site/#/development-tools/scons/scons?id=scons-简介)\n\n[https://scons.org/doc/production/HTML/scons-user/index.html](https://scons.org/doc/production/HTML/scons-user/index.html)\n\n最后记得更新 Sconscripts（在项目资源管理器选择目标工程 -> 右键 -> 更新 `Sconscripts`）：\n\n![image-20220226231733878](image-20220226231733878.png)\n\n### D、迁移 CubeMX产生的代码\n\n当完成上面操作后，再次构建工程，或多或少还会出现错误，大概率是函数重复定义导致，比如 `multiple definition of main`。这时候可以如下操作：\n\n![20220226173146](20220226173146.png)\n\n嘛，或许有时候在 CubeMX初次生成的 main()函数上自带了 `__WEAK` 弱处理关键字，但后期在多次更改 CubeMX settings配置后，会有出现去掉 `__WEAK` 的情况，所以为了安全，还是把 `__WEAK` 添加到上述的保护区域位置去吧。\n\n除了以上情况，在 CubeMX settings配置更多外设时，需要把 cubemx/Src里的 main.c文件里的配置函数，手动移加到 RT-Thread工程的 main.c主文件函数中（一些 RTT配置里面有的，就不用添加过去了，避免功能出错，例如 ETH 的配置）。如下图：\n\n![20220226172930](20220226172930.png)","tags":["history","RTOS"],"categories":["实时系统"]},{"title":"Modbus家族之开篇","url":"//docs/Modbus/Modbus家族之开篇/","content":"\n\n\n\n# 历史溯源\n\nModbus是由 Modicon公司（现在的施耐德电气 Schneider Electric）在 1979年开发的一种消息传递结构，为使用可编程逻辑控制器（PLC）通信而发表，用于在智能设备之间建立客户端 - 服务器通信；这是一个划时代、里程碑式的网络协议，因此为工业网络拉开了序幕。Modbus已经成为工业领域通信协议事实上的业界标准，并且现在是工业电子设备之间常用的连接方式。\n\nModbus在工业环境下很流行，因为它是公开发表并且无著作权要求的。它是为工业应用开发的，与其他标准相比，它相对易于部署和维护，除了要传输的数据格式的大小外，几乎没有其他限制。Modbus通常使用 **RS485**作为其物理层。\n\n## 发展史\n\nModicon，即今天的施耐德电气，于 1979 年向市场推出了 Modbus原始协议（Modbus ASCII和 Modbus RTU）；随着通信领域的迅速发展以及传输速度的提高，扩展版本 Modbus Plus（Modbus+或者MB+）紧接着出现，不过此协议是 Modicon专有的，**和 Modbus并不相同**；直到以太网技术的标准化和商品化，以太网成为了企业系统的业界标准，同时也成为了工业网络的业界标准；为了将 Modbus带入 21 世纪，一个开放的 Modbus TCP/IP规范于 1999 年修订发行；到了 2004 年 4 月，Modbus 协议从施耐德电气转移到 Modbus组织，这标志着对开放的承诺（**该规范可免费下载，并且**使用 Modbus 或 Modbus TCP/IP 协议无需后续许可费用）；至此，在 Modbus TCP/IP 因为它的开放性、简单、低成本的开发以及支持它所需的最少硬件等特点，存在多个 Modbus TCP变种，而 Modbus ASCII和 Modbus RTU在小型的嵌入式设备当中得到广泛应用。\n\n<br/>\n\n# 协议版本\n\nModbus协议目前存在用于**串口**、**以太网**以及其他支持**互联网协议**的网络的版本。\n\nModbus是一种请求 / 回复协议，提供由功能代码指定的服务。Modbus功能代码是 Modbus Request(请求) / Response(响应)  PDU 的元素。\n\n串行端口和以太网存在多种版本的 Modbus协议，最常见的是：\n\n- Modbus RTU\n- Modbus ASCII\n- Modbus TCP\n- Modbus Plus\n\n![](Modbus-Different-Types.jpg)\n\n\n\n## Modbus RTU\n\n`Modbus RTU` 是一种紧凑的，采用二进制表示数据的方式；因为使用二进制编码和 CRC错误检查的结合使得 Modbus RTU适用于工业应用，因为它比 ASCII字符的替代方案更有效地传输。在 Modbus RTU与 ASCII之间进行选择时，如果考虑性能，则 RTU是首选。\n\n\n\n## Modbus ASCII\n\n`Modbus ASCII` 是当设备设置为使用 `ASCII` （**美国信息交换标准代码**）模式时，在 `MODBUS` 串行线上把通信消息中的每个 8位字节将作为两个 ASCII 4位字符发送。当物理通信链路或设备的功能不允许符合 RTU计时器管理要求时，使用此模式。所以此模式的效率不如 RTU，因为每个字节需要两个字符。示例：字节0x7D编码为两个字符： `0x35`和 `0x42`（在 `ASCII`表中为 `0x37` = `'7'`，而 `0x44` = `'D'`）。\n\n\n\n## Modbus TCP\n\n`Modbus TCP` 是在 `TCP/IP` 网络上运行的 Modbus的实现，旨在允许 Modbus ASCII / RTU协议在基于 TCP / IP的网络上传输。Modbus / TCP将 Modbus消息嵌入 TCP / IP帧内。尽管实现起来非常简单，但是与网络相关的特性增加了一些挑战。例如，由于Modbus主机期望并要求在一定时间范围内对其轮询做出响应，因此必须考虑 TCP / IP网络的不确定性（和其他方面）。Modbus ASCII和 Modbus TCP之间的主要区别在于，Modbus ASCII所需的 LRC错误检查由 IP层执行。\n\n\n\n> 对于以上 `TCP`/ `RTU`/ `ASCII`的这三种通信协议在数据模型和功能调用上都是相同的，只有封装方式是不同的。\n\n\n\n## Modbus Plus\n\n`Modbus Plus` （Modbus+或者MB+）属于 Modbus的一个扩展版本，不过此协议是Modicon专有的，和 Modbus不同。它需要一个专门的协处理器来处理类似 HDLC的高速令牌旋转。它使用 1Mbit/s的双绞线，并且每个节点都有转换隔离设备，是一种采用转换／边缘触发而不是电压／水平触发的设备。连接 Modbus Plus到计算机需要特别的接口，通常是支持 ISA（SA85），PCI或者 PCMCIA总线的板卡。\n\n\n\n# 通信和设备\n\nModbus有下列三种通信方式：\n\n（1）以太网：对应的通信模式是 **Modbus TCP/IP**\n\n（2）异步串行传输（各种介质如有线 RS-232/422/485/、光纤、无线等）：对应的通信模式是 **Modbus RTU**或 **Modbus ASCII**\n\n（3）高速令牌传递网络：对应的通信模式是 **Modbus PLUS**\n\n\n\nModbus通过多种类型的物理介质进行通信，例如：\n\n- 串行RS-232\n- 串行RS-485\n- 串行RS-422\n- 以太网\n\nModbus RTU和 Modbus ASCII协议应用于串口链接（RS232、RS485、RS422），Modbus TCP/IP协议应用于以太网链接。\n\n![img](Modbus-Communication-Physical-Media.gif)\n\n\n\n# 消息结构\n\nModbus的主要消息结构是点对点，能够在点对点和多点网络上运行。\n\n![image-20220208222537825](image-20220208222537825.png)\n\nModbus协议遵循**主 / 从（客户端 / 服务器）**架构，主（客户端）向从（服务器）发送请求并等待响应。注意！目前 Modbus中使用的术语 “主” 和 “从” 已被术语 “客户端” 和 “服务器” 所取代了。\n\n![image-20220209165731722](image-20220209165731722.png)\n\n\n\n# 常见 Modbus开源库\n\n## [FreeModbus](https://www.embedded-experts.at/en/freemodbus/)\n\nFreeMODBUS 是流行的 Modbus 协议的免费实现，专门针对嵌入式系统。FreeMODBUS 提供了 *Modbus 应用协议 v1.1a* 的实现，并支持 *Modbus over serial line 规范 1.0* 中定义的 **RTU/ASCII** 传输模式 ；自 0.7 版以来，FreeModbus 还支持 **Modbus/TCP**；0.9 版添加了第一个 Modbus/TCP 端口嵌入式使用 LWIP TCP/IP 堆栈的系统。唯一可惜的是，该 FreeMODBUS 只对从机开放了源码，主机部分并未实现开源。\n\n以下是该 FreeMODBUS 的下载链接：\n\nhttps://www.embedded-experts.at/en/freemodbus-downloads/\n\n\n\n## [libmodbus](https://libmodbus.org/)\n\nlibmodbus是一个多平台的 Modbus 源库，适用于 Linux、Mac OS X、FreeBSD、QNX 和 Win32 等操作系统；可以根据 Modbus协议发送和接收数据。支持 RTU（串行）和 TCP（以太网）通信。\n\n以下是该 libmodbus 的下载链接：\n\nhttps://libmodbus.org/download/\n\n\n\n# 参考\n\n[Modbus主页](https://modbus.org/)\n\n[Modbus](https://zh.wikipedia.org/wiki/Modbus) - wiki\n\n[WHAT IS MODBUS?](https://realpars.com/modbus/)\n\n《[modbus communication manual](https://process.honeywell.com/us/en/support/product-documents-downloads?search=modbus%20communication%20manual)》\n\n《[MODBUS APPLICATION PROTOCOL SPECIFICATION V1.1b](https://modbus.org/docs/Modbus_Application_Protocol_V1_1b.pdf)》\n\n《[Modbus Fieldbus Networking](https://www.generationrobots.com/media/roboteq/modbus-manual.pdf)》\n\n《[Modbus Protocol Reference Guide](https://www.m-system.co.jp/mssenglish/service/emmodbus.pdf)》\n\n[Modbus RTU通信指南](https://www.virtual-serial-port.org/cn/articles/modbus-rtu-guide/)\n\n[高级Modbus ASCII教程](https://www.virtual-serial-port.org/cn/articles/modbus-ascii-guide/)\n\n[modbus tools](https://www.modbustools.com/modbus.html)\n\n","tags":["history","modbus"],"categories":["传输协议"]},{"title":"步进电机及丝杆","url":"//docs/步进电机及丝杆/","content":"\n\n\n# 步进电机\n\n## 介绍\n\n步进电机（英语：Stepper motor、Step motor）是直流无刷电机的一种，为具有如齿轮状突起（小齿）相锲合的定子和转子，可借由切换流向定子线圈中的电流，以一定角度逐步转动的电动机，能将电脉冲信号转换成相应角位移或线位移。\n\n\n\n### A、构造上\n\n步进电机在构造上有三种主要类型：反应式（Variable Reluctance, VR）、永磁式（Permanent Magnet, PM）和混合式（Hybrid Stepping, HS）\n\n![](15350977719637sn7os61sp.jpg)\n\n- 反应式：也叫感应式、磁滞式或磁阻式步进电机。定子上有绕组、转子由软磁材料组成；定、转子周边均匀分布小齿和槽，通电后利用磁导的变化产生转矩。结构简单、成本低、步距角小，可达1.2°、但动态性能差、效率低、发热大，可靠性难保证。\n\n  ![](2_10.png)\n\n- 永磁式：永磁式步进电机的转子用永磁材料制成，转子的极数与定子的极数相同。其特点是动态性能好、输出力矩大，但这种电机精度差，步矩角大（一般为7.5°或15°）。\n\n  ![](3_11.png)\n\n- 混合式：也叫永磁反应式、永磁感应式步进电机，综合了反应式和永磁式的优点。其定子上有多相绕组、转子上采用永磁材料，转子和定子上均有多个小齿以提高步矩精度。其特点是输出力矩大、动态性能好，步距角小，但结构复杂、成本相对较高。\n\n  ![](4_10.png)\n\n结构区别：\n\n![](step%20motor.jpg)\n\n### B、相数上\n\n从定子上绕组来分类，共有二相、三相和五相等系列。目前最受欢迎的是两相混合式步进电机，约占 97%以上的市场份额，其原因是性价比高，配上细分驱动器后效果良好。\n\n![](1535097802673o0o22s1864.jpg)\n\n- 两相：\n\n  ![](5_6%20-%20%E5%89%AF%E6%9C%AC.png)\n\n- 三相：\n\n  ![](5_6.png)\n\n### C、极数上\n\n按照接线方式的不同，步进电机又可以分为单极步进电机（Unipolar Stepper Motor），和双极步进电机（Bipolar Stepper Motor）。\n\n![](153509774969411451pn716%20-%20%E5%89%AF%E6%9C%AC.jpg)\n\n- 单极型：采用电流在一个绕组中始终沿固定方向流动的驱动方式（单极驱动）。虽然步进电机的结构较为复杂，但是由于仅需要电流 ON /OFF的控制，因此步进电机的驱动电路较简单。\n\n  ![](MT1-30_f02.gif)\n\n- 双极型：采用电流在一个绕组中双向流动的驱动方式（双极驱动）。这种方式电机的结构比较简单，端子数也较少，但由于必须控制一个端子的极性，因此驱动电路较为复杂。\n\n  ![](MT1-30_f01.gif)\n\n单极跟双极比较：\n\n・双极连接\n －采用电流在一个绕组中双向流动的驱动方式（双极驱动）。\n －结构简单，但步进电机的驱动电路复杂。\n －绕组利用率好，且可以进行精细的控制，因此步进电机能够获得很高的输出转矩。\n －可以减小在线圈中产生的反电动势，因此可以使用耐压低的电机驱动器。\n\n・单极连接\n －具有中心抽头，采用电流在一个绕组中始终沿固定方向流动的驱动方式（单极驱动）。\n －结构复杂，但步进电机的驱动电路简单。\n －绕组利用率差，与双极连接相比，步进电机只能获得约一半的输出转矩。\n －由于会在线圈中产生较高的反电动势，因此需要使用高耐压的电机驱动器。\n\n\n\n## 步进模式\n\n主要有 3种步进模式 ：\n\n- 整步\n- 半步\n- 微步\n\n### A、整步\n\n![](full-step-mode-stepper-motor.png)\n\n顾名思义，就是每走一步都是取整的意思。而在整步控制上，也可分成**单相通电驱动**和**双相通电驱动**：\n\n![](11_2.png)\n\n![](full_step_driving_1.png)\n\n它们之间最大的区别在于，双相通电驱动下，由于电机中流动的电流更多，产生的磁场也更强，因此扭矩也更大。\n\n### B、半步\n\n![](half-step-operation-of-stepper-motor.png)\n\n半步模式属于单相通电驱动和双相通电驱动的组合，这种模式可以将步距减小一倍（旋转45°，而不是90°）。其唯一的缺点是电机产生的扭矩不是恒定的，当两相都通电时扭矩较高，只有一相通电时扭矩较小。\n\n![](half_step_driving.png)\n\n### C、微步\n\n![](modes-of-excitation-of-stepper-motor-stepper-microstepping.png)\n\n在微步模式下，可以看作是半步模式的增强版，因为它可以进一步减小步距，并且具有恒定的扭矩输出。这是通过控制每相流过的电流强度来实现的。最多可将电机步距角细分 256倍，提高了低速光滑度和低速谐振效果。\n\n![](microstepping.png)\n\n\n\n## 运作方式\n\n步进电机的运行一般分为三个部分：\n\n- 控制器\n- 驱动器\n- 电机马达\n\n![](TIM%E6%88%AA%E5%9B%BE20211031144528.png)\n\n### A、控制器\n\n控制器类似于人的大脑，指引着电机转动的方向以及操控着电机运转的快慢；当配合着一些控制策略，如：PID 控制、自适应控制等等，会使得其运作效果相当出色；而对于常见的控制方式有：传统方式的步进电机控制系统、基于 PLC的步进电机控制系统、基于 DSP的步进电机控制系统、基于 ARM的步进电机控制系统等。\n\n### B、驱动器\n\n驱动器一般作两个功能：电机的精度控制和驱动运转控制。可分为恒流驱动与恒压驱动两种；恒压驱动方式因其电路构造简单，在高速领域时不易获得转矩的特性，现今已经很少使用；然而恒流驱动方式则是现在广为使用的驱动方式，在高速领域中能掌 握优良的转矩特性。\n\n常见的驱动电路有：\n\n- 单极步进电机驱动电路\n\n  ![](9_5.png)\n\n- 双极步进电机驱动电路\n\n  ![](10_4.png)\n\n### C、电机马达\n\n![](Image_506.png)\n\n略\n\n<br>\n\n# 滚珠丝杆\n\n## 种类\n\n![](TIM%E6%88%AA%E5%9B%BE20211101201524.png)\n\n![](TIM%E6%88%AA%E5%9B%BE20211101201817.png)\n\n## 型号\n\n![image-20211101202146111](image-20211101202146111.png)\n\n![image-20211101202211688](image-20211101202211688.png)\n\n![image-20211101202236464](image-20211101202236464.png)\n\n![image-20211101202300243](image-20211101202300243.png)\n\n![image-20211101202323044](image-20211101202323044.png)\n\n![image-20211101202343698](image-20211101202343698.png)\n\n![image-20211101202416290](image-20211101202416290.png)\n\n![image-20211101202437316](image-20211101202437316.png)\n\n![image-20211101202459745](image-20211101202459745.png)\n\n![image-20211101202522600](image-20211101202522600.png)\n\n\n\n# 传动装置\n\n## 通电自锁\n\n绕组通电时步进电机具有全部的保持力矩。这就意味着步进电机可以在不使用机械刹车的情况下保持在停止位置。\n\n![](stop_position_self_hold.jpg)\n\n## 刹车抱闸\n\n一旦电源被切断，电机自身的保持力矩丢失，电机不能在垂直操作中或施加外力作用下保持在停止位置。在提升和其它相似应用中需要使用带电磁刹车的电机。\n\n![](electromagnetic_brake_motor.jpg)\n\n<br>\n\n# 常用知识归纳\n\n## 细分与步进数\n\n### A、定义\n\n- **什么是步进数**\n\n  步进数，也叫脉冲数，是指步进电机转动一圈或是前进一段距离，需要电机需要接受的信号个数，单位为步。 因为电机的转动最终还是转化为直线运动，所以通常步进数指的是电机推动、拉动主轴，龙门等配件前进 1毫米所需要的步数。\n\n  当步进数不对的后果：\n\n  例如当一台雕刻机的电机步进数不对，直接影响雕刻出来的结果大小不对。比如步进为 100的机器，雕刻 1毫米的直线，电机需要的信号是 100，如果设置步进数为 200，那就多走了一倍的距离，实际雕刻出来的线条就为 2毫米了。\n\n- **什么是细分**\n\n  细分是步进电机驱动器的功能。步进电机的精度有限，一般的步进电机为 200步走一圈，走一步转动的角度是 1.8度。当我们需要电机走 0.9度时，电机就没有办法了。好在步进电机驱动器，可以帮助步进电机把精度提高，把精度提高一倍，叫做半步细分，也叫 1/2细分，此时电机一个信号脉冲就可以转动 0.9度。再把精度提高一倍，叫 1/4细分，走一步，相当于 0.45度。细分都是一倍倍上去的，有 1/2, 1/4, 1/8, 1/16, 1/32等，最大可达 256细分。\n\n### B、应用\n\n- **步进数计算三要素**\n\n  一个是电机转动一圈所需的脉冲数（原始步数）。这个一般为 200，对应的步进角为 1.8度；当然也有其他的，像一些小电机只有 15度，那么转一圈只需 24个脉冲。\n\n  二是所采用的传动结构。如果用丝杆，要知道丝杆的导程，就是说丝杆转一圈时，前进的毫米数（这个稍后说）。如果是皮带轮，就要知道齿数和齿距，两个相乘得到皮带轮转一圈，皮带前进的毫米数。\n\n  三是步进电机驱动器的细分数。计算的公式是： **原始脉冲数** 除于 **毫米数** 再乘于 **细分数**。\n\n- **合理的步进数**\n\n  步进数越大，理论上来说精度越高；然在实际应用中，精度是由很多因素决定的，比如说齿轮可能有间隙，皮带有弹性，机架会抖动等。因此小于 0.01精度的步进数是大部分是没有意义的。\n\n- **如何纠正步进参数**\n\n  有些不是我们自己购买的机器，我们可能不知道具体的电机，传动参数，那么还有一种调整的办法。 先随便设置一个步进数，如 200，然后在软件上控制电机走100毫米，如果设置对，实际走的距离就是100毫米，如果不对，那么有偏差，比如实际它只走了 80毫米。那么可以用以下方式计算正确的步进数。\n\n  原理： 正确的步进数跟正确的距离之比 = 错误的步进数跟错误的距离之比\n\n  公式：正确的步进数 = 正确的距离 乘于 错误的步进数 除于 错误的距离 = 100 * 200 / 80= 250 设置步进数为 250后，你会发现，走 100mm，就是100mm，校对成功。\n\n\n\n## 丝杆脉冲计算\n\n1. 首先认识丝杆的导程，一般来说常见的有 1205、1210、1605、1610等这些说法，然后前两位是直径，后两位表示导程，导程 05的丝杆就是每两个丝的间距为 5（单位：mm）。\n2. 以常规的步进电机 1.8度 200步进，那么走一圈就是 200 * 1.8 = 360度\n3. 假设驱动器是 8细分，那就是把 1.8度再分成 8份；所以经过驱动器的电机每一步进就是 1.8度 / 8 = 0.225度；最终在 8细分下每转一圈就是 200 * 8 = 1600步进。\n4. 当导程为 5的丝杠，则每转一圈走 5毫米，每一步进就是 5 / 1600 = 0.003125毫米，这就是**电机参数**。如果是导程为 3的参数，那就是 0.001875毫米，以次类推。\n5. 用 1除以电机参数就是**脉冲当量**，例如: 1 / 0.003125 = 320步进，就是每走 1毫米需要多少步进。\n\n## 常规公式\n\n$ 步进电机运行步数 = 运行位移 / 导程 * 360 / 步距角 * 细分数 $\n\n这是用步进电机接丝杆做驱动时用的，就是计算步进数的式子：各个变量如下：\n\n1. 步进电机运行步进数 —— 这是你要计算的（也可以说是脉冲的数量），\n2. 运行位移 / 导程 —— 这是位移和导程的关系，这个除出来，就是移动这一段距离螺杆需要转几圈。\n3. 360 / 步距角 —— 因为正常步进电机是一个脉冲转一个步距角，这个算出来就是多少步电机转一圈。例如：步距角 = 7.5度，这样算出来是 48，这就是 48步就走一圈。\n4. 细分数 —— 一般情况这个数值是 1，但是采用了细分的方式驱动，可以控制电机一步只转半个步距角，这时细分数就为 2。合在上面式子里就会算出 96步转一圈。\n5. 最后将 2、3、4 相乘。\n\n\n\n# 参考：\n\n[步进电机驱动器简介（上）——步进电机的特点、分类和工作原理](http://news.eeworld.com.cn/mp/TOSHIBA/a22212.jspx)\n\n[步进电机驱动器简介（下）——步进电机的控制驱动和安全技术](http://news.eeworld.com.cn/mp/TOSHIBA/a22342.jspx)\n\n[步进电机基础知识：类型、用途和工作原理](https://www.monolithicpower.cn/cn/stepper-motors-basics-types-uses)","tags":["history","电机"]},{"title":"Kicad应用总结","url":"//docs/Kicad应用总结/","content":"\n\n\n> 在当前这个时代，对于 PCB设计，有太多的 EDA设计软件了，如：Cadence、PADS、Altium等，但绝大多数是要授权的，而且如今人们版权意识正在提高；这对电子爱好者来说，要想 DIY一个好东西，免不了依赖于这些设计软件，但如果有开源的、顺手的软件，那么我们更倾于应用这些软件，毕竟从版权意识上看以及投向开源社区来讲都是好的。\n\n\n\n## 简介\n\nKiCad 是一个开源软件工具，用于设计电子原理图和 PCB 图形。 \n\n其官网地址：https://www.kicad.org/\n\n各操作文档说明：https://docs.kicad.org/\n\n由于 KiCad 是一个开源软件，所以我们可以获取到它的源码：https://github.com/KiCad/kicad-source-mirror\n\n当然，基于开源，它实现了跨平台：\n\n![image-20210814170409099](image-20210814170409099.png)\n\n\n\n然后在正式开篇之前，以下这些说明都是基于 V5.1.9版本（最新版为 V5.1.10，修正了部分 Bug）；该死 V6.0版本居然还没发布，对于想要了解 V6.0版本的一些升级功能的，可以移到 [KiCad 6 is coming!](https://techexplorations.com/blog/kicad/kicad-6-review-new-and-improved-features/#t-1611031599240)\n\n<br/>\n\n## 入门\n\n### 工作流程\n\nKicad有着其独特的工作流程：\n\n![kicad_flowchart](kicad_flowchart.png)\n\n设计一个 PCB板，主要由两个任务来完成：绘制原理图和布置电路板。\n\n### 文件说明\n\nKiCad在创建并使用时具有以下特定扩展名文件和文件夹，其主要用于原理图和电路板编辑。\n\n1. 项目管理文件\n\n   | 文件扩展名 | 描述                                                         |\n   | ---------- | :----------------------------------------------------------- |\n   | *.pro      | Small file containing a few parameters for the current project, including the component library list. |\n\n2. 原理图编辑器文件\n\n   | 文件扩展名    | 描述                                                         |\n   | ------------- | :----------------------------------------------------------- |\n   | *.sch         | Schematic files, which do not contain the components themselves. |\n   | *.lib         | Schematic component library files, containing the component descriptions: graphic shape, pins, fields. |\n   | *.dcm         | Schematic component library documentation, containing some component descriptions: comments, keywords, reference to data sheets. |\n   | *_cache.lib   | Schematic component library cache file, containing a copy of the components used in the schematic project. |\n   | sym-lib-table | Symbol library list (symbol library table): list of symbol libraries available in the schematic editor. |\n\n3. 制板编辑文件和文件夹\n\n   | 文件扩展名   | 描述                                                         |\n   | ------------ | :----------------------------------------------------------- |\n   | *.kicad_pcb  | Board file containing all info but the page layout.          |\n   | *.pretty     | Footprint library folders. The folder itself is the library. |\n   | *.kicad_mod  | Footprint files, containing one footprint description each.  |\n   | *.brd        | Board file in the legacy format. Can be read, but not written, by the current board editor. |\n   | *.mod        | Footprint library in the legacy format. Can be read by the footprint or the board editor, but not written. |\n   | fp-lib-table | Footprint library list (footprint library table): list of footprint libraries (various formats) which are loaded by the board or the footprint editor or CvPcb. |\n\n4. 通用文件\n\n   | 文件扩展名  | 描述                                                         |\n   | ----------- | :----------------------------------------------------------- |\n   | *.kicad_wks | Page layout description files, for people who want a worksheet with a custom look. |\n   | *.net       | Netlist file created by the schematic, and read by the board editor. This file is associated to the .cmp file, for users who prefer a separate file for the component/footprint association. |\n\n5. 特殊文件\n\n   | 文件扩展名 | 描述                                                         |\n   | ---------- | ------------------------------------------------------------ |\n   | *.cmp      | Association between components used in the schematic and their footprints. It can be created by Pcbnew and imported by Eeschema. Its purpose is to import changes from Pcbnew to Eeschema, for users who change footprints inside Pcbnew (for instance using Exchange Footprints command) and want to import these changes in schematic. |\n\n6. 其他文件\n\n   主要是生产生成文件\n\n   | 文件扩展名 | 描述                                                         |\n   | ---------- | ------------------------------------------------------------ |\n   | *.gbr      | Gerber files, for fabrication.                               |\n   | *.drl      | Drill files (Excellon format), for fabrication.              |\n   | *.pos      | Position files (ASCII format), for automatic insertion machines. |\n   | *.rpt      | Report files (ASCII format), for documentation.              |\n   | *.ps       | Plot files (Postscript), for documentation.                  |\n   | *.pdf      | Plot files (PDF format), for documentation.                  |\n   | *.svg      | Plot files (SVG format), for documentation.                  |\n   | *.dxf      | Plot files (DXF format), for documentation.                  |\n   | *.plt      | Plot files (HPGL format), for documentation.                 |\n\n<br/>\n\n## 常用快捷键\n\n首先说明一下，热键（即单个按键）直接用字母表示；组合键（是指先按住第一个键不放，然后按下第二个键，再放开这两个键。）则用 “ + ” 表示；多次按键（是指先按下第一个键并放开，然后按下第二个键并放开，以此类推。）则用 “ - ” 表示。\n\n### 常规\n\n| 快捷键           | 功能     |\n| ---------------- | -------- |\n| Ctrl + N         | 新建     |\n| Ctrl + O         | 打开     |\n| Ctrl + S         | 保存     |\n| Ctrl + Shift + S | 另存为   |\n| Ctrl + Z         | 撤销     |\n| Ctrl + Y         | 重做     |\n| Ctrl + X         | 剪切     |\n| Ctrl + C         | 复制     |\n| Ctrl + V         | 粘贴     |\n| Ctrl + F         | 查找     |\n| F1               | 放大     |\n| F2               | 缩小     |\n| F3               | 缩放重绘 |\n| F4               | 缩放中心 |\n| Home             | 适合屏幕 |\n| E                | 编辑     |\n\n### 原理图\n\n| 快捷键   | 功能                 |\n| -------- | -------------------- |\n| C        | 重复的器件符号或标签 |\n| R        | 旋转                 |\n| M        | 移动                 |\n| A        | 添加器件符号         |\n| P        | 添加电源符号         |\n| X        | X轴镜像              |\n| Y        | Y轴镜像              |\n| W        | 画线                 |\n| B        | 放置总线             |\n| L        | 添加标签             |\n| H        | 添加分层标签         |\n| Ctrl + L | 添加全局标签         |\n| J        | 添加连接点           |\n| Q        | 添加禁止连接标志     |\n| F8       | 更新到 PCB           |\n\n### PCB\n\n| 快捷键           | 功能                                             |\n| ---------------- | ------------------------------------------------ |\n| O                | 放置封装                                         |\n| D                | 保持角度拖动布线                                 |\n| X                | 布线                                             |\n| Q                | 编辑线宽/过孔尺寸                                |\n| L                | 锁定/解锁封装                                    |\n| V                | 常规状态下，切换层；布线状态下，放置过孔并切换层 |\n| N / Shift + N    | 切换网格大小                                     |\n| Ctrl + H         | 板层高对比模式（单层显示）                       |\n| W / Shift + W    | 切换线宽                                         |\n| Ctrl             | 保持角度                                         |\n| /                | 布线轨迹切换                                     |\n| B                | 填充所有铜层区域                                 |\n| Ctrl + Shift + M | 测量                                             |\n| Alt + 6          | 差分布线                                         |\n| G                | 调整铜层区域                                     |\n\n### 库封装\n\n| 快捷键  | 功能     |\n| ------- | -------- |\n| M       | 移动     |\n| X       | X轴镜像  |\n| Y       | Y轴镜像  |\n| Instert | 重复引脚 |\n\n<br/>\n\n## 常用插件\n\n### 主题配色\n\n地址链接：https://github.com/pointhi/kicad-color-schemes\n\n例如笔者当前的主题配色为（**behave-dark**）：\n\n![eeschema](eeschema.png)\n\n![pcbnew](pcbnew.png)\n\n### 动态 BOM\n\n吾称之为最硬合交互式 BOM操作：\n\n![Interactive HTML BOM](capture.gif)\n\n地址链接：https://github.com/openscopeproject/InteractiveHtmlBom\n\n### 泪滴生成\n\n地址链接：https://github.com/NilujePerchut/kicad_scripts\n\n泪滴的作用，这里就不说啦，以前有讲过，然后演示：\n\n焊盘：\n\n![image-20210814210020179](image-20210814210020179.png)\n\n通孔：\n\n![image-20210814211109805](image-20210814211109805.png)\n\n<br/>\n\n## Pcbnew中各层用途说明\n\n### 所支持的板层\n\nKiCAD在 Pcbnew中总计提供了 32个铜层供导线走线（可覆铜），12个固定技术层（按照正反面分为 6对），2个独立技术层，4个辅助层。\n\n在 KiCad里 Pcbnew的层描述中：\n\n- F.代表电路板上层（Front），B.代表电路板的下层（Back）；\n\n- 6对固定技术层：Adhesive、Solder Paste、Silk Screen、Solder Mask、Courtyard、Fabrication；\n\n- 2个独立技术层：Edge Cuts、Margin；\n\n- 4个辅助层：Comments、E.C.O. 1、E.C.O. 2、Drawings；\n\n![image-20210814212055614](image-20210814212055614.png)\n\n### 层的使用说明\n\n#### 固定技术层\n\nKiCad中12个技术层分为 6对：上层一个，下层一个。可以通过 F.或者 B.来区分它们的位置。\n\n| 技术层名称                                | 功能描述                                                     |\n| ----------------------------------------- | ------------------------------------------------------------ |\n| Adhesive (F.Adhes and B.Adhes) 粘合层     | 用于在波峰焊前将 SMD元件的粘合剂粘贴到电路板上的粘合层。     |\n| Solder Paste (F.Paste and B.Paste) 焊膏层 | 用于在回流焊接之前生产掩模以允许焊膏放置在 SMD元件的焊盘上；通常这些层只有表面安装元件的焊盘。 |\n| Silk Screen (F.SilkS and B.SilkS) 丝印层  | 主要用于放置印制信息，如元件的轮廓和标注，各种注释字符等。   |\n| Solder Mask (F.Mask and B.Mask) 阻焊层    | 这两个层定义了焊接的掩模，即不过绿油的区域；所有焊盘都要出现在这两个层的其中一个层（SMD元件）或者所有两个层（通孔元件）以防止焊盘被过油，影响导电。 |\n| Courtyard (F.CrtYd and B.CrtYd) 空间层    | 用于显示元件在 PCB上实际占用的空间大小。                     |\n| Fabrication (F.Fab and B.Fab) 制造层      | 用于辅助元件贴装；主要用于记录目的，以将信息传达给例如 PCB 制造商或组装厂。 |\n\n#### 独立技术层\n\n| 技术层名称        | 功能描述                                                     |\n| ----------------- | ------------------------------------------------------------ |\n| Edge.Cuts 边界层  | 用于绘制电路板轮廓。一般用于设置电路板的外形尺寸，数据标记，对齐标记，装配说明以及其它的机械信息。所以请仅使用此图层绘制 PCB的轮廓。 |\n| Margin 电气边界层 | 用于定义在电路板上能够有效放置元件和布线的区域。             |\n\n#### 辅助层\n\n| 技术层名称            | 功能描述      |\n| --------------------- | ------------- |\n| E.C.O. 1/2 用户自定层 | 2层，用于拓展 |\n| Comments 注释层       | 描述性注释    |\n| Drawings 图层         | 图形说明      |\n\n这些层可以任意使用，它们可以是组装或布线等的说明文本，也可以是组装或加工的构造图，嘛，一般没啥用。\n\n#### 铜层\n\n该层在 Kicad中最多可拓展 32层。\n\n在 Pcbnew中任何铜层的名字都是可以编辑的，我们一般使用默认的名称。当电路板是 2层板时，只有 F.Cu层和 B.Cu层。当增加相应的层级数时，在 F.Cu层和 B.Cu层之间，将插入从上层到下层的顺序依次为 In1.Cu，In2.Cu，In3.Cu和 In4.Cu等的名称板层。\n\n1. 通常，电路板是 2层时，采用如下结构：\n\n   | 层编号 | 层名称 | 用途描述  |\n   | ------ | ------ | --------- |\n   | 1      | F.Cu   | Signal    |\n   | 2      | B.Cu   | GND Plane |\n\n2. 通常，电路板是 4层时，采用如下结构：\n\n   | 层编号 | 层名称 | 用途描述  |\n   | ------ | ------ | --------- |\n   | 1      | F.Cu   | Signal    |\n   | 2      | In1.Cu | GND Plane |\n   | 3      | In2.Cu | VCC Plane |\n   | 4      | B.Cu   | Signal    |\n\n3. 通常，电路板是 6层时，采用如下结构：\n\n   | 层编号 | 层名称 | 用途描述  |\n   | ------ | ------ | --------- |\n   | 1      | F.Cu   | Signal    |\n   | 2      | In1.Cu | GND Plane |\n   | 3      | In2.Cu | Signal    |\n   | 4      | In3.Cu | Signal    |\n   | 5      | In4.Cu | VCC Plane |\n   | 6      | B.Cu   | Signal    |\n\n4. 通常，电路板是 8层时，采用如下结构：\n\n   | 层编号 | 层名称 | 用途描述  |\n   | ------ | ------ | --------- |\n   | 1      | F.Cu   | Signal    |\n   | 2      | In1.Cu | GND Plane |\n   | 3      | In2.Cu | Signal    |\n   | 4      | In3.Cu | VCC Plane |\n   | 5      | In4.Cu | GND Plane |\n   | 6      | In5.Cu | Signal    |\n   | 7      | In6.Cu | VCC Plane |\n   | 8      | B.Cu   | Signal    |\n\n5. 通常，电路板是 10层时，采用如下结构：\n\n   | 层编号 | 层名称 | 用途描述  |\n   | ------ | ------ | --------- |\n   | 1      | F.Cu   | Signal    |\n   | 2      | In1.Cu | GND Plane |\n   | 3      | In2.Cu | Signal    |\n   | 4      | In3.Cu | Signal    |\n   | 5      | In4.Cu | VCC Plane |\n   | 6      | In5.Cu | GND Plane |\n   | 7      | In6.Cu | Signal    |\n   | 8      | In7.Cu | Signal    |\n   | 9      | In8.Cu | VCC Plane |\n   | 10     | B.Cu   | Signal    |\n\n<br/>\n\n## 生产制造\n\n在使用本操作时，假定您已经在 KiCad中完成了 PCB的设计。\n\n### 设置 PCB原点坐标\n\n选择 “菜单栏”，放置 -> 钻孔和位置偏移（或者在右边菜单栏直接选择），将原点放置到 PCB板框左下角位置，再放置【层对齐标记】到刚刚放置的原点位置。\n\n![image-20210814222049491](image-20210814222049491.png)\n\n### Gerber导出\n\n从菜单栏中点击绘制按键：\n\n![image-20210814220901206](image-20210814220901206.png)\n\n绘制 Gerber，并输出到相应文件夹：\n\n![image-20210814221059310](image-20210814221059310.png)\n\n绘制完后，点击旁边的 “生成钻孔文件” 进入设置生成：\n\n![image-20210814222350241](image-20210814222350241.png)\n\n生成文件放置到同样的文件夹，同时需要注意一下钻孔单位一般要对应 Pcbnew中所使用的单位。\n\n### BOM输出\n\n1. 从原理图输出\n\n   点击生成 BOM：\n\n   ![image-20210814230416366](image-20210814230416366.png)\n\n   选择生成插件：\n\n   ![image-20210814230521885](image-20210814230521885.png)\n\n   值得注意的是，在箭头处需要添加后缀 “**.csv**\"\n\n2. 从 PCB中输出\n\n   ![image-20210814231010230](image-20210814231010230.png)","tags":["EDA","kicad","history"]},{"title":"常用校验算法","url":"//docs/算法/常用校验算法/","content":"\n\n\n# 奇偶校验\n\n## 介绍\n\n**奇偶校验位**（英语：**parity bit**）或**校验比特**（英语：**check bit**）是一个表示给定位数的二进制数中1的个数是奇数还是偶数的二进制数。奇偶校验位是最简单的错误检测码。\n\n## 原理\n\n奇偶校验常见于串口数据收发，如其名，可分为奇校验和偶校验：\n\n- **奇校验：原始码流+校验位，其 “1” 的个数为奇数，则校验位为 “0”；若为偶数，则校验位为 “1”。**\n\n- **偶校验：原始码流+校验位，其 “1” 的个数为奇数，则校验位为 “1”；若为偶数，则校验位为 “0”。**\n\n奇校验是在每个字节后增加一个附加位，使得 “1” 的总数为奇数；而偶校验是在每个字节后增加一个附加位，使得 “1” 的总数为偶数。\n\neg：\n\n以**偶校验位**来说，如果一组给定数据位中1的个数是奇数，补一个bit为1，使得总的1的个数是偶数。例：0000001, 补一个bit为1, 0000001**1**。\n\n以**奇校验位**来说，如果给定一组数据位中1的个数是奇数，补一个bit为0，使得总的1的个数是奇数。例：0000001, 补一个bit为0, 0000001**0**。\n\n其原理是：假如采用奇校验，发送端发送的一个字符编码（含校验位）中，“1” 的个数一定为奇数个，在接收端对接收字符二进制位中的 “1” 的个数进行统计，若统计出 “1” 的个数为偶数个，则意味着传输过程中有 1位（或奇数位）发生差错。\n\n## 应用场景\n\n奇校验通常用于同步传输；偶校验常用于异步传输或低速传输。\n\n## 总结\n\n虽然这个校验应该算是校验算法中最简单的，可是它却有不足之处：\n\n如果数据传输过程只有奇数个码位变化，那么不管变化在哪我们都可以直接判断数据传输是错误的，但是一旦有偶数位发生了变化，或者出现移位情况，我们就无法检测到错误，该方法的校错率是 50%。\n\neg：\n\n奇校验 正确码流 `11000001`\n\n**错 1位** `11000011` 变成了偶数个 1，能检测出错误\n\n错 2位 `11001011` 变成了奇数个 1，检测不出错误\n\n出现移位 `11000010` 变成了奇数个 1，检测不出错误\n\n\n\n# 校验和\n\n## 介绍\n\n**校验和**（英语：Checksum）是冗余校验的一种形式。 它是通过错误检测方法，对经过空间（如通信）或时间（如计算机存储）所传送数据的完整性进行检查的一种简单方法。\n\n## 原理\n\n所谓校验和，就是将被校验数据进行 “累加”，并省略 “累加” 溢出的位，最终得到的 1个或多个字节的结果。这个 “累加”，可以是简单的整数加法校验，又或者是反码加法校验等等。\n\n一般常用的有：\n\n**A、整数加法校验和（Integer Addition Checksum）**\n\n其操作如加法运算一样，把数据值累加，最后省略高位。\n\n![image-20210506204818892](image-20210506204818892.png)\n\n在熟知其操作后，我们来看下误码率；假设传输数据以两个 bit为单位，进行传输两个两位数 `00b` 和 `00b` ，则该校验和为：00+00=00，那么在传输过程中其出现错码的数据有以下，那么来简单分析下本次校验出错的概率有多少：\n\n|         | 00b  | 01b  | 10b  | 11b  |\n| ------- | ---- | ---- | ---- | ---- |\n| **00b** | 00b  | 01b  | 10b  | 11b  |\n| **01b** | 01b  | 10b  | 11b  | 00b  |\n| **10b** | 10b  | 11b  | 00b  | 01b  |\n| **11b** | 11b  | 00b  | 01b  | 00b  |\n\n如上表所示，在传输两个两位数 `00b` 和 `00b` 时，会有其余三种组合相加校验和也是 00，所以有 3/16 的概率会校验出错的，约为 1/4；但当数据的位宽越大，校验出错概率越低。\n\n**B、反码加法校验和（One’s Complement Addition Checksum）**\n\n反码加法校验，实际就是先进行整数加法运算，然后将进位加回来。\n\n![image-20210506205712724](image-20210506205712724.png)\n\n该处理相对于上一个的整数加法校验，由于需要加上进位操作，所以校验出错概率比它低一点。\n\n## 补充\n\n由于有讲到 `One’s Complement`，所以在这里稍微说一下：one's-complement 和 two's-complement以及 one's complement sum和 two's complement sum。\n\n- **one's-complement 和 two's-complement**\n\n  前者表示：反码，高位为符号位；后者表示：补码，高位为符号位。\n\n  ![image-20210506210446251](image-20210506210446251.png)\n\n  参考：https://tutorialspoint.dev/computer-science/computer-organization-and-architecture/whats-difference-between-1s-complement-and-2s-complement\n\n- **one's complement sum和 two's complement sum**\n\n  前者表示：反码加法，需要加上进位；\n\n  ![image-20210506210955942](image-20210506210955942.png)\n\n  后者表示：补码加法，舍弃进位。\n\n  ![image-20210506210936345](image-20210506210936345.png)\n\n  参考：《Short description of the Internet checksum》\n\n\n\n# 纵向冗余校验（LRC）\n\n## 介绍\n\n纵向冗余校验（LRC）是一种从纵向通道上的特定比特串产生校验比特的错误检测方法；而最常用的是 **LRC-8**错误检验，除此之外，还有 **LRC-16**、 **LRC-32**，它们是逐字节的奇偶校验计算，通过将数据字的所有字节异或在一起，生成一个对应字节的校验数。下面以 LRC-8为说明。\n\n## 原理\n\n通过对数据拆分为单字节，并利用纵向排列，把对应的字节位异或计算，最终得到一个单字节校验数：\n\n![image-20220327112126895](image-20220327112126895.png)\n\n## 应用处理\n\n![image-20220327113147917](image-20220327113147917.png)\n\n然后，它有什么特点呢：\n\n- 可以检测垂直切片分析中所有奇数的比特错误\n- 无法检测垂直切片分析中偶数个比特的错误\n- 可以检测所有 1位错误或检测单个字节内的所有错误\n- 可以检测多个 2位错误，但并不是所有的 2位错误类型都可检测到\n\n所以，最终得到的是：在检测同一垂直切片分析中的任何 2位（bit）出现错误都是不可检测的。\n\n最后附一张到目前介绍为止的检测概率图：\n\n![image-20220327114446012](image-20220327114446012.png)\n\n\n\n# 循环冗余校验（CRC）\n\n## 介绍\n\n**循环冗余校验**（英语：**Cyclic redundancy check**，通称“**CRC**”）是一种根据网络数据包或电脑文件等数据产生简短固定位数校验码的一种散列函数，主要用来检测或校验数据传输或者保存后可能出现的错误。生成的数字在传输或者存储之前计算出来并且附加到数据后面，然后接收方进行检验确定数据是否发生变化。由于本函数易于用二进制的电脑硬件使用、容易进行数学分析并且尤其善于检测传输通道干扰引起的错误，因此获得广泛应用。\n\n## CRC多项式\n\n多项式的选择是 CRC算法实现中最重要的部分，所选择的多项式必须有最大的错误检测能力，同时保证总体的碰撞概率最小。多项式最重要的属性是它的长度，也就是最高非零系数的数值，因为它直接影响着计算的校验和的长度。\n\n最常用的多项式长度有\n\n- 9位（CRC-8）\n- 17位（CRC-16）\n- 33位（CRC-32）\n- 65位（CRC-64）\n\n在构建一个新的 CRC多项式或者改进现有的 CRC时，一个通用的数学原则是使用满足所有模运算不可分解多项式约束条件的多项式。\n\n- 这种情况下的不可分解是指多项式除了 1与它自身之外不能被任何其它的多项式整除。\n\n生成多项式的特性可以从算法的定义中推导出来：\n\n- 如果 CRC有多于一个的非零系数，那么 CRC能够检查出输入消息中的所有单数据位错误。\n- CRC可以用于检测短于 2k的输入消息中的所有双位错误，其中k是多项式的最长的不可分解部分的长度。\n- 如果多项式可以被 x+1整除，那么不存在可以被它整除的有奇数个非零系数的多项式。因此，它可以用来检测输入消息中的奇数个错误，就像奇偶校验函数那样。\n\n## 多项式与二进制数码\n\n假设一个多项式为 `G(x)=x^4+x^3+x+1`， 可转换为二进制数码 `11011b`。\n\n等式 `G(X)=x^4+x^3+x+1`，可以写成 `G(X) = 1*(X^4) + 1*(X^3) + 0*(X^2) + 1*(X^1) + 1*(X^0)`\n\n总结：有幂次就为 1，没有幂次就为 0，首尾一定要是 1， 所以 `G(x)=x^4+x^3+x+1`为 `11011b`。\n\n## CRC校验核心\n\n从上面可以看出，CRC校验中有两个关键点：\n\n- 一是要预先确定一个发送端和接收端都用来作为除数的二进制比特串（或多项式）；\n- 二是把原始帧与上面选定的除进行二进制除法运算，计算出 FCS。\n\n前者可以随机选择，也可按国际上通行的标准选择，但**最高位和最低位必须均为 “1”**，如在 IBM的 SDLC（同步数据链路控制）规程中使用的 CRC-16（也就是这个除数一共是17位）生成多项式 `G（x）= x^16 + x^15 + x^2 +1`（对应二进制比特串为：`11000000000000101b`）；而在 ISO HDLC（高级数据链路控制）规程、ITU的 SDLC、X.25、V.34、V.41、V.42等中使用 CCITT-16生成多项式 `G（x）= x^16 + x^15 + x^5 +1`（对应二进制比特串为：`11000000000100001b`）。\n\n## 校验原理\n\nCRC算法的是以GF(2)(2元素伽罗瓦域)多项式算术为数学基础的，原理看起来比较复杂、好难懂，但实际上它的主要特点和运算规则是很好理解的。\n\n在 CRC算法中，其运算法制使用 “模 2算术”运算。\n\n**A、模 2加减法运算**\n\n- 模 2加法运算：1+1=0，0+1=1，0+0=0，无进位，也无借位\n- 模 2减法运算：1-1=0，0-1=1，1-0=1，0-0=0，无进位，也无借位\n\n   显然，加和减是一样的效果(故在GF(2)多项式中一般不出现 \"-\" 号)，相当于二进制中的逻辑异或运算；也就是相互比较后，两者对应位相同则结果为 “0”，不同则结果为 “1”。\n\neg：\n\n多项式：`P1 = x^3 + x^2 + 1，P2 = x^3 + x^1 + 1，P1 + P2 = `\n\n```\n      x^3 + x^2       + 1\n  +   x^3       + x^1 + 1\n  ------------------------------\n            x^2 + x^1\n```\n二进制：`P1 = 1101，P2 = 1011，P1 + P2 = `\n\n```\n      1 1 0 1\n  +   1 0 1 1\n  --------------\n        1 1 0\n```\n\n**B、模 2乘法运算**\n\nGF(2)多项式乘法和一般多项式乘法基本一样，只是在各项相加的时候按模 2算术进行，同样的，无进位，也无借位。\n\neg：\n多项式：`P1 = x^3 + x^2 + 1，P2 = x^3 + x^1 + 1，P1 x P2 = `\n\n```\n  (x^3 + x^2 + 1) (x^3 + x^1 + 1)  \n  = (x^6 + x^4 + x^3\n    + x^5 + x^3 + x^2\n    + x^3 + x + 1)\n  = x^6 + x^5 + x^4 + x^3 + x^2 + x + 1\n```\n二进制：`P1 = 1101，P2 = 1011，P1 x P2 = `\n\n```\n          1 1 0 1\n x        1 0 1 1\n --------------------\n\t      1 1 0 1\n\t    1 1 0 1\n\t  0 0 0 0\n +  1 1 0 1     \n --------------------\n    1 1 1 1 1 1 1\n```\n**C、模 2除法运算**\n\n多项式：`P1 = x^5 + x^2 + 1，P2 = x^3 + x^2 + x^1，P1 / P2 = `\n\n```\n                                      x^2   x^1\n                   ----------------------------------\n x^3 + x^2 + x^1  ) x^5             + x^2       + 1\n                    x^5 + x^4 + x^3\n                   ----------------------------------\n                          x^4 + x^3 + x^2\n                          x^4 + x^3 + x^2\n                   ----------------------------------\n                                                  1                          \n```\n二进制：`P1 = 100101，P2 = 1110，P1 x P2 = `\n\n```\n                          1 1\n                   ---------------\n          1 1 1 0 ) 1 0 0 1 0 1\n                    1 1 1 0\n                   ---------------\n                      1 1 1 0\n                      1 1 1 0\n                   ---------------\n                              1         \n```\n\n\n 具体来说，CRC校验原理就是以下几个步骤：\n\n   （1）先选择（可以随机选择，也可按标准选择，具体在后面介绍）一个用于在接收端进行校验时，对接收的帧进行除法运算的除数（是二进制比较特串，通常是以多项方式表示，所以 CRC又称多项式编码方法，这个多项式也称之为“生成多项式”）。\n\n   （2）看所选定的除数二进制位数（假设为k位），然后在要发送的数据帧（假设为m位）后面加上 k-1位 “0”，然后以这个加了 k-1个 “0“的新帧（一共是 m+k-1位）以 “模 2除法”方式除以上面这个除数，所得到的余数（也是二进制的比特串）就是该帧的 CRC校验码，也称之为 FCS（帧校验序列）。但要注意的是，余数的位数一定要是比除数位数只能少一位，哪怕前面位是 0，甚至是全为 0（附带好整除时）也都不能省略。\n\n   （3）再把这个校验码附加在原数据帧（就是 m位的帧，注意不是在后面形成的 m+k-1位的帧）后面，构建一个新帧发送到接收端，最后在接收端再把这个新帧以 “模 2除法” 方式除以前面选择的除数，如果没有余数，则表明该帧在传输过程中没出错，否则出现了差错。\n\n![image-20210523204223295](image-20210523204223295.png)\n\n## 计算步骤\n\n假设以最常用的 CRC-16_MODBUS为例：\n\n（1）、预置 1个16位的寄存器值 0xFFFF，称此寄存器为CRC寄存器；\n\n（2）、把第一个 8位二进制数据（既通讯信息帧的第一个字节）与 16位的 CRC寄存器的低 8位相异或，把结果放于 CRC寄存器，高八位数据不变；\n\n（3）、把 CRC寄存器的内容右移一位（朝高位）用 0填补最高位，并检查右移后的移出位；\n\n（4）、如果移出位为 0则重复第 3步（再次右移一位）；如果移出位为1，那么将 CRC寄存器与一多项式（A001）进行异或；\n\n（5）、重复步骤 3和 4，直到右移 8次，这样整个 8位数据全部进行了处理；\n\n（6）、重复步骤 2到步骤 5，进行通讯信息帧下一个字节的处理；\n\n（7）、将该通讯信息帧所有字节按上述步骤计算完成后，得到的 16位CRC寄存器的高、低字节进行交换；\n\n（8）、最后得到的 CRC寄存器内容即为：CRC码。\n\n以上计算步骤中的多项式 A001是 8005按位颠倒后的结果。\n\n## CRC-16实现代码\n\n常用 CRC-16码表：\n\n| Algorithm         | Poly   | Init   | RefIn | RefOut | XorOut |\n| ----------------- | ------ | ------ | ----- | ------ | ------ |\n| CRC16_CCITT       | 0x1021 | 0x0000 | true  | true   | 0x0000 |\n| CRC16_CCITT_FALSE | 0x1021 | 0xFFFF | false | false  | 0x0000 |\n| CRC16_XMODEM      | 0x1021 | 0x0000 | false | false  | 0x0000 |\n| CRC16_X25         | 0x1021 | 0xFFFF | true  | true   | 0xFFFF |\n| CRC16_MODBUS      | 0x8005 | 0xFFFF | true  | true   | 0x0000 |\n| CRC16_IBM         | 0x8005 | 0x0000 | true  | true   | 0x0000 |\n| CRC16_MAXIM       | 0x8005 | 0x0000 | true  | true   | 0xFFFF |\n| CRC16_USB         | 0x8005 | 0xFFFF | true  | true   | 0xFFFF |\n\n这里只演示常用的 CRC-16的部分程序：\n\n![image-20210506233502474](image-20210506233502474.png)\n\n","tags":["history","校验"],"categories":["算法"]},{"title":"cJSON库 API解析（下）","url":"//docs/cJSON/cJSON库 API解析（下）/","content":"\n\n\n> 继上一篇 [cJSON库 API解析（上）]()，本篇为下篇，以解析 JSON数据包为主\n\n\n\n# JSON数据解析\n\n在 cJSON里，解析 JSON数据包，其实就是通过搜寻对应的配对关键符号或者关键字，然后一个一个剥离成为链表节点(键值对)的过程。\n\n其所支持的解析函数有以下几个：\n\n- `CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value);`\n\n- `CJSON_PUBLIC(cJSON *) cJSON_ParseWithLength(const char *value, size_t buffer_length);`\n\n- `CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated);`\n\n- `CJSON_PUBLIC(cJSON *) cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated);`\n\n但一般来说，平常我们只需要用到 cJSON_Parse();函数来解析。同样的，在调用了 parse函数后，使用完毕需要调用 cJSON_Delete();及时释放；\n\n整个解析过程，其核心操作函数为：\n\n```c\n/* Parser core - when encountering text, process appropriately. */\nstatic cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)\n{\n    if ((input_buffer == NULL) || (input_buffer->content == NULL))\n    {\n        return false; /* no input */\n    }\n\n    /* parse the different types of values */\n    /* null */\n    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), \"null\", 4) == 0))\n    {\n        item->type = cJSON_NULL;\n        input_buffer->offset += 4;\n        return true;\n    }\n    /* false */\n    if (can_read(input_buffer, 5) && (strncmp((const char*)buffer_at_offset(input_buffer), \"false\", 5) == 0))\n    {\n        item->type = cJSON_False;\n        input_buffer->offset += 5;\n        return true;\n    }\n    /* true */\n    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), \"true\", 4) == 0))\n    {\n        item->type = cJSON_True;\n        item->valueint = 1;\n        input_buffer->offset += 4;\n        return true;\n    }\n    /* string */\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '\\\"'))\n    {\n        return parse_string(item, input_buffer);\n    }\n    /* number */\n    if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9'))))\n    {\n        return parse_number(item, input_buffer);\n    }\n    /* array */\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '['))\n    {\n        return parse_array(item, input_buffer);\n    }\n    /* object */\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '{'))\n    {\n        return parse_object(item, input_buffer);\n    }\n\n    return false;\n}\n```\n\n就像前面说的，通过搜寻对应的配对关键符号或者关键字去调用不同的处理函数，然后配对校验，并把相应的数据插入到根结点，形成一个个相连的子节点链表。\n\n\n\n# JSON数据获取\n\n当调用完上面的解析函数后，返回的是根结点指针，通过这个 cJSON的结构指针，我们就可以利用其解析后每个节点所对应的类型，快速寻找同类型的数据，再根据提供的键（名称）来获取数据。\n\n下面就来认识一下常用的 API函数：\n\n**1、类型校验：**\n\n- False：`CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item);`\n\n- True：`CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item);`\n\n- 布尔值：`CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item);`\n\n- null：`CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item);`\n\n- 数值：`CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item);`\n\n- 字符串：`CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item);`\n\n- 数组：`CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item);`\n\n- 对象：`CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item);`\n\n不难发现，这些函数都是用于判断参数的类型的，因此返回值只有 true（真）和 false（假）；用的比较多的是 cJSON_IsFalse();和 cJSON_IsTrue();，直接判断 JSON数据包里的布尔变量。\n\n**2、信息提取：**\n\n- 数组：`CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index);`\n\n- 对象：`CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string);`\n\n- 对象（名称区分大小写）：`CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string);`\n\n**3、校验类型并返回值：**\n\n- 字符串：`CJSON_PUBLIC(char *) cJSON_GetStringValue(const cJSON * const item);`\n\n- 数值：`CJSON_PUBLIC(double) cJSON_GetNumberValue(const cJSON * const item);`\n\n**4、获取项目数：**\n\n- `CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array);`\n\n**5、错误分析：**\n\n- `CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void);`\n\n\n\n# 示例\n\n以上篇打印的封装的数据信息为例；\n\n原封装的 JSON数据包：\n\n```json\n{\n  \"name\": \"cJSON\",\n  \"version\": \"v1.7.14\",\n  \"file\": {\n    \"name\": \"cJSON.c\",\n    \"size\": 75.8,\n    \"unit\": \"KB\"\n  },\n  \"released\": [\n    2020,\n    \"Sep\",\n    3\n  ],\n  \"latest\": true\n}\n```\n\n随后解析打印出来的信息：\n\n```tex\nname:cJSON\nversion:v1.7.14\n\nfile:cJSON.c\nsize:75.800000\nunit:KB\n\nreleased date:2020 Sep 3\n\nIs it necessary to update?\nnot update\n```\n\n代码执行（沿用上篇的封装代码）：\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"cJSON.h\"\n\n\nint main(int argc, char *argv[])\n{\n    cJSON *jtest = NULL;\n    cJSON *jfile = NULL;\n    cJSON *jissue = NULL;\n    cJSON *jyear = NULL;\n    cJSON *jmonth = NULL;\n    cJSON *jday = NULL;\n    char *str = NULL;\n\n    /* 创建一个 JSON格式的主对象(主链表头结点) */\n    jtest = cJSON_CreateObject();\n\n    /* 追加字符串类型的 JSON数据到主对象中(添加一个链表节点) */\n    cJSON_AddStringToObject(jtest, \"name\", \"cJSON\");\n    cJSON_AddStringToObject(jtest, \"version\", \"v1.7.14\");\n\n    /* 追加一个对象到主对象中(添加一个链表节点) */\n    jfile = cJSON_AddObjectToObject(jtest, \"file\");\n    /* 往追加的对象添加对应的值 */\n    cJSON_AddStringToObject(jfile, \"name\", \"cJSON.c\");\n    cJSON_AddNumberToObject(jfile, \"size\", 75.8);\n    cJSON_AddStringToObject(jfile, \"unit\", \"KB\");\n\n    /* 创建一个 JSON格式的数组(另一个链表头结点) */\n    jissue = cJSON_CreateArray();\n    /* 创建相应的值并把这些值添加到数组里 */\n    jyear = cJSON_CreateNumber(2020);\n    cJSON_AddItemToArray(jissue, jyear);\n    jmonth = cJSON_CreateString(\"Sep\");\n    cJSON_AddItemToArray(jissue, jmonth);\n    jday = cJSON_CreateNumber(3);\n    cJSON_AddItemToArray(jissue, jday);\n    /* 把已经填好的数据的数组插入到主对象中 */\n    cJSON_AddItemToObject(jtest, \"released\", jissue);\n\n    /* 追加一个值为 True的布尔类型的 JSON数据到主对象中(添加一个链表节点) */\n    cJSON_AddTrueToObject(jtest, \"latest\");\n\n    /* 打印 JSON对象(整条链表)的所有数据 */\n    str = cJSON_Print(jtest);\n    printf(\"%s\\n\\n\", str);\n    \n    /* 释放整条链表的内存数据 */\n    cJSON_Delete(jtest);\n\n/* ------------------------- 以上为上篇的封装代码 ------------------------- */\n\n\n/* ------------------------- 数据保留并初始化变量 ------------------------- */    \n    jtest = NULL;\n    jfile = NULL;\n    jissue = NULL;\n    jyear = NULL;\n    jmonth = NULL;\n    jday = NULL;\n    cJSON *jtemp = NULL;\n    \n/* ------------------------- 以下为本篇的解析代码 ------------------------- */\n\n    /* 解析整段 JSON数据 */\n    jtest = cJSON_Parse(str);\n    if (jtest == NULL)\n    {\n        printf(\"parse fail.\\n\");\n        return -1;\n    }\n\n    /* 依次根据名称提取 JSON数据（键值对） */\n    jtemp = cJSON_GetObjectItem(jtest, \"name\");\n    printf(\"name:%s\\n\", jtemp->valuestring);\n    jtemp = cJSON_GetObjectItem(jtest, \"version\");\n    printf(\"version:%s\\n\\n\", jtemp->valuestring);\n\n    /* 解析嵌套的 JSON对象 */\n    jfile = cJSON_GetObjectItem(jtest, \"file\");\n    jtemp = cJSON_GetObjectItem(jfile, \"name\");\n    printf(\"file:%s\\n\", jtemp->valuestring);\n    jtemp = cJSON_GetObjectItem(jfile, \"size\");\n    printf(\"size:%f\\n\", jtemp->valuedouble);\n    jtemp = cJSON_GetObjectItem(jfile, \"unit\");\n    printf(\"unit:%s\\n\\n\", jtemp->valuestring);\n\n    /* 解析嵌套的 JSON数组 */\n    jissue = cJSON_GetObjectItem(jtest, \"released\");\n    jyear = cJSON_GetArrayItem(jissue, 0);\n    jmonth = cJSON_GetArrayItem(jissue, 1);\n    jday = cJSON_GetArrayItem(jissue, 2);\n    printf(\"released date:%d \", jyear->valueint);\n    printf(\"%s \", jmonth->valuestring);\n    printf(\"%d\\n\\n\", jday->valueint);\n\n    /* 解析布尔型数据 */\n    printf(\"Is it necessary to update?\\n\");\n    jtemp = cJSON_GetObjectItem(jtest, \"latest\");\n    cJSON_IsTrue(jtemp) ? printf(\"not update\") : printf(\"update\");\n    /* 等同于 cJSON_IsFalse(jtemp) ? printf(\"update\") : printf(\"not update\"); */\n    printf(\"\\n\\r\");\n\n    cJSON_Delete(jtest);\n    \n    cJSON_free(str);\n\n    return 0;\n}\n```\n\n实例：\n\n![image-20210131224342050](image-20210131224342050.png)\n\n\n\n#  内存管理\n\n**1、cJSON_Delete();函数**\n\n```c\n/* Delete a cJSON structure. */\nCJSON_PUBLIC(void) cJSON_Delete(cJSON *item)\n{\n    cJSON *next = NULL;\n    while (item != NULL)\n    {\n        next = item->next;\n        if (!(item->type & cJSON_IsReference) && (item->child != NULL))\n        {\n            cJSON_Delete(item->child);\n        }\n        if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))\n        {\n            global_hooks.deallocate(item->valuestring);\n        }\n        if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))\n        {\n            global_hooks.deallocate(item->string);\n        }\n        global_hooks.deallocate(item);\n        item = next;\n    }\n}\n```\n\n通过上面的代码可以了解到，当调用 cJSON_Delete();函数后，会通过 while循环一直从当前节点删除释放其后面的节点，直至到尾部结点 null节点为止；因此，在应用中，一般都是传入主链表的头结点来释放整个 JSON数据包。\n\n**2、cJSON_Hooks里的钩子函数**\n\n在 cJSON项目里面，是留有 cJSON_InitHooks();外部引用内存管理函数的 API接口的，其原型：\n\n`CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks);`\n\n通过结构体 struct cJSON_Hooks跟内部调用的内存分配挂钩，其 Hooks原型：\n\n```c\ntypedef struct cJSON_Hooks\n{\n      /* malloc/free are CDECL on Windows regardless of the default calling convention of the compiler, so ensure the hooks allow passing those functions directly. */\n      void *(CJSON_CDECL *malloc_fn)(size_t sz);\n      void (CJSON_CDECL *free_fn)(void *ptr);\n} cJSON_Hooks;\n```\n\n一般情况是默认不调用 cJSON_InitHooks();函数的，因此，其内存分配管理处于默认状态，使用的是以下标准内存分配函数：\n\n```c\n#if defined(_MSC_VER)\n/* work around MSVC error C2322: '...' address of dllimport '...' is not static */\nstatic void * CJSON_CDECL internal_malloc(size_t size)\n{\n    return malloc(size);\n}\nstatic void CJSON_CDECL internal_free(void *pointer)\n{\n    free(pointer);\n}\nstatic void * CJSON_CDECL internal_realloc(void *pointer, size_t size)\n{\n    return realloc(pointer, size);\n}\n#else\n#define internal_malloc malloc\n#define internal_free free\n#define internal_realloc realloc\n#endif\n```\n\n如此一来，假设我们在系统上跑了 FreeRTOS（或者其他 RTOS），那么，在默认情况下，如果使用其标准内存分配函数，这样，对于多线程来讲是不安全的，所以，可以利用该函数重新把内存分配函数定义调用；例如在 FreeRTOS中：\n\n```c\ncJSON_Hooks cJSON_mem;\n\ncJSON_mem.malloc_fn = pvPortMalloc;\ncJSON_mem.free_fn = vPortFree;\ncJSON_InitHooks(&cJSON_mem);\n```\n\n通过该钩子函数，把 cJSON内部调用的内存分配处理，更换为线程安全的 pvPortMalloc();和 vPortFree();函数。\n\n**3、cJSON_malloc();和 cJSON_free();**\n\n其原型分别为：\n\n```c\nCJSON_PUBLIC(void *) cJSON_malloc(size_t size);\nCJSON_PUBLIC(void) cJSON_free(void *object);\n```\n一般来说，cJSON_malloc();很少用，因为 cJSON的数据处理 API函数都默认会自动分配内存；而 cJSON_free();则更多的是用来 free cJSON格式化出来的数据（即调用 print类的 API接口）。\n\n","tags":["history","JSON"],"categories":["middleware"]},{"title":"cJSON库 API解析（上）","url":"//docs/cJSON/cJSON库 API解析（上）/","content":"\n\n\n> cJSON项目可以说是一个很适合学习及应用 C语言中的链表的项目，刨析它的源码，你会惊叹它设计之巧妙，其代码为之简洁；同时，在嵌入式应用场景中也经常发现它的身影。\n>\n> 本系列分为上下两篇，其中上篇以应用分析其 JSON数据封装为主。\n\n\n\n# 介绍\n\n在认识 cJSON之前，先来认识一下 JSON：\n\n**JSON**（**J**ava**S**cript **O**bject **N**otation，JavaScript对象表示法，读作/ˈdʒeɪsən/）是一种由道格拉斯·克罗克福特构想和设计、轻量级的资料交换语言，该语言以易于让人阅读的文字为基础，用来传输由属性值或者序列性的值组成的数据对象。JSON采用完全独立于语言的文本格式，但是也使用了类似于 C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使 JSON成为理想的数据交换语言。\n\n其官网：https://www.json.org/json-en.html\n\n而 cJSON，顾名思义就是一个使用 C 语言编写的 JSON 数据解析器，目前 cJSON 项目托管在 Github上，仓库地址如下：https://github.com/DaveGamble/cJSON；以前的旧版本则是存放在：https://sourceforge.net/projects/cjson/files/上面，但现已停止更新，继而转到 Github上了。\n\n\n\n# JSON语法\n\nJSON的基本数据类型：\n\n1. 对象（*object*）：若干无序的 “键值对” (key-value pairs)，其中键是数值或字符串，以花括号 `{` 开始，并以 `}` 结束。\n2. 数组 / 值的有序列表（array）：有序的零个或者多个值，使用方括号 `[ ]` 括起来。\n3. 字符串（*string*）：以双引号 `\" \"` 括起来的零个或多个 Unicode码位。支持反斜杠开始的转义字符序列。\n\n4. 数值（*number*）：不区分整数与浮点数。JavaScript用双精度浮点数 double表示所有数值。\n5. 布尔值（*boolean*）：表示为 `true` 或者 `false` 。\n6. null 类型：值写为 `null`\n\n\n\n1、JSON 对象是一个若干无序的 \"名称 /值\" 键值对的集合：\n\n- 以 \"`{`\" 开始，以 \"`}`\" 结束，允许嵌套使用；\n- 每个名称和值成对出现，名称和值之间使用 \"`:`\" 分隔；\n- 键值对之间用 \"`,`\" 分隔\n- 在这些字符前后允许存在无意义的空白符；\n\n\n\n2、JSON 数组是一个有序的零个或者多个值的序列表：\n\n- 以 \"`[`\" 开始，以 \"`]`\" 结束，允许嵌套使用；\n- 每个值可以为任意类型，可以是双引号括起来的字符串（*string*）、数值（*number*）、`true`、`false`、 `null`、对象（*object*）或者数组（*array*）；\n- 元素之间用 \"`,`\" 分隔\n- 在这些元素前后允许存在无意义的空白符；\n\n\n\n# cJSON结构\n\n在下载的 cJSON源码中，实际用到的文件只有两个（cJSON.c和 cJSON.h），因此 cJSON具有超轻便，可移植，单文件的特点。\n\n对于 cJSON文件，整个的数据结构就主要用到以下结构体：\n\n```c\n/* The cJSON structure: */\ntypedef struct cJSON\n{\n    /* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */\n    struct cJSON *next;\n    struct cJSON *prev;\n    /* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */\n    struct cJSON *child;\n\n    /* The type of the item, as above. */\n    int type;\n\n    /* The item's string, if type==cJSON_String  and type == cJSON_Raw */\n    char *valuestring;\n    /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */\n    int valueint;\n    /* The item's number, if type==cJSON_Number */\n    double valuedouble;\n\n    /* The item's name string, if this item is the child of, or is in the list of subitems of an object. */\n    char *string;\n} cJSON;\n```\n\n从上面的代码可以看出，cJSON的设计思想是 --- 链表。\n\n然后我们分析一下各部分的成员信息：\n\n- `type`：用于表示该键值对中值的类型；\n- `valuestring`：如果键值类型 (type) 是字符串，则将该指针指向键值；\n- `valueint`：如果键值类型 (type) 是整数，则将该指针指向键值；\n- `valuedouble`：如果键值类型 (type) 是浮点数，则将该指针指向键值；\n- `String`：用于表示当前键值对的名称；\n\n还有两个 cJSON格式的结构体指针：\n\n- `next`：指向下一个键值对\n- `prev`：指向上一个键值对\n\n最后一个 cJSON格式的结构体指针：\n\n- `child`：该子指针指向当前数组 /对象中的节点\n\n\n\n如果是想要分析 cJSON它的代码设计，除开那两个承接上下节点的 `next` 和 `prev` 结构体指针，那么你还要重点关注上面说到 `type` 成员，它支持以下定义：\n\n> The type can be one of the following:\n>\n> - `cJSON_Invalid` (check with `cJSON_IsInvalid`): Represents an invalid item that doesn't contain any value. You automatically have this type if you set the item to all zero bytes.\n> - `cJSON_False` (check with `cJSON_IsFalse`): Represents a `false` boolean value. You can also check for boolean values in general with `cJSON_IsBool`.\n> - `cJSON_True` (check with `cJSON_IsTrue`): Represents a `true` boolean value. You can also check for boolean values in general with `cJSON_IsBool`.\n> - `cJSON_NULL` (check with `cJSON_IsNull`): Represents a `null` value.\n> - `cJSON_Number` (check with `cJSON_IsNumber`): Represents a number value. The value is stored as a double in `valuedouble` and also in `valueint`. If the number is outside of the range of an integer, `INT_MAX` or `INT_MIN` are used for `valueint`.\n> - `cJSON_String` (check with `cJSON_IsString`): Represents a string value. It is stored in the form of a zero terminated string in `valuestring`.\n> - `cJSON_Array` (check with `cJSON_IsArray`): Represent an array value. This is implemented by pointing `child` to a linked list of `cJSON` items that represent the values in the array. The elements are linked together using `next` and `prev`, where the first element has `prev.next == NULL` and the last element `next == NULL`.\n> - `cJSON_Object` (check with `cJSON_IsObject`): Represents an object value. Objects are stored same way as an array, the only difference is that the items in the object store their keys in `string`.\n> - `cJSON_Raw` (check with `cJSON_IsRaw`): Represents any kind of JSON that is stored as a zero terminated array of characters in `valuestring`. This can be used, for example, to avoid printing the same static JSON over and over again to save performance. cJSON will never create this type when parsing. Also note that cJSON doesn't check if it is valid JSON.\n>\n> Additionally there are the following two flags:\n>\n> - `cJSON_IsReference`: Specifies that the item that `child` points to and/or `valuestring` is not owned by this item, it is only a reference. So `cJSON_Delete` and other functions will only deallocate this item, not its `child`/`valuestring`.\n> - `cJSON_StringIsConst`: This means that `string` points to a constant string. This means that `cJSON_Delete` and other functions will not try to deallocate `string`.\n\n<br/>\n\n\n\n# JSON数据封装\n\n封装一个 JSON格式的数据包，其实就是创建链表和向链表中添加节点的过程。\n\n在 cJSON源码里面是存放着很多 API接口的，但是，一般来说我们并不是全部用到，而且有些函数是辅助函数，例如：\n\n```c\ncJSON *Info;\nInfo = cJSON_CreateObject();\ncJSON_AddStringToObject(Info, \"Nationality\", \"China\");\n\n/* 等价于 */\n\ncJSON *Info, *jtext;\nInfo = cJSON_CreateObject();\njtext = cJSON_CreateString(\"China\");\ncJSON_AddItemToObject(Info, \"Nationality\", jtext);\n```\n\n然后下面就分析一些常用的 API函数：\n\n**1、创建原始框架：**\n\n- 数组（等于创建了一个空的 `[ ]`）：`CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void);`\n- 对象（等于创建了一个空的 `{ }`）：`CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void);`\n\n**2、追加类型值：**\n\n- 数组：`CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToArray(cJSON *array, cJSON *item);`\n\n- 对象：`CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item);`\n\n**3、追加对应的值到对象中：**\n\n- null：`CJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name);`\n- True：`CJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name);`\n- False：`CJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name);`\n- 布尔值（实际为 True和 False合并）：`CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean);`\n- 数值：`CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number);`\n- 字符串：`CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string);`\n- 对象：`CJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name);`\n- 数组：`CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name);`\n\n**4、创建同一类型的值到数组中：**\n\n- 整形：`CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count);`\n- 单精度：`CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count);`\n- 双精度：`CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count);`\n- 字符串：`CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char *const *strings, int count);`\n\n**5、创建对应类型的值**\n\n- null：`CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void);`\n- True：`CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void);`\n- False：`CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void);`\n- 布尔值：`CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean);`\n- 数值：`CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num);`\n- 字符串：`CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string);`\n\n\n\n# 示例\n\n```json\n{\n  \"name\": \"cJSON\",\n  \"version\": \"v1.7.14\",\n  \"file\": {\n    \"name\": \"cJSON.c\",\n    \"size\": 75.8,\n    \"unit\": \"KB\"\n  },\n  \"released\": [\n    2020,\n    \"Sep\",\n    3\n  ],\n  \"latest\": true\n}\n```\n\n以打印输出上面为例，建立以下代码：\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include \"cJSON.h\"\n\n\nint main( int argc, char *argv[] )\n{\n    cJSON *jtest = NULL;\n    cJSON *jfile = NULL;\n    cJSON *jissue = NULL;\n    cJSON *jyear = NULL;\n    cJSON *jmonth = NULL;\n    cJSON *jday = NULL;\n    char* str = NULL;\n\n    /* 创建一个 JSON格式的主对象(主链表头结点) */\n    jtest = cJSON_CreateObject();\n\n    /* 追加字符串类型的 JSON数据到主对象中(添加一个链表节点) */\n    cJSON_AddStringToObject(jtest, \"name\", \"cJSON\");\n    cJSON_AddStringToObject(jtest, \"version\", \"v1.7.14\");\n\n    /* 追加一个对象到主对象中(添加一个链表节点) */\n    jfile = cJSON_AddObjectToObject(jtest, \"file\");\n    /* 往追加的对象添加对应的值 */\n    cJSON_AddStringToObject(jfile, \"name\", \"cJSON.c\");\n    cJSON_AddNumberToObject(jfile, \"size\", 75.8);\n    cJSON_AddStringToObject(jfile, \"unit\", \"KB\");\n    \n    /* 创建一个 JSON格式的数组(另一个链表头结点) */\n    jissue = cJSON_CreateArray();\n    /* 创建相应的值并把这些值添加到数组里 */\n    jyear = cJSON_CreateNumber(2020);\n    cJSON_AddItemToArray(jissue, jyear);\n    jmonth = cJSON_CreateString(\"Sep\");\n    cJSON_AddItemToArray(jissue, jmonth);\n    jday = cJSON_CreateNumber(3);\n    cJSON_AddItemToArray(jissue, jday);\n    /* 把已经填好的数据的数组插入到主对象中 */\n    cJSON_AddItemToObject(jtest, \"released\", jissue);\n\n    /* 追加一个值为 True的布尔类型的 JSON数据到主对象中(添加一个链表节点) */\n    cJSON_AddTrueToObject(jtest, \"latest\");\n\n    /* 打印 JSON对象(整条链表)的所有数据 */\n    str = cJSON_Print(jtest);\n    printf(\"%s\\n\", str);\n\n    cJSON_free(str);\n    cJSON_Delete(jtest);\n\n    return 0;\n}\n```\n\n实例：\n\n![image-20210130174615600](image-20210130174615600.png)\n\n\n\n# 注意事项\n\n1、在调用了 create接口的数据，并且用完一个完整的 JSON格式包后，必须要使用 cJSON_Delete();释放内存，且不说不释放会造成泄露数据，在嵌入式中，内存容量可是很少的，很容易就耗完内存。\n\n2、cJSON_Delete();函数，并不是每调用一个 create接口，等用完都要一一对应释放，而是要释放主链表，简单的来说要处理的是头一个创建的数据类型，对于后期往其追加的数据，cJSON_Delete();函数会自动把插入进来的节点删除掉，这个在下篇再详细分析。\n\n3、cJSON里面的 Print接口格式化出来返回的数据，需要调用 cJSON_free();释放。cJSON的内存申请涉及到初始化钩子函数 cJSON_InitHooks();那里，这个也是下篇分析。","tags":["history","JSON"],"categories":["middleware"]},{"title":"逻辑门、锁存器和触发器","url":"//docs/逻辑门、锁存器和触发器/","content":"\n\n> 好久没写硬件的笔记了，写这篇笔记是因为在网上或者在现有的书上查阅相关知识点的时候，发现大多数东西都是一略带过、不全面，而且内容讲的有点沉闷，容易让人呼呼入睡（ps：这里绝对没有瞧不起作者的意思哈，可能风格有点不适应），所以想着以后可能也会用到，还是自己总结一篇吧。\n>\n> 本篇主要分析半导体存储电路（其中包括时序图跟真值表），但由于涉及到逻辑门电路，所以就一并放在一起总结了。嘛，原本的标题是想写 “半导体存储电路分析” 的。。。\n>\n\n\n\n# 逻辑门电路\n\n## 与、或、非\n\n- 与门\n\n  ![AND](AND.jpg)\n\n  特点：所有输入为高电平时（逻辑 1），才会有高电平（逻辑 1）输出；其中一个输入为低电平（逻辑 0）则出低电平（逻辑 0）。\n\n  **真值表：**\n\n  | **输入** | **输入** | **输出**  |\n  | :------: | :------: | :-------: |\n  |    A     |    B     | A  and  B |\n  |    0     |    0     |     0     |\n  |    0     |    1     |     0     |\n  |    1     |    0     |     0     |\n  |    1     |    1     |     1     |\n\n  ==总结：遇 0为 0。==\n\n  \n\n- 或门\n\n  ![OR](OR.jpg)\n\n  特点：其中一个输入为高电平时（逻辑 1），输出为高电平（逻辑 1）；只有当所有输入为低电平（逻辑 0）才出低电平（逻辑 0）。\n\n  **真值表：**\n\n  | **输入** | **输入** | **输出** |\n  | :------: | :------: | :------: |\n  |    A     |    B     | A  or  B |\n  |    0     |    0     |    0     |\n  |    0     |    1     |    1     |\n  |    1     |    0     |    1     |\n  |    1     |    1     |    1     |\n\n  ==总结：遇 1为 1。==\n\n  \n\n- 非门\n\n  ![NOT](NOT.jpg)\n\n  特点：输出的电平与输入的电平（逻辑）相反。\n\n  **真值表：**\n\n  | **输入** | **输出** |\n  | :------: | :------: |\n  |    A     |  not  A  |\n  |    0     |    1     |\n  |    1     |    0     |\n  \n  ==总结：状态取反。==\n\n\n\n## 异或和同或\n\n- 异或\n\n  ![XOR](XOR.jpg)\n\n  特点：输入的电平相同时，输出为低电平（逻辑 0）；若输入的电平不同，则输出高电平（逻辑 1）。\n\n  **真值表：**\n\n  | **输入** | **输入** | **输出**  |\n  | :------: | :------: | :-------: |\n  |    A     |    B     | A  xor  B |\n  |    0     |    0     |     0     |\n  |    0     |    1     |     1     |\n  |    1     |    0     |     1     |\n  |    1     |    1     |     0     |\n\n  ==总结：相同为 0，不同为 1。==\n\n  \n\n- 同或\n\n  ![XNOR](XNOR.jpg)\n\n  特点：只有当输入的电平相同时，输出才为高电平（逻辑 1）；而输入的电平不同时，输出低电平（逻辑 0）。\n\n  **真值表：**\n\n  | **输入** | **输入** |  **输出**  |\n  | :------: | :------: | :--------: |\n  |    A     |    B     | A  xnor  B |\n  |    0     |    0     |     1      |\n  |    0     |    1     |     0      |\n  |    1     |    0     |     0      |\n  |    1     |    1     |     1      |\n\n  ==总结：不同为 0，相同为 1。==\n\n\n\n## 与非和或非\n\n与非和或非，其实相当于与门和或门输出取反：\n\n![X](X.jpg)\n\n真值表这里就不放了，其实就是把与门和或门的输出状态取反。。。\n\n\n\n## 逻辑门电路实现\n\n逻辑门电路的实现，可由三极管或者 CMOS管构建而成，可以看以前的文章：[三极管---初识(图文并茂)](https://blog.csdn.net/qq_42992084/article/details/98784963)\n\n\n\n# 存储电路\n\n**基本概念：**\n\n- **存储单元**：存储一位数据的电路。可分为**静态存储单元**和**动态存储单元**两大类。静态存储单元由门电路连接而成，其中包括各种电路结构形式的**锁存器**和**触发器**，只要保持通电，静态存储单元的状态会一直保持下去。动态存储单元则是利用**电容**的电荷存储效应来存储数据的，由于电容存储的电荷会随着时间的推移逐渐泄露，必须定期地进行 “刷新”，才能保证数据不会丢失。\n- **寄存器**：存储一组数据的电路。由 N个触发器构成的寄存器可以存储一组 N位的二值数据。\n- **存储器**：存储大量数据的电路。存储器种类虽然很多，但它们的基本结构形式都是由**存储矩阵**和**读/写控制电路**两部分组成的。从存储功能上讲，可分为**随机存储器**（Random Access  Memory，简称 RAM）和**只读存储器**（Read Only Memory ，简称 ROM）两大类。随机存储器又分成**静态随机存储器**（SRAM）和**动态随机存储器**（DRAM）两类；而只读存储器又有**掩模 ROM**、**可编程 ROM**（PRAM）和**可擦除可编程 ROM**（EPRAM）几种不同类型。\n\n\n\n# 锁存器和触发器\n\n下面主要分析硬件电路中经常接触的**静态存储单元**，那么就先来了解一下**锁存器**和**触发器**之间的关系：\n\n触发器的线路图由逻辑门组合而成，其结构均由 SR锁存器派生而来（广义的触发器包括锁存器）；\n\n**触发器**除了自身的输入信号外，还带有 CLK时钟信号线，通过时钟信号的变化，使得触发器的次态仅仅取决于 CLK信号下降沿（或上升沿）到达时刻输入信号的状态，以此来增强靠干扰能力，因此，触发器也叫边沿触发器；\n\n而**锁存器**并没有 CLK时钟信号线作为辅助，只有自身的输入信号，但是，通过改进（增加一条使能信号线）可以产生新的门控锁存器，此时锁存器上多了一条使能信号线，如果在使能信号线上给予一定频率的脉冲信号，那么门控锁存器就相当于触发器了。\n\n知识补充：https://circuitglobe.com/difference-between-latch-and-flip-flop.html\n\n\n\n# 锁存器\n\n锁存器的类型有很多种：S-R、J-K、T and D latches。这里只介绍比较常用的 S-R latch and Gated D latch。\n\n## SR锁存器\n\n![R-S_mk2](R-S_mk2.gif)\n\nSR锁存器（Set-Reset Latch）是静态存储单元当中最基本、也是电路结构最简单的一种。通常它由两个**或非门**或者**与非门**组成。\n\n\n\n**Ⅰ、电路组成：**\n\n- 由**或非门**构成\n\n  ![Logic_Design_NOR_Latches](Logic_Design_NOR_Latches.jpg)\n\n- 由**与非门**构成\n\n  ![Logic_Design_NAND_Latches](Logic_Design_NAND_Latches.jpg)\n\n**Ⅱ、状态分析：**\n\n从上面的两种构成进行比较，根据它们对应的状态表可以看出，当 S、R信号为高电平（逻辑 1）【对应的，$\\overline{S}$、$\\overline{R}$信号（由于符号表示的是非的关系）就为低电平（逻辑 0）】，就相当于这两个状态表高亮部分，所以无论是由哪个逻辑门构成，其输出状态都是一样的；因此，找其中一个表对照着理解就好了，那么就来稍微分析一下吧：\n\n- [ ] 当输入的 S = 0、R = 1（$\\overline{S}$ = 1、$\\overline{R}$ = 0），输出 Q = 0和 $\\overline{Q}$ = 1（定义为 0状态）；\n\n- [ ] 当输入的 S = 1、R = 0（$\\overline{S}$ = 0、$\\overline{R}$ = 1），输出 Q = 1和 $\\overline{Q}$ = 0（定义为 1状态）；\n- [ ] 当输入的 S = R = 0（ $\\overline{S}$ = $\\overline{R}$ = 1）；输出将会保持；\n\n- [ ] 当输入的 S = 1、R = 1（$\\overline{S}$ = 0、$\\overline{R}$ = 0），输出 Q和 $\\overline{Q}$其状态是不确定的；因此，在 SR锁存器里，有一条约束条件：S · R = 0（即不应该出现 $\\overline{S}$ = $\\overline{R}$ = 0，这种情况）。\n\n**Ⅲ、时序分析：**\n\n以**与非门**构成电路为例：\n\n![SR latch](SR%20latch.png)\n\n在上图可以看到， t3 ~ t4时刻，输入端出现了 $\\overline{S}$ = $\\overline{R}$ = 0的状态，但由于 $\\overline{S}$ 首先回到了高电平，所以 SR锁存器的次态仍是可以确定的；可能你会觉得，上面不是说了无法确定状态吗？这是由于 $\\overline{S}$ = $\\overline{R}$ = 0时会出现非定义的 Q =  $\\overline{Q}$ = 1的非法状态（要知道我们只定义了 0和 1的状态），而且当 $\\overline{S}$ 和 $\\overline{R}$ 同时回到高电平以后锁存器的状态难以确定，因此一般情况下还是避免这种 $\\overline{S}$ = $\\overline{R}$ = 0的状态；同时，由于这个缺陷，**JK触发器**产生了，下面会讲。\n\n**Ⅳ、电路改进：**\n\n从上面可以得知，由**与非门**构成的 SR触发器，输入的电平（逻辑）是反向的输入（即为  $\\overline{S}$、$\\overline{R}$ ），因此，人们在电路的前端输入部分添加了转换功能，并且引入了使能控制信号，如下图：\n\n![Logic_Design_gated_SR_latch](Logic_Design_gated_SR_latch.jpg)\n\n于是乎，把上面的电路称之为：**门控 SR锁存器**\n\n\n\n门控使能信号（一般表示为 E或者 C）的作用：\n\n| E/C  |              Action              |\n| :--: | :------------------------------: |\n|  0   |      No action (keep state)      |\n|  1   | The same as non-clocked SR latch |\n\n\n\n## 门控 D锁存器\n\n在上面已经见识到了 **门控 SR锁存器**，那么稍微修改一下就会得到 **门控 D锁存器**，由于是从 SR锁存器上进行的修改，所以也存在着由**或非门**或者**与非门**所组成电路。\n\n**Ⅰ、电路组成：**\n\n- 基于 SR NAND锁存器的门控 D锁存器\n\n  ![676px-D-Type_Transparent_Latch.svg](676px-D-Type_Transparent_Latch.svg.png)\n\n- 基于 SR NOR锁存器的门控 D锁存器\n\n  ![676px-D-type_Transparent_Latch_(NOR).svg](676px-D-type_Transparent_Latch_(NOR).svg.png)\n\n对应上面两个门控 D锁存器，其真值表都是一样的：\n\n|  E   |   D   |   Q   |   $\\overline{Q}$   |  Comment  |\n| :--: | :---: | :---: | :----------------: | :-------: |\n|  0   | **X** | Qprev | $\\overline{Q}$prev | No change |\n|  1   |   0   |   0   |         1          |   Reset   |\n|  1   |   1   |   1   |         0          |    Set    |\n\n从真值表上看，可以知道，在使能信号输入为高电平（逻辑 1）时，D锁存器才起作用，否则，输出信号将保持原状态；并且，当 D锁存器起作用时，输出的信号 Q状态跟 D输入状态一致，因此，D锁存器也叫 D跟随。\n\n**Ⅱ、时序分析**\n\n![Gated D latch](Gated%20D%20latch.png)\n\n\n\n锁存器部分相关链接：https://learn.circuitverse.org/docs/Latches\n\n\n\n# 触发器\n\n触发器的类型同样也有很多种：S-R、J-K、T and D Flip flops。这里也只是分析常见的 J-K、T and D Flip flops。\n\n根据时钟信号触发的不同，可以分为两种情况（上升沿触发和下降沿触发）：\n\n![Logic_Design_SR_flip_flop_symbol](Logic_Design_SR_flip_flop_symbol.jpg)\n\n从上图可以看到，上升沿触发和下降沿触发根本区别在于时钟信号输入端是否多了个非门。\n\n## JK触发器\n\n根据边沿触发的不同，有以下两种逻辑符号：\n\n![Logic_Design_JK_flip_flop_symbol](Logic_Design_JK_flip_flop_symbol.jpg)\n\n**以上升沿为例，其电路组成如下：**\n\n![jk flip flop](jk%20flip%20flop.png)\n\n**对应的真值表：**\n\n|    触发    |   J   |   K   |   Q   | Qnext |  Comment   |\n| :--------: | :---: | :---: | :---: | :---: | :--------: |\n| $\\searrow$ | **X** | **X** | Qprev |   Q   | No change  |\n| $\\nearrow$ |   0   |   0   |   0   |   0   | Hold state |\n| $\\nearrow$ |   0   |   0   |   1   |   1   | Hold state |\n| $\\nearrow$ |   0   |   1   |   0   |   0   |   Reset    |\n| $\\nearrow$ |   0   |   1   |   1   |   0   |   Reset    |\n| $\\nearrow$ |   1   |   0   |   0   |   1   |    Set     |\n| $\\nearrow$ |   1   |   0   |   1   |   1   |    Set     |\n| $\\nearrow$ |   1   |   1   |   0   |   1   |   Toggle   |\n| $\\nearrow$ |   1   |   1   |   1   |   0   |   Toggle   |\n\n**时序分析：**\n\n![JK Flip-Flop](JK%20Flip-Flop.png)\n\n**特征方程式：**\n\n![JK](JK.png)\n\n\n\n## T触发器\n\n根据边沿触发的不同，有以下两种逻辑符号：\n\n![Logic_Design_T_flip_flop_symbol](Logic_Design_T_flip_flop_symbol.jpg)\n\n**以上升沿为例，其电路组成如下：**\n\n![T flip flop](T%20flip%20flop.png)\n\n**对应的真值表：**\n\n|    触发    |   T   |   Q   | Qnext |  Comment   |\n| :--------: | :---: | :---: | :---: | :--------: |\n| $\\searrow$ | **X** | Qprev |   Q   | No change  |\n| $\\nearrow$ |   0   |   0   |   0   | Hold state |\n| $\\nearrow$ |   0   |   1   |   1   | Hold state |\n| $\\nearrow$ |   1   |   0   |   1   |   Toggle   |\n| $\\nearrow$ |   1   |   1   |   0   |   Toggle   |\n\n**时序分析：**\n\n![T Filp-Flop](T%20Filp-Flop.png)\n\n**特征方程式：**\n\n![T](T.png)\n\n\n\n## D触发器\n\n根据边沿触发的不同，有以下两种逻辑符号：\n\n![Logic_Design_D_flip_flop_symbols](Logic_Design_D_flip_flop_symbols.jpg)\n\n**以上升沿为例，其电路组成如下：**\n\n![D flip flop](D%20flip%20flop.png)\n\n**对应的真值表：**\n\n|    触发    |   D   |   Q   | Qnext |  Comment  |\n| :--------: | :---: | :---: | :---: | :-------: |\n| $\\searrow$ | **X** | Qprev |   Q   | No change |\n| $\\nearrow$ |   0   |   0   |   0   |   Reset   |\n| $\\nearrow$ |   0   |   1   |   0   |   Reset   |\n| $\\nearrow$ |   1   |   0   |   1   |    Set    |\n| $\\nearrow$ |   1   |   1   |   1   |    Set    |\n\n**时序分析：**\n\n![D Filp-Flop](D%20Filp-Flop.png)\n\n**特征方程式：**\n\n![D](D.png)\n\n\n\n触发器部分相关链接：https://learn.circuitverse.org/docs/flipflop\n\n\n\n# 相关资料\n\nhttps://en.wikipedia.org/wiki/Flip-flop_(electronics)\n\nhttps://www.youtube.com/watch?v=-aQH0ybMd3U&list=RDCMUCSX3MR0gnKDxyXAyljWzm0Q&start_radio=1\n\nhttp://yhhuang1966.blogspot.com/2019/06/latch-flip-flop.html\n\nhttps://www.electronics-tutorials.ws/sequential/seq_1.html\n\n","tags":["history","电子电路"]}]