[{"title":"wireshark使用","url":"/docs/wireshark使用/","content":"\n\n\n官方说明：\n\nhttps://wiki.wireshark.org/Home\n\nhttps://www.wireshark.org/docs/wsug_html_chunked/\n\n# 着色规则\n\n在 wireshark监控界面上，不同的报文会显示不一样样的颜色，它们分别表示不同的含义；而这些颜色，都是是由着色规则设置的：\n\n![image-20221006162351042](image-20221006162351042.png)\n\n在默认的着色规则中，一般黑色背景代表报文的各类错误，红色背景代表各类异常情景，其它颜色代表正常。\n\n官方的说明可以看：https://www.wireshark.org/docs/wsug_html_chunked/ChCustColorizationSection.html\n\n着色规则分析：\n\n**1、Bad TCP：** tcp.analysis.flags && !tcp.analysis.window_update && !tcp.analysis.keep_alive && !tcp.analysis.keep_alive_ack\n\n即 TCP包损坏，通常表示为重传，乱序，丢包，重复响应等都在此条规则的范围内。具体看第三大点。\n\n参看：https://www.wireshark.org/docs/wsug_html_chunked/ChAdvTCPAnalysis.html\n\n**2、HSRP State Change：** hsrp.state != 8 && hsrp.state != 16\n\nHSRP即热备份路由协议（Hot Standby Router Protocol），这条规则表明当前报文状态非 Standby和 Active。\n\nHSRP的状态值可以是以下几种：\n\n- 0 - Initial\n- 1 - Learn\n- 2 - Listen\n- 4 - Speak\n- 8 - Standby\n- 16 - Active\n\n参考：https://www.rfc-editor.org/rfc/rfc2281\n\n**3、Spanning Tree Topology  Change：** stp.type == 0x80\n\n当生成树协议的状态标记为 `0x80`，表示着生成树拓扑发生变化。即 STP协议数据单元 (BPDU) 的 `flag` 字段发生变化（使用 IEEE-802.1d）：\n\n![img](bpdu.png)\n\n参考：https://techhub.hpe.com/eginfolib/networking/docs/switches/5980/5200-3921_l2-lan_cg/content/499036672.htm\n\n**4、OSPF State Change：** ospf.msg != 1\n\nOSPF（Open Shortest Path First，开放式最短路径优先协议）的 msg类型不是Hello报文。\n\nOSPF报文的类型，有下面几种类型：\n\n- 1：Hello报文；\n- 2：DD报文；\n- 3：LSR报文；\n- 4：LSU报文；\n- 5：LSAck报文。\n\n参考：http://www.023wg.com/message/message/cd_feature_ospf_message.html\n\n**5、ICMP errors：** icmp.type eq 3 || icmp.type eq 4 || icmp.type eq 5 || icmp.type eq 11 || icmpv6.type eq 1 || icmpv6.type eq 2 || icmpv6.type eq 3 || icmpv6.type eq 4\n\nICMP协议错误，协议的 type字段值错误。\n\n**6、ARP：** arp\n\n即 ARP协议。\n\n**7、ICMP：** icmp || icmpv6\n\n即 ICMP协议。\n\n**8、TCP RST：** tcp.flags.reset eq 1\n\nTCP流产生 reset。\n\n**9、SCTP ABORT：** sctp.chunk_type eq ABORT\n\nSCTP（即流控制传输协议）发生中止。\n\n参考：https://www.rfc-editor.org/rfc/rfc4960#section-3.3.7\n\n**10、TTL low or unexpected：** ( ! ip.dst == 224.0.0.0/4 && ip.ttl < 5 && !pim && !ospf) || (ip.dst == 224.0.0.0/24 && ip.dst != 224.0.0.251 && ip.ttl != 1 && !(vrrp || carp))\n\nTTL (Time-To-Live) 指解析记录在本地 DNS服务器中的缓存时间。该规则表示 TTL产生异常。\n\n在 IP组播中，通过 TTL控件来管理转发数据包的范围，按照惯例：\n\n- 0 - 仅限于同一主机上\n- 1 - 被限制在同一个子网内\n- 32 仅限于同一站点\n- 64 - 仅限于同一区域\n- 128 - 仅限于同一大陆\n- 255 - 不受限制\n\n参考：https://www.techtarget.com/searchnetworking/definition/time-to-live\n\n**11、Checksum Errors：** eth.fcs.status == \"Bad\" || ip.checksum.status == \"Bad\" || tcp.checksum.status == \"Bad\" || udp.checksum.status == \"Bad\" || sctp.checksum.status == \"Bad\" || mstp.checksum.status == \"Bad\" || cdp.checksum.status == \"Bad\" || edp.checksum.status == \"Bad\" || wlan.fcs.status == \"Bad\" || stt.checksum.status == \"Bad\"\n\n条件中的各类协议的 checksum出现异常。\n\n**12、SMB：** smb || nbss || nbns || netbios\n\nServer Message Block类协议。\n\n**13、HTTP：** http || tcp.port == 80 || http2\n\nHyper Text Transfer Protocol（超文本传输协议），这是很简陋的识别方法。\n\n**14、DCERPC：** dcerpc\n\n即 DCE/RPC，分散式运算环境/远端过程调用（Distributed Computing Environment / Remote Procedure Calls）协议。\n\n**15、Routing：** hsrp || eigrp || ospf || bgp || cdp || vrrp || carp || gvrp || igmp || ismp\n\n路由类协议。\n\n**16、TCP SYN/FIN： ** tcp.flags & 0x02 || tcp.flags.fin == 1\n\nTCP连接的起始和关闭。\n\n**17、TCP：** tcp\n\nTCP协议。\n\n**18、UDP：** udp\n\nUDP协议。\n\n**19、Broadcast：** eth[0] & 1\n\n广播数据。\n\n**20、System Event：** systemd_journal || sysdig\n\n系统调用及系统事件等系统活动。\n\n\n\n# 专家信息\n\n在报文的信息栏中，通常也有颜色限定，如下图：\n\n![image-20221006185352059](image-20221006185352059.png)\n\n而这次的颜色区别是属于对应的信息条目的：\n\n![image-20221006185105048](image-20221006185105048.png)\n\n每个专家信息项都有一个严重性级别。使用以下级别，从最低到最高。Wireshark 使用不同的颜色标记它们：\n\n- 聊天（蓝色）\n\n  有关常用的工作流程信息，例如设置了 SYN 标志的 TCP 数据包；数据包都符合常规流量的特征，包括 SYN、FIN、RST以及各种状态码的HTTP事件。\n\n- 注意（青色）\n\n  值得注意的事件，例如应用程序返回了一个常见的错误代码，例如 HTTP 404；数据包中有可能会引发故障的异常现象，例如TCP重传、重复确认、快速重传等现象。\n\n- 警告（黄色）\n\n  警告，例如应用程序返回异常错误代码，如连接问题。\n\n  与 TCP窗口有关的事件 TCP window full或TCP zero window，一般是连接设备忙不过来所致。\n\n  与 TCP报文段丢失或失序有关的事件，丢失是因为未抓全某个 TCP数据流的所有 TCP报文段；失序是因其感知到了TCP报文段未按发出的顺序到达接收主机。\n\n- 错误（红色）\n\n  严重的问题。\n\n  校验和错误：Ethernet及IP校验和错误。\n\n  伪造的数据包：一般涉及具体的应用层协议。\n\n参看：https://www.wireshark.org/docs/wsug_html_chunked/ChAdvExpert.html\n\n\n\n# TCP Info\n\n参看：https://wiki.wireshark.org/TCP_Analyze_Sequence_Numbers\n\n## A、ACK信息\n\n**1、TCP ACKed unseen segment**\n\n表示 Wireshark发现该条 ACK在整个网络包中找不到所对应的 Seq（排除了乱序），就会提示。\n\n![image-20221012210009741](image-20221012210009741.png)\n\n如图，在这组网络中，第 296号包出现这种情况，然后在上面的包中是找不到它所对应的 Seq的。\n\n**2、TCP Dup ACK *<frame>* #*<acknowledgement number>***\n\n重复 ACK包，当收发不稳定时，会出现重复响应的情况；而这种情况就是响应端会向请求端回复重复 ACK。`#` 符号前面的数字表示对应的重复包号，后面的数字表示确认次数，也可以说是出现的次数。\n\n![image-20221012221850769](image-20221012221850769.png)\n\n如图，在第 31191号包的信息中可以看到提示是说跟第 31188号包出现重复，通过查看第 31188号包，而这一包其实是为了响应第 31187号的。\n\n**3、TCP Fast Retransmission**\n\n标志着前面接收到重复的 ACK包（即出现了 [TCP Dup ACK] ）达 3个或 3个以上，进而触发了 TCP的快速重传（这是 RFC的规定）。\n\n![image-20221012224854822](image-20221012224854822.png)\n\n如图， [TCP Dup ACK] 出现了 3次，而且都是对应第 1309号包，因此触发快速重传包第 1330号包，重传了第 1309号包所响应的请求包第 1245号包，如下图：\n\n![image-20221012230828693](image-20221012230828693.png)\n\n然后通过对比原包第 1245号包和快速重传包第 1330号包，你会发现并不相同，实际上原始数据应该是相同的，只不过数据加密了，才出现不同的现象。\n\n## B、保活探测\n\n**4、TCP Keep-Alive**\n\n这个应该不陌生，一般 TCP长链接时，如果启用保活功能，则在特定时间段没有数据交互，那么将会传输一条保活字段，如下图：\n\n![image-20221012233735152](image-20221012233735152.png)\n\n**5、TCP Keep-Alive ACK**\n\n作为上一点 [TCP Keep-Alive] 的响应包，例图看上一张。\n\n## C、乱序 or 丢包\n\n**6、TCP Out-Of-Order**\n\n标志着 TCP传输出现乱序。\n\n![image-20221013201521709](image-20221013201521709.png)\n\n如图，在 TCP传输过程中（不包括三次握手和四次挥手），同一台主机发出的数据包应该是连续的，即后一个包的 Seq号等于前一个包的 Seq + Len；也可以说，后一个包的 Seq会大于或等于前一个包的 Seq。当 Wireshark发现后一个包的 Seq值小于前一个包的 Seq + Len时，就会认为是乱序了，因此标志 [TCP Out-of-Order]。\n\n在连续传输数据过程中，可以看到从第 330号包一直到第 337包被标志为乱序这几个包，应当是连续的，但是可以发现第 336号包跟第 337号包调转了，因此第 336号包被标志为上一包未捕获，而第 337号包则被标志为乱序。\n\n然后来分析一下，例如第 337号包的 Seq = 83518，Len = 1380，那么 Seq + Len = 84898，可以发现其实该包列栏中 `Sequence Number` 的 `83518` 数据对应 Seq，`NextSequence Number` 的 `84898` 数据对应 Seq + Len。根据上面的结论，在发生错误前的第 335号包它的 `NextSequence Number` 表明下一包第 336号包的 Seq值应当是 `83518` ，但是实际上第 336号包的 Seq值为 `84898` ，当到了第 337号包的时候，才出现理应对应的值 `83518` ，这时 Wireshark通过对比在发生错误前的第 335号包至理论连续的第 337号包之间看是否有出现调转包，有则标志 [TCP Out-of-Order]。一般出现 [TCP Out-of-Order] 时都会伴随出现 [TCP Previous segment not captured] 。\n\n**7、TCP Previous segment not captured**\n\n在 TCP传输过程中，同一台主机发出的数据段应该是连续的，即后一个包的 Seq号等于前一个包的 Seq + Len（三次握手和四次挥手是例外）。如果 Wireshark发现后一个包的 Seq值大于前一个包的 Seq + Len，就知道中间缺失了一段数据。\n\n依然沿用上一张图，在发生错误前的第 335号包 Seq + Len 值为 `83518` ，但下一包的 Seq值为 `84898` ，因此出现后一个包的 Seq值大于前一个包的 Seq + Len，而非等于，所以预示着该数据包的上一个包未捕获到，但后面我们也有发现虽然显示上一个包未捕获到，实际紧随它的后一个包就是它们之间的数据包，只是调转了包而已。\n\n## D、端口\n\n**8、TCP Port numbers reused**\n\n这个死活没捕捉出来，就简单说一下吧。\n\n当发送 SYN 标志时（不是 SYN + ACK），如果已经存在一个使用相同地址和端口的现有会话，那么将会被 Wireshark标记 [TCP Port numbers reused]。\n\n## E、重传\n\n**9、TCP Spurious Retransmission**\n\nTCP虚假重传，意味着发送端认为发送的包已经丢失了，然后就重传了，尽管此时接收端已经发送了对这些包的确认（确认还没收到或者已经丢失了）。\n\n![image-20221013232224434](image-20221013232224434.png)\n\n如图，第 459号包出现虚拟重传现象，实际为第 453号包的重传，可从显示来看第 453号包是已经是得到接收端的 ACK响应了，理论来讲是不会重传的，但前面也有说到了，可能会出现接收端确认了请求（已经发出去了），发送端却还没收到或者已经丢失了，那么发送端将会重传数据，而由于这时这段数据包在初包发送后接收端有回一次请求，这次重传相当于接收端又回了一次请求（即重复了两次响应，可以看到第 460号包标志为 [TCP Dup ACK] 了），所以对于这种有回 ACK还重传的数据包将被标志为 [TCP Spurious Retransmission] 。然后至于为什么是重传了第 453号包，可以看到第 460号包的信息提示，这是 ACK响应第 459号包的，但同时也是跟第 454号包重复，而第 454号包对应响应第 453号包的，那自然而然地得到第 459号包为第 453号包的重传。\n\n**10、TCP Retransmission**\n\nTCP重传，与上面不同的是如果一个包不确定是否丢了，但它又没有像上面 [TCP Spurious Retransmission] 那样得到接收端的 ACK响应，那它大概率就是丢包了，就不会快速重传；而针对这种情况，发送方也就只好等到超时了再重传，此类重传包就会被 Wireshark标志 [TCP Retransmission] 。\n\n![image-20221014221501852](image-20221014221501852.png)\n\n如图，第 33号包被标志为 [TCP Previous segment not captured]，预示着有可能出现丢包，并且在后面一段时间内也没有像前面那样有标志 [TCP Out-Of-Order]提示的包，排除了乱序情况，最终等待超时，重传数据包，于是第 33号重传包就有了 [TCP Retransmission]标志。TCP重传是 TCP通讯中常有的事情，有时候看到一大堆黑漆漆一片的 error事件，可能就是这种情况。\n\n## F、TCP Window\n\n**11、TCP Window Full**\n\n顾名思义，就是窗口已满，指的发送端发送的数据已经达到的接受窗口的上限；那么发送端暂停发送，等待新的接收窗口的通告。\n\n![image-20221014235639055](image-20221014235639055.png)\n\n如图，在这组数据中，从第 526323号包开始，出现了 [TCP Window Full] 表明发送数据达到上限了，同时还有另一个 [TCP Spurious Retransmission] 表明了虚假重传，但可惜的是接收端后续都没有响应，最终导致在发送 RST 报文后，关闭 TCP连接。\n\n**12、TCP Window Update**\n\nTCP协议允许随时改变窗口的大小，并且通过发送标识有 WindowUpdate 的报文通知对端；或者当接收端的应用程序消耗完了已经从 RX 缓冲区接收到的数据时，也会发生 WindowUpdate，以指示缓冲区中现在有更多可用空间；以上这些数据包将被标志 [TCP Window Update]。[TCP Window Update] 是 TCP通信中的一个状态，它可以发生的原因还有有很多，通常在 TCP ZeroWindow 条件发生后看到。\n\n![image-20221014234941548](image-20221014234941548.png)\n\n**13、TCP ZeroWindow**\n\n如图，当接收窗口值大小为零（Win = 0）且非 SYN、FIN 或 RST 数据时设置。\n\n![image-20221014223515008](image-20221014223515008.png)\n\n在每个 TCP报头中的窗口字段表明着接收端可以接受的数据量大小；如果接收端不能接受任何数据，它将把窗口值设置为零，这告诉发送端暂停其传输。在某些特定情况下，这是正常的，例如，打印机可能会在加载或翻转一张纸时使用零窗口暂停打印作业的传输；然而，在大多数情况下，这表明接收端存在性能或容量问题。恢复暂停的连接可能需要很长时间(有时需要几分钟)，即使导致零窗口的底层条件很快就会清除。\n\n**14、TCP ZeroWindowProbe**\n\n当通信的一方接收到 TCP ZeroWindow 报文后，会定时发送 TCP ZeroWindowProbe 报文进行探测；探测报文是需要发送下一字节数据，然后通过接收端的响应，由此来判断接收端窗口值是否仍然为 0，如果接收方回复窗口大小仍然为零，则发送端继续探测。ZeroWindowProbe 它有助于证明发送端已经确认到接收端其 TCP 窗口大小为零，但仍试图让数据继续交互而非关闭通讯。\n\n![img](windows-3.png)\n\n**15、TCP ZeroWindowProbeAck**\n\n作为 [TCP ZeroWindowProbe] 的 ACK应答，结合 TCP ZeroWindowProbe 理解。ZeroWindowProbeAck 数据包的存在也表明网络正在传递数据包并且设备没有关闭。\n\n## G、交互\n\n**16、TCP Conversation Completeness**\n\n- SYN\n- SYN-ACK\n- ACK\n- DATA\n- FIN\n- RST\n\n![img](0.jpg)\n\n\n\n# 常见表达式\n\n**1、运算符**\n\n| 英文写法 |  别名  | C-like |              描述              |         例子          |\n| :------: | :----: | :----: | :----------------------------: | :-------------------: |\n|    eq    | any_eq |   ==   |      相等（如果超过一个）      | `ip.src == 10.0.0.5`  |\n|    ne    | all_ne |   !=   | 不相等（如果多于一个，则全部） | `ip.src != 10.0.0.5`  |\n|          | all_eq |  ===   |  相等（如果多于一个，则全部）  | `ip.src === 10.0.0.5` |\n|          | any_ne |  !==   | 不相等（如果多于一个，则任意） | `ip.src !== 10.0.0.5` |\n|    gt    |        |   >    |              大于              |   `frame.len > 10`    |\n|    lt    |        |   <    |              小于              |   `frame.len < 128`   |\n|    ge    |        |   >=   |           大于或等于           | `frame.len ge 0x100`  |\n|    le    |        |   <=   |           小于或等于           |  `frame.len <= 0x20`  |\n\n**2、逻辑符**\n\n| 英文写法 | C-like |  描述  |                       例子                        |\n| :------: | :----: | :----: | :-----------------------------------------------: |\n|   and    |   &&   | 逻辑与 |       `ip.src==10.0.0.5 and tcp.flags.fin`        |\n|    or    |  \\|\\|  | 逻辑或 |      `ip.src==10.0.0.5 or ip.src==192.1.1.1`      |\n|   xor    |   ^^   |  异或  | `tr.dst[0:3] == 0.6.29 xor tr.src[0:3] == 0.6.29` |\n|   not    |   !    | 逻辑非 |                     `not llc`                     |\n\n**3、协议过滤**\n\n```\nip.proto == xxx\n\nnote: xxx表示为对应的协议，如 TCP：ip.proto == TCP\n```\n\n- **TCP：** 只显示 TCP协议的数据流\n- **UDP：** 只显示 UDP协议的数据流\n- **HTTP：** 只显示 HTTP协议的数据流\n- **ICMP：** 只显示 ICMP协议的数据流\n- **ARP：** 只显示 ARP协议的数据流\n- **DNS：** 只显示 DNS协议的数据流\n\n**4、IP过滤**\n\n- `ip.addr == 192.168.116.138` ，只显示 **IP地址**为 `192.168.116.138` 有关的数据流\n- `ip.src == 192.168.116.138` ，只显示**源 IP地址**为 `192.168.116.138` 的数据流\n- `ip.dst == 192.168.116.138` ，只显示**目标 IP地址**为 `192.168.116.138` 的数据流\n\n**5、端口过滤**\n\n- `tcp.port == 80` ，只显示 80端口 TCP数据流\n- `udp.prot == 67` ，只显示 67端口 UDP数据流\n- `tcp.srcport == 80` , 只显示源地址的 80端口数据流\n- `tcp.dstport == 80` ，只显示目的地址 80端口数据流\n\n**6、过滤HTTP协议**\n\n- `http.request.method == \"GET\"` ，显示 GET请求\n- `http.request.method == \"POST\"` ，显示 POST请求\n- `http.request.code == 404` ，显示状态码为 404\n\n\n\n参看：https://www.wireshark.org/docs/wsug_html_chunked/ChWorkBuildDisplayFilterSection.html\n\n\n\n# 列信息增删\n\n**1、增加列信息**\n\n在报文的信息栏，选着想要显示的信息，右键点击添加：\n\n![image-20221006221325561](image-20221006221325561.png)\n\n**2、删除列信息**\n\n在监控报文栏，选择不需要的列，右键选中：\n\n![image-20221006221434994](image-20221006221434994.png)\n\n**3、隐藏列信息**\n\n同样在监控报文栏操作，随便选择一列，右键选中，然后把想要隐藏的列去掉勾选，这里就不放图了。","tags":["history","工具"]},{"title":"markdown语法测试","url":"/docs/markdown语法测试/","content":"\n# Welcome to Arachnid‘s blog!\n\n## 排版\n\n**粗体** *斜体* \n\n~~这是一段错误的文本。~~\n\n引用:\n\n> 引用鲁迅的话：我以为“别人尊重我，是因为我很优秀”，后来才明白，“别人尊重我，是因为别人很优秀。\n\n有序列表:\n\n  1. 支持 Vim\n  2. 支持 Emacs\n\n无序列表:\n\n - 项目1\n - 项目2\n\n\n\n## 图片与链接\n\n图片:\n\n![test Image](https://avatars.githubusercontent.com/u/48347583?v=4 \"test Image\")\n\n\n链接:\n\n[这是去往 Arachnid 博客的链接](https://arachnid.cc)\n\n\n\n## 标题\n\n以下是各级标题, 最多支持5级标题\n\n```\n# h1\n## h2\n### h3\n#### h4\n##### h4\n###### h5\n```\n\n\n\n## 代码\n\n示例:\n\n    function get(key) {\n        return m[key];\n    }\n\n代码高亮示例:\n\n``` javascript\n/**\n* nth element in the fibonacci series.\n* @param n >= 0\n* @return the nth element, >= 0.\n*/\nfunction fib(n) {\n  var a = 1, b = 1;\n  var tmp;\n  while (--n >= 0) {\n    tmp = a;\n    a += b;\n    b = tmp;\n  }\n  return a;\n}\n \ndocument.write(fib(10));\n```\n\n```python\nclass Employee:\n   empCount = 0\n \n   def __init__(self, name, salary):\n        self.name = name\n        self.salary = salary\n        Employee.empCount += 1\n```\n\n\n\n# Markdown 扩展\n\nMarkdown 扩展支持:\n\n* 表格\n* 定义型列表\n* Html 标签\n* 脚注\n* 目录\n* 时序图与流程图\n* MathJax 公式\n\n\n\n## 表格\n\n| Item     | Value  |\n| -------- | ------ |\n| Computer | \\$1600 |\n| Phone    | \\$12   |\n| Pipe     | \\$1    |\n\n可以指定对齐方式, 如Item列左对齐, Value列右对齐, Qty列居中对齐\n\n| Item     |  Value | Qty  |\n| :------- | -----: | :--: |\n| Computer | \\$1600 |  5   |\n| Phone    |   \\$12 |  12  |\n| Pipe     |    \\$1 | 234  |\n\n\n\n## 定义型列表\n\n名词 1\n:   定义 1（左侧有一个可见的冒号和四个不可见的空格）\n\n代码块 2\n:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）\n\n        代码块（左侧有八个不可见的空格）\n\n\n\n## Html 标签\n\n支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格，最后使用 `{% raw %}` `{% endraw %}` 把 Html 代码包裹起来应该就可以了：\n\n    <table>\n        <tr>\n            <th rowspan=\"2\">值班人员</th>\n            <th>星期一</th>\n            <th>星期二</th>\n            <th>星期三</th>\n        </tr>\n        <tr>\n            <td>李强</td>\n            <td>张明</td>\n            <td>王平</td>\n        </tr>\n    </table>\n\n\n{% raw %}\n\n<table>\n    <tr>\n        <th rowspan=\"2\">值班人员</th>\n        <th>星期一</th>\n        <th>星期二</th>\n        <th>星期三</th>\n    </tr>\n    <tr>\n        <td>李强</td>\n        <td>张明</td>\n        <td>王平</td>\n    </tr>\n</table>\n\n\n{% endraw %}\n\n\n\n**提示**, 如果想对图片的宽度和高度进行控制, 你也可以通过 img标签, 如:\n\n{% raw %}\n\n<img src=\"https://avatars.githubusercontent.com/u/48347583?v=4\" width=\"50px\" />\n\n{% endraw %}\n\n\n\n## 脚注\n\nMarkdown[^footnote]来创建一个脚注\n\n[^footnote]: Markdown是一种轻量级标记语言.\n\n## 目录\n\n通过 `[TOC]` 在文档中插入目录, 如:\n\n[TOC]\n\n## 时序图与流程图\n\n```mermaid\nsequenceDiagram\n    Alice->Bob: Hello Bob, how are you?\n    Note right of Bob: Bob thinks\n    Bob-->Alice: I am good thanks!\n```\n\n流程图:\n\n```mermaid\ngraph TB\n    A[Hard] -->|Text| B(Round)\n    B --> C{Decision}\n    C -->|One| D[Result 1]\n    C -->|Two| E[Result 2]\n```\n\n\n> **提示:** 更多关于时序图与流程图的语法请参考:\n>\n> - [Mermaid](https://github.com/mermaid-js/mermaid/blob/develop/README.zh-CN.md)\n\n\n\n## KaTex 数学公式\n\n$ 表示行内公式： \n\n质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。\n\n`$$` 表示整行公式：\n\n$$\\sum_{i=1}^n a_i=0 $$\n\n$$f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$\n\n$$\\sum^{j-1}_{k=0}{\\widehat{\\gamma}_{kj} z_k} $$\n\n更复杂的公式：\n\n$$\\begin{eqnarray}\\vec\\nabla \\times (\\vec\\nabla f) & = & 0  \\cdots\\cdots梯度场必是无旋场\\\\\n\\vec\\nabla \\cdot(\\vec\\nabla \\times \\vec F) & = & 0\\cdots\\cdots旋度场必是无散场\\\\\n\\vec\\nabla \\cdot (\\vec\\nabla f) & = & {\\vec\\nabla}^2f\\\\\n\\vec\\nabla \\times(\\vec\\nabla \\times \\vec F) & = & \\vec\\nabla(\\vec\\nabla \\cdot \\vec F) - {\\vec\\nabla}^2 \\vec F\\\\\\end{eqnarray} $$\n\n访问 [KaTex](https://katex.org/) 参考更多使用方法。"},{"title":"基于官方指导安装 Arch Linux","url":"/docs/Linux/基于官方指导安装 Arch Linux/","content":"\n\n\n> 官方 wiki安装中文指导：https://wiki.archlinux.org/title/Installation_guide_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)\n>\n> 最好还是以**英文版**的为基准，因为 ArchLinux是一个激进的系统，更新比较快，可能刚写完这篇笔记，转头已经有些对应不上了，哈哈哈。\n\n\n\n## 系统镜像\n\n官方镜像下载地址：https://archlinux.org/download/\n\n当然，也可以去各大高校提供的镜像源网站下载。\n\n\n\n## 启动盘制作\n\n**1、windows 平台**\n\n可以使用 Rufus：https://rufus.ie/zh/\n\n这是一款开源、免费、小巧（1.1mb）纯粹的系统启动盘制作工具。\n目前所支持的 ISO镜像如下：\n\n![image-20220412112425056](image-20220412112425056.png)\n\n**2、Uinx 平台**\n\n类 Unix系统可以直接使用 `dd` 命令来制作启动盘。\n\n`dd` 命令使用可参考：https://www.runoob.com/linux/linux-comm-dd.html\n\n**3、多平台**\n\n可以使用开源的 etcher：https://www.balena.io/etcher/\n\n\n\n> 然后本篇文章是基于官方指导的总结分析安装的笔记，如下开始正式安装配置，因为是以官方 wiki安装为指导，所以下面用到的操作的标题将一一对应官方 wiki的标题，没用到的将忽略不写，以及需要增加的将给出说明。目前使用的镜像版本：`archlinux-2022.04.01-x86_64.iso`\n\n\n\n## 引导安装\n\nArch 的启动引导过程有两种：[BIOS](https://en.wikipedia.org/wiki/BIOS) 和 [UEFI](https://wiki.archlinux.org/title/UEFI) 系统，这两者的引导过程是完全不同的。在 Arch 中它们的引导加载及区别可看：https://wiki.archlinux.org/title/Arch_boot_process\n\n目前大部分设备的引导方式主要分为 `UEFI 引导 + GPT 分区表` 和 `BIOS(LEGACY) 引导 + MBR 分区表` 这两种，而在新的机器里大部分都采用了 `UEFI/GPT` 引导的方式，当然，同时也兼容 `BIOS/MBR` 。\n\nUEFI进入：\n\n![image-20220412115757611](image-20220412115757611.png)\n\nBIOS进入：\n\n![image-20220412120426116](image-20220412120426116.png)\n\n启动安装后，最终界面出现的效果是一样的：\n\n![image-20220412153955531](image-20220412153955531.png)\n\n\n\n## 验证引导模式\n\n键入如下命令：（`ls`：表示列出目录内容；后面的路径可以利用 Tab键 自动补全，即键入命令或文件名的前几个字符，然后按 [Tab] 键）\n\n```\nls /sys/firmware/efi/efivars\n```\n\n如果命令结果显示了目录且没有报告错误，则系统以 UEFI 模式引导。 \n\n如果目录不存在，则系统可能**（注意是可能，并不一定确是 BIOS模式）**以 [BIOS](https://en.wikipedia.org/wiki/zh:BIOS) 模式 (或 [CSM](https://en.wikipedia.org/wiki/Compatibility_Support_Module) 模式) 引导，如显示：\n\n```\nls: cannot access '/sys/firmware/efi/efivars': No such file or directory\n```\n\n对于一些不是新的/格式过的磁盘，可能就不太适用了，当然，最好方法就是查看安装的主分区磁盘的属性。\n\n\n\n## 连接到因特网\n\n1、检查网络接口是否启用\n\n```\nip link\n```\n\n2、连接到网络\n\n- 有线：连接网线，并保证上级路由有网。\n- 无线：使用 [iwctl](https://wiki.archlinux.org/title/Iwd_(简体中文)#iwctl) 验证无线网络，具体操作点击链接查看。\n\n3、配置网络连接\n\n- 动态：需要支持 DHCP，然后执行以下命令。\n\n  ```\n  dhcpcd\n  ```\n\n- 静态：直接按照 [静态 IP 地址](https://wiki.archlinux.org/title/Network_configuration_(简体中文)#静态_IP_地址) 这个链接进行操作。\n\n4、检查网络连接\n\n在确认无误完成上面的操作后，通过 PING IP来检查：\n\n```\nping archlinux.org\n```\n\n\n\n**note：**关于网络部分的，详情请看 https://wiki.archlinux.org/title/Network_configuration\n\n\n\n## 更新系统时间\n\n执行：\n\n```\ntimedatectl set-ntp true\n```\n\n然后正常情况下是并没有输出的，所谓没有消息就是最好的消息，这就是 Linux/Unix系统的设计思想。\n\n最后，执行如下命令来检查服务状态：\n\n```\ntimedatectl status\n```\n\n\n\n## 建立硬盘分区\n\n系统如果识别到磁盘，就会将其分配为一个块设备，如 `/dev/sda`、`/dev/nvme0n1` 或 `/dev/mmcblk0` 等等。然后可以执行如下命令查看：\n\n```\nfdisk -l\n```\n\n然后，针对不同的引导方式，其分区布局是不一样的，以官方给出的分区为例：\n\n- **UEFI 与** [GPT](https://wiki.archlinux.org/title/Partitioning_(简体中文)#GUID_分区表)\n\n  | 挂载点    | 分区                        | 分区类型                | 建议大小     |\n  | --------- | --------------------------- | ----------------------- | ------------ |\n  | /mnt/boot | /dev/*efi_system_partition* | EFI 系统分区            | 至少 300 MiB |\n  | [SWAP]    | /dev/*swap_partition*       | Linux swap (交换空间)   | 大于 512 MiB |\n  | /mnt      | /dev/*root_partition*       | Linux x86-64 根目录 (/) | 剩余空间     |\n\n- **BIOS 与** [MBR](https://wiki.archlinux.org/title/Partitioning_(简体中文)#Master_Boot_Record)\n\n  | 挂载点 | 分区                  | 分区类型                | 建议大小     |\n  | ------ | --------------------- | ----------------------- | ------------ |\n  | [SWAP] | /dev/*swap_partition* | Linux swap (交换空间)   | 大于 512 MiB |\n  | /mnt   | /dev/*root_partition* | Linux x86-64 根目录 (/) | 剩余空间     |\n\n  然后在这里拓展一下 `MiB` 跟 `MB` 这两个单位，`MB` 是国际单位制 SI 制定的十进制标准单位制，这个 M 是 1000K，而 `MiB` 是国际电工委员会 IEC 制定的二进制标准，这个 M 是 1024K 。参看：https://physics.nist.gov/cuu/Units/binary.html\n\n- 其它的布局实例可看：https://wiki.archlinux.org/title/Partitioning_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%B8%83%E5%B1%80%E7%A4%BA%E4%BE%8B\n\n在了解上面的布局后，然后我们常用的引导方式有 `UEFI 引导 + GPT 分区表` 和 `BIOS(LEGACY) 引导 + MBR 分区表` 这两种，所以下面分开说明：\n\n1. **BIOS/MBR**\n\n   这种方式相对于另一种比较简单，所以就先说了。\n\n   首先，先来了解一下 `[SWAP]` 挂载点和 `/mnt` 挂载点：\n\n   - `[SWAP]`：swap 分区通常被称为交换分区，这是一块特殊的硬盘空间，即当实际内存（物理内存，可以理解为内存条容量）不够用的时候，操作系统会从内存中取出一部分暂时不用的数据，放在交换分区中，从而为当前运行的程序腾出足够的内存空间（有点类似于 windows系统下的虚拟内存）。也就是说，当内存不够用时，我们使用 swap 分区来临时顶替，等到那些程序要运行时，再从 swap 中恢复保存的数据到内存中。这种 “拆东墙，补西墙” 的方式应用于几乎所有的操作系统中。\n\n     使用 swap 交换分区，显著的优点是，通过操作系统的调度，应用程序实际可以使用的内存空间将远远超过系统的物理内存。\n\n     那么 swap 分区到底设置成多大才最优？少了又觉得不够，多了又感觉浪费，那么我们可以参考 Redhat 官方文档中 [关于swap分区大小设置的建议](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/installation_guide/s2-diskpartrecommend-ppc#id4394007)：\n\n     |   物理内存   | 建议的交换空间大小 | 如果开启休眠功能建议的交换空间大小 |\n     | :----------: | :----------------: | :--------------------------------: |\n     |    ⩽ 2GB     |     内存的2倍      |             内存的3倍              |\n     | > 2GB – 8GB  |    等于内存大小    |             内存的2倍              |\n     | > 8GB – 64GB |       至少4G       |            内存的1.5倍             |\n     |    > 64GB    |       至少4G       |           不建议使用休眠           |\n\n     最后结合日常使用，一般来说可以按照如下规则设置 swap 大小：\n\n     - 4G以内的物理内存，SWAP 设置为内存的2倍，不超过4G。\n     - 4-8G的物理内存，SWAP 等于内存大小。\n     - 8-64G 的物理内存，SWAP 设置为8G。\n     - 64-256G物理内存，SWAP 设置为16G。\n\n   - `/mnt`：全称 `mount` 可直接理解为 “挂载”，用于存放手动挂载的硬件。这部分是根目录`/` 下的目录，用来挂载文件系统。\n\n     一般的 Linux根目录展开如下图：\n\n     ![img](994198-20160908160724832-375737054.png)\n\n     然后按照官方的说明，是想把将根磁盘卷挂载到 `/mnt` 目录下，即 `/mnt` 变成 `/` 根目录。\n\n   **好了，了解完后下面正式开始。**\n\n   执行命令：\n\n   ```\n   fdisk /dev/sdx （sdx可以为sda、sdb等，具体以你实际需要挂载的磁盘名称为准）\n   ```\n\n   接着你就进入了 `fdisk` 操作环境，为了获取该命令下的操作功能，根据提示输入 `m` 并回车查看各命令的作用：\n\n   ![image-20220414144302934](image-20220414144302934.png)\n\n   在 `fdisk` 操作环境下：\n\n   1、对于一个全新的磁盘（格式化了），输入 `o` 来创建一个全新的 `MBR` 分区表（因为这里是 BIOS引导）；如果是旧磁盘（要么原本有 `MBR` 分区表，要么不是 `MBR` 属性 `DOS` 的），那对于非 `MBR` 分区表可能得更改分区表或者格式化，而已有 `MBR` 分区表的直接执行第 2步。\n\n   2、输入 `n` 创建一个新的分区，首先会让你选择类型分区，输入 `p` 选择主分区，回车接着选择分区号，这里一般直接回车使用默认数值，这样可以避免自己定义出现冲突；紧接着选择开始起扇区地址，如果不知道原有区域划分情况，那一般直接回车使用默认数值即可；随后，输入结束扇区地址或者容量大小，这里决定了你为该分区创建的容量大小；我们按照表格顺序创建分区，那这第一个就是 `swap` 交换分区，例如我分配的是 8G容量，那可以直接输入容量大小：`+8G` 。\n\n   3、创建完毕后，可以输入 `p` 来查看创建的分区。\n\n   4、重复第 2项创建根目录分区和第 3项确认最后的分区信息，至此就有两个分区（对应表格）。\n\n   5、最后输入 `w` 将之前所有的操作写入磁盘并生效。\n\n2. **UEFI/GPT**\n\n   与上一种引导方式相比，根据表格显示，只多了一个 **EFI 系统分区**，然后了解一下这个挂载点：\n\n   - `/mnt/boot`：上面说了官方是想把将根磁盘卷挂载到 `/mnt` 目录下，那这个 boot引导自然就挂载到了新的 `/mnt` 目录下了。\n\n   在该引导模式下的操作就如下。\n\n   执行命令如下进入 `fdisk` 操作环境：\n\n   ```\n   fdisk /dev/sdx （sdx可以为sda、sdb等，具体以你实际需要挂载的磁盘名称为准）\n   ```\n\n   在 `fdisk` 操作环境下：\n\n   1、对于一个全新的磁盘（格式化了），这里则输入 `g` 来创建一个全新的 `GPT` 分区表（因为到这里是 UEFI引导）；同样的如果是旧磁盘那跟上面的 BIOS引导操作差不多，只不过这里是 `GPT` 属性了。\n\n   2、输入 `n` 创建一个新的分区，让你选择分区号**（UEFI 比 BIOS 少了类型分区选择）**，这里一般直接回车使用默认数值，这样可以避免自己定义出现冲突；紧接着选择开始起扇区地址，如果不知道原有区域划分情况，那一般直接回车使用默认数值即可；随后，输入结束扇区地址或者容量大小，这里决定了你为该分区创建的容量大小；我们按照表格顺序创建分区，那这第一个就是 `/mnt/boot` 引导分区，例如我取的是 512MiB容量，那可以直接输入容量大小：`+512M` 。\n\n   3、创建完毕后，可以输入 `p` 来查看创建的分区。\n\n   4、重复第 2项和第 3项两次，分别创建 `[SWAP]` 和 `/mnt`，至此就有三个分区（对应表格）。\n\n   5、最后输入 `w` 将之前所有的操作写入磁盘并生效。\n\n\n\n## 格式化分区\n\n- **EFI系统分区（仅对于 UEFI/GPT引导方式）**\n\n  使用 `mkfs.fat` 命令将其格式化为 Fat32：\n\n  ```\n  mkfs.fat -F 32 /dev/sdxY （sdxY为上面创建的 EFI 系统分区符）\n  ```\n\n- **swap交换分区**\n\n  如果有创建，则请使用 `mkswap` 命令将其初始化：\n\n  ```\n  mkswap /dev/sdxY （sdxY为上面创建的交换空间分区符）\n  ```\n\n- **`/mnt` 根目录分区**\n\n  执行以下命令创建一个 Ext4 文件系统：\n\n  ```\n  mkfs.ext4 /dev/sdxY （sdxY为上面创建的根分区符）\n  ```\n\n\n\n## 挂载分区\n\n1、将根磁盘卷挂载到 `/mnt`，执行：\n\n```\nmount /dev/sdxY /mnt （把 sdxY替换为上面创建根分区符）\n```\n\n2、如果创建了 `swap` 交换空间卷，执行：\n\n```\nswapon /dev/sdxY （把 sdxY替换为上面创建的交换空间分区符）\n```\n\n3、对于 UEFI 系统，挂载 EFI 系统分区：\n\n```\nmkdir /mnt/boot\nmount /dev/sdxY /mnt/boot （把 sdxY替换为上面创建的 EFI 系统分区符）\n```\n\n\n\n## 选择镜像\n\n文件 `/etc/pacman.d/mirrorlist` 定义了软件包会从哪个镜像源下载。在列表中越前的镜像在下载软件包时有越高的优先权。\n\n各地区镜像源获取：https://archlinux.org/mirrorlist/ ，然后点击生成：\n\n![image-20220415095310180](image-20220415095310180.png)\n\n编辑 `/etc/pacman.d/mirrorlist` 文件，执行：\n\n```\nvim /etc/pacman.d/mirrorlist\n```\n\n然后进入 VIM 环境，输入 `i` 进入编辑状态，然后根据上面生成提供的镜像表，选择几个放到文件最顶端，在这里笔者选择阿里云镜像：\n\n![image-20220415103048537](image-20220415103048537.png)\n\n如果其速度不佳，可以手动指定其他镜像源，像中科大或者清华的放在最上面即可：\n\n```\nServer = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch\nServer = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch\n```\n\n然后，按 `Esc` 键退出编程，最后输入 `:wq` 保存退出。\n\n关于 vim 命令的使用，可看：https://www.runoob.com/linux/linux-vim.html\n\n\n\n## 安装必需的软件包\n\n使用 `pacstrap` 脚本，安装 [base](https://archlinux.org/packages/?name=base) 软件包和 Linux [内核](https://wiki.archlinux.org/title/Kernel_(简体中文))以及常规硬件的固件：\n\n```\npacstrap /mnt base base-devel linux linux-headers linux-firmware （base-devel在 AUR包的安装是必须的）\n```\n\n\n\n## Fstab配置\n\n生成自动挂载分区的 `fstab` 文件，执行命令：\n\n```\ngenfstab -U /mnt >> /mnt/etc/fstab\n```\n\n然后 `cat` 一下检查生成的 `/mnt/etc/fstab` 文件是否正确：\n\n```\ncat /mnt/etc/fstab\n```\n\n执行后将显示各分区挂载情况及属性信息。\n\n\n\n## Chroot配置\n\n[Change root](https://wiki.archlinux.org/title/Change_root_(简体中文)) 到新安装的系统：\n\n```\narch-chroot /mnt\n```\n\n执行了这步以后，我们的操作都相当于在磁盘上新装的系统中进行。\n\n\n\n## 时区配置\n\n设置时区：\n\n```\nln -sf /usr/share/zoneinfo/Region（地区名）/City（城市名） /etc/localtime\n```\n\neg：以上海为例，执行 `ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime`\n\n然后运行 `hwclock` 以生成 `/etc/adjtime`：\n\n```\nhwclock --systohc\n```\n\n\n\n## 本地化配置\n\n程序和库如果需要本地化文本，则需要根据区域设置 Locale，以明确规定地域、货币、时区日期的格式、字符排列方式和其他本地化标准。\n\n需在这两个文件设置：`locale.gen` 与 `locale.conf`。\n\n通过前面的 Chroot配置，我们已经处于 chroot 环境下了，这就意味这现在所在的系统中只有一些最基本的包（组件），而 VIM 组件并未包含在里面，这时候就需要自己安装组件包了。利用 Archlinux 下非常强大的包管理工具 `pacman`，其安装包的命令格式为 `pacman -S 包名`，`pacman` 会自动检查这个包所需要的其他包（即为依赖）并一起装上。\n\n然后我们安装 VIM 组件，执行：\n\n```\npacman -S vim\n```\n\n1、利用刚安装的 `vim` ，编辑 `locale.gen` 文件：\n\n```\nvim /etc/locale.gen\n```\n\n找到 `zh_CN.UTF-8 UTF-8`、`en_US.UTF-8 UTF-8` 这两行，去掉注释并保存。\n\n紧接着执行 `locale-gen` 以生成 locale 信息：\n\n```\nlocale-gen\n```\n\n2、然后创建 [locale.conf](https://man.archlinux.org/man/locale.conf.5) 文件，并 [编辑设定 LANG 变量](https://wiki.archlinux.org/title/Locale_(简体中文)#系统区域设置)，\n\n```\necho LANG=en_US.UTF-8 > /etc/locale.conf\n```\n\n\n\n## 网络配置\n\n创建 `/etc/hostname` 文件，并设定的一个 `myhostname`：\n\n```\necho myhostname > /etc/hostname （myhostname是你想要为该系统设置的名称）\n```\n\n这步在我目前使用的功能里好像没用到。。。\n\n然后，在官方文档中有一条说明：\n\n>  请注意，目前的 [base](https://archlinux.org/packages/?name=base) 不含有任何网络管理工具。对于新安装的系统环境，请接着完成[网络配置](https://wiki.archlinux.org/title/网络配置)，配置过程中可能包括要安装合适的[网络管理](https://wiki.archlinux.org/title/网络管理)软件。\n\n因此，我们需要安装网络配置管理包（[DHCP](https://wiki.archlinux.org/title/Dhcpcd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87))客户端和 [netctl](https://wiki.archlinux.org/title/Netctl_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87))网络管理器）：\n\n```\npacman -S dhcpcd netctl\n```\n\n\n\n## Root 密码\n\n`Root` 是 `Linux` 中具有最高权限帐户，有些敏感的操作必须通过 `Root` 用户进行，比如使用`pacman` 命令。\n\n执行以下命令，然后根据提示输入两次密码即可（注意输入是不显示出来）：\n\n```\npasswd root\n```\n\n\n\n## 安装引导程序\n\n如果是 Intel 或 AMD 的 CPU，启用 [微码](https://wiki.archlinux.org/title/Microcode_(简体中文)) 更新：\n\n- Intel\n\n  ```\n  pacman -S intel-ucode\n  ```\n\n- AMD\n\n  ```\n  pacman -S amd-ucode\n  ```\n\n接着，官方推荐的引导加载是 [GRUB](https://wiki.archlinux.org/title/GRUB_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)) （其他的引导加载可看：[引导功能比较](https://wiki.archlinux.org/title/Arch_boot_process_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%8A%9F%E8%83%BD%E6%AF%94%E8%BE%83)），因此我们对其安装并配置，不同的引导系统，其操作不一样：\n\n- **BIOS/MBR**\n\n  1、安装 `grub`：\n\n  ```\n  pacman -S grub\n  ```\n\n  2、部署 `grub`：\n\n  ```\n  grub-install --target=i386-pc /dev/sdx （sdx为要安装 GRUB 的磁盘，注意不是分区）\n  ```\n\n- **UEFI/GPT**\n\n  1、安装 `grub` 和 `efibootmgr`：\n\n  ```\n  pacman -S grub efibootmgr\n  ```\n\n  2、部署 `grub`：\n\n  ```\n  grub-install --target=x86_64-efi --efi-directory=esp --bootloader-id=GRUB （这里的 esp 替换成挂载点）\n  ```\n\n  像在这里，那就是：\n\n  ```\n  grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB\n  ```\n\n**最后，不管是哪个引导方式，都执行第三步：**\n\n3、生成配置文件：\n\n```\ngrub-mkconfig -o /boot/grub/grub.cfg\n```\n\n执行后，最后显示 `done` 即完成操作。\n\n\n\n**note：这一步是至关重要的一步，请检查是否正确安装好引导加载程序后再重新启动，否则下次重启后将无法正常进入系统。**\n\n\n\n## 重启\n\n最最最后，你需要进行重启来启动已经安装好的系统。\n\n1、输入以下命令退出 chroot 环境：\n\n```\nexit\n```\n\n2、手动取消挂载的分区（这有助于发现任何「繁忙」的分区）：\n\n**如果挂载了 `/mnt/boot`，先 `umount -r /mnt/boot`，再 `umount -r /mnt`，否则直接 `umount /mnt`。**\n\n```\numount -r /mnt/boot\numount -r /mnt\n```\n\n3、执行重启：\n\n```\nreboot\n```\n\n\n\n## Other\n\n另外一些比较详细的安装教程：\n\n[Arch Linux 安装使用教程](https://archlinuxstudio.github.io/ArchLinuxTutorial/#/?id=arch-linux-安装使用教程-archtutorial-arch-linux-studio)\n\n[以官方Wiki的方式安装ArchLinux](https://www.viseator.com/2017/05/17/arch_install/)\n\n","tags":["history","Linux"]},{"title":"X/YModem传输协议","url":"/docs/通讯协议/XYModem传输协议/","content":"\n\n# 文件传输\n\n最常用的几种文件传输协议有：XModem、YModem、ZModem等。\n\n- XModem是最早的文件传输协议之一，由于出现较早，几乎大部分的通讯程序所支持的文件传输都使用该协议，通常是传输 128字节的信息块；这种古老的传输协议速度虽然较慢，但由于使用了 CRC错误校验方法，传输的准确率可高达 99.6%。\n\n- YModem协议是 XModem的改进版，它最早用于调制解调器之间的文件传输，具有快速，稳定传输的优点。它的传输速度比 XModem快，这是由于它可以一次传输 1024字节的信息块，同时它还支持传输多个文件，也就是常说的批文件传输。\n\n- ZModem协议的处理速度快于 XModem和 YModem，这是因为它采用了串流式（streaming）传输方式，而且还具有自动改变区段大小和断点续传、快速错误侦测等功能，可以很好地进行断开后恢复传输。这是目前最流行的文件传输协议。\n\n- 除开上面介绍的三种 X / Y / ZModem协议，还有个常见的传输协议 --- ASCII协议，这是最快的传输协议，但只能传送文本文件。\n\n\n\nX / Ymodem协议：\nhttp://pauillac.inria.fr/~doligez/zmodem/ymodem.txt\n\nZmodem协议：\nhttp://gallium.inria.fr/~doligez/zmodem/zmodem.txt\n\n\n\n# 控制字符定义\n\n```\n<SOH> 01H       // 传输 128Byte 启动标志\n<STX> 02H \t\t// 传输 1024Byte 启动标志\n<EOT> 04H       // 传输结束\n<ACK> 06H       // 应答\n<NAK> 15H       // 没应答\n<CAN> 18H       // 取消传输\n<C> 43H         // ASCII 'C' CRC校验请求\n\n<NUL> 00H       // 空符填充\n<CPMEOF> 1AH    // 数据填充 (^Z)\n```\n\n\n\n# XModem通讯\n\nXmodem 是使用最广泛的文件传输协议之一。原始的 Xmodem 协议使用 128字节数据包和一个简单的 “校验和\" 错误检测方法。后面增强为 Xmodem-CRC，使用了更安全的循环冗余校验 (CRC) 用于错误检测方法。Xmodem 协议总是首先尝试使用 CRC。如果发件人不确认对 CRC 的请求，接收器将转移到 ”校验和“ 模式并继续其传输请求。\n\n增强型 Xmodem-1K 本质上是 Xmodem CRC 模式传输 1K (1024字节) 数据包。在某些系统和通报上它也可以称为 Ymodem。\n\n\n\nXmodem 协议传输由接收程序和发送程序完成，先由接收程序发送协商字符，协商校验方式，协商通过之后发送程序就开始发送数据包，接收程序接收到完整的一个数据包之后按照协商的方式对数据包进行校验。校验通过之后发送确认字符，然后发送程序继续发送下一包；如果校验失败，则发送否认字符，发送程序重传此数据包。**信息报中如果剩余的数据不足 128字节，不足的部分将以 `0x1A` 填充。**\n\n## 校验和模式\n\n### 帧包格式\n\n|        Byte1         |      Byte2      |       Byte3        |    Byte4~131     | Byte132  |\n| :------------------: | :-------------: | :----------------: | :--------------: | :------: |\n| Start Of Header(SOH) | Packet NumberID | ~(Packet NumberID) | Packet Data[128] | CheckSUM |\n\n### 传输方式\n\n|                        Sender                        | Flow |             Receiver             |\n| :--------------------------------------------------: | :--: | :------------------------------: |\n|                                                      | <--- |               NAK                |\n|                                                      |      |     Time out after 3 Second      |\n|                                                      | <--- |               NAK                |\n| \\<SOH\\> \\<0x01\\> \\<0xFE\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> |            Packet OK             |\n|                                                      | <--- |               ACK                |\n| \\<SOH\\> \\<0x02\\> \\<0xFD\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> | **Line hit during transmission** |\n|                                                      | <--- |             **NAK**              |\n| \\<SOH\\> \\<0x02\\> \\<0xFD\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> |            Packet OK             |\n|                                                      | <--- |               ACK                |\n| \\<SOH\\> \\<0x03\\> \\<0xFC\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> |            Packet OK             |\n|                 **ACK get garbaged**                 | <--- |               ACK                |\n| \\<SOH\\> \\<0x03\\> \\<0xFC\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> |       **Duplicate packet**       |\n|                                                      | <--- |             **NAK**              |\n| \\<SOH\\> \\<0x04\\> \\<0xFB\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> | **UART Framing err on any byte** |\n|                                                      | <--- |             **NAK**              |\n| \\<SOH\\> \\<0x04\\> \\<0xFB\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> |            Packet OK             |\n|                                                      | <--- |               ACK                |\n| \\<SOH\\> \\<0x05\\> \\<0xFA\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> | **UART Overrun err on any byte** |\n|                                                      | <--- |             **NAK**              |\n| \\<SOH\\> \\<0x05\\> \\<0xFA\\> \\<Data[0-127]\\> \\<Chksum\\> | ---> |            Packet OK             |\n|                                                      | <--- |               ACK                |\n|                         EOT                          | ---> |            Packet OK             |\n|                 **ACK get garbaged**                 | <--- |               ACK                |\n|                         EOT                          | ---> |            Packet OK             |\n|                       Finished                       | <--- |               ACK                |\n\n## CRC模式\n\n计算 16位 CRC 校验的除数多项式为：`X ^ 16 + X ^ 12 + X ^ 5 + 1`，信息报中的 128数据字节将参加 CRC 校验的计算，在发送端 CRC-16 的高字节在前，低字节在后。\n\n### 帧包格式\n\n|        Byte1         |      Byte2      |       Byte3        |    Byte4~131     | Byte132~133 |\n| :------------------: | :-------------: | :----------------: | :--------------: | :---------: |\n| Start Of Header(SOH) | Packet NumberID | ~(Packet NumberID) | Packet Data[128] | 16-Bit CRC  |\n\n### 传输方式\n\n传输流程：接收方要求发送方以 CRC 校验方式发送时以 ‘C’ 来请求，发送方将对此作出应答。\n\n|                       Sender                        | Flow |             Receiver             |\n| :-------------------------------------------------: | :--: | :------------------------------: |\n|                                                     | <--- |               'C'                |\n|                                                     |      |     Time out after 3 Second      |\n|                                                     | <--- |               'C'                |\n| \\<SOH\\> \\<0x01\\> \\<0xFE\\> \\<Data[0-127]\\> \\<CRC16\\> | ---> |            Packet OK             |\n|                                                     | <--- |               ACK                |\n| \\<SOH\\> \\<0x02\\> \\<0xFD\\> \\<Data[0-127]\\> \\<CRC16\\> | ---> | **Line hit during transmission** |\n|                                                     | <--- |             **NAK**              |\n| \\<SOH\\> \\<0x02\\> \\<0xFD\\> \\<Data[0-127]\\> \\<CRC16\\> | ---> |            Packet OK             |\n|                                                     | <--- |               ACK                |\n| \\<SOH\\> \\<0x03\\> \\<0xFC\\> \\<Data[0-127]\\> \\<CRC16\\> | ---> |            Packet OK             |\n|                                                     | <--- |               ACK                |\n|                         EOT                         | ---> |            Packet OK             |\n|                  ACK get garbaged                   | <--- |               ACK                |\n|                         EOT                         | ---> |            Packet OK             |\n|                      Finished                       | <--- |               ACK                |\n\n## 扩展\n\n关于校验和和 CRC 校验可以看以前的文章《[常用校验算法](https://blog.csdn.net/qq_42992084/article/details/116466029)》\n\n[XModem Protocol with CRC](https://web.mit.edu/6.115/www/amulet/xmodem.htm)\n\n\n\n# YModem通讯\n\nYmodem 本质上是允许多个批处理文件传输的 Xmodem-1K，也可表示为 YModem-1K。\n\nYmodem 在 Xmodem-1K 基础上发展，沿用了 `TeLink` 协议的添加空头块的做法，也就是增加 `block 0`。该 block 标识即将发送文件的 `文件名`，`文件大小` 和  `文件创建时间戳(一般不填写)`\n\nYmodem-g 是 Ymodem 的变体。它设计用于支持错误控制的调制解调器。该协议不提供软件纠错或恢复，但期望调制解调器提供服务。它是一种流式传输协议，以连续流的形式发送和接收 1K 个数据包，直到指示停止。YModem-g 传输形式与 YModem-1K 差不多，同时在发送完一个数据块后，它不会等待应答确认，而是快速连续地发送下一个数据块；如果有任何块不成功转移，整个转移被取消。\n\n## 起始帧（block 0）\n\nYModem 的起始帧并不直接传输文件的数据，而是将文件名与文件的大小放在数据帧中传输，它的帧长 = 3字节数据首部 + 128字节数据 + 2字节 CRC16 校验码 = 33字节。\n\n|        Byte1         | Byte2 | Byte3 |                 Byte4~131                 | Byte132~133 |\n| :------------------: | :---: | :---: | :---------------------------------------: | :---------: |\n| Start Of Header(SOH) | 0x00  | 0xFF  | [ \\<`filename`\\> \\<`filezise`\\> \\<NUL\\> ] | 16-Bit CRC  |\n\n说明：\n\n- Byte 1~3：头标志是 SOH，起始帧序固定为 0x00，帧序取反为 0xFF。\n- Byte 4~131：\n  - `filename` 是传输的文件名字，如文件名 `foo.c`，它在起始帧中的格式为：`66 6F 6F 2E 63 00`，也就是把 ASCII 码转成十六进制，最后的 0x00 代表文件名结束。\n  - `filesize` 是要传输的文件的大小，比如文件大小为 120 KByte，转换为 `120 * 1024 = 122880` Byte，转化为十六进制为 `0x1E00`，它在起始帧中的格式为：`31 45 30 30 00`，对应 ASCII 为 `1E00`，最后的 0x00 代表文件长度结束。\n  - 最后 `NUL` 代表剩余不足 128 Byte 部分用 0x00 填充。\n- Byte 132~133：CRCH、CRCL分别表示 16位 CRC 校验码的高 8位与低 8位，高字节在前，低字节在后。\n\n## 数据帧（block n）\n\n|        Byte1         |      Byte2      |       Byte3        |    Byte4~1027     | Byte1028~1029 |\n| :------------------: | :-------------: | :----------------: | :---------------: | :-----------: |\n| Start Of Header(STX) | Packet NumberID | ~(Packet NumberID) | Packet Data[1024] |  16-Bit CRC   |\n\n注意：有一种特殊的情况是，如果文件总大小小于等于 128字节或者文件数据最后剩余的数据小于 128字节，则 YModem 会选择 SOH 数据帧格式用 128 字节来传输数据，而数据不满 128 字节，剩余的数据用 `0x1A` 填充。\n\n这时数据帧的结构就变成了：\n\n文件大小小于 128字节：`<SOH> <01> <FE> <data1> <data2> ... <datan>  <CPMEOF> ... <CRCH> <CRCL>`\n\n文件最后剩余数据小于 128字节：`<SOH> <ID> <~ID> <data1> <data2> ... <datan> <CPMEOF> ... <CRCH> <CRCL>`\n\n## 结束帧（block n+1）\n\nYModem 的结束帧数据也采用 SOH 的 128字节数据帧\n\n|        Byte1         | Byte2 | Byte3 | Byte4~131 | Byte132~133 |\n| :------------------: | :---: | :---: | :-------: | :---------: |\n| Start Of Header(SOH) | 0x00  | 0xFF  |  \\<NUL\\>  | 16-Bit CRC  |\n\n## 传输流程\n\n以把 foo.c，大小为 4196Byte（16进制为 0x1064）的文件作为传输的对象：\n\n|                            Sender                            | Flow |        Receiver         |\n| :----------------------------------------------------------: | :--: | :---------------------: |\n|                                                              | <--- |           'C'           |\n|                                                              |      | Time out after 3 Second |\n|                                                              | <--- |           'C'           |\n| \\<SOH\\> \\<0x00\\> \\<0xFF\\> \\<Data[ `<foo.c>` \\| `<0x1064>` \\| \\<NUL\\> ]\\> \\<CRC16\\> | ---> |        Packet OK        |\n|                                                              | <--- |           ACK           |\n|                                                              | <--- |           'C'           |\n|     \\<STX\\> \\<0x01\\> \\<0xFE\\> \\<Data[0-1023]\\> \\<CRC16\\>     | ---> |        Packet OK        |\n|                                                              | <--- |           ACK           |\n|     \\<STX\\> \\<0x02\\> \\<0xFD\\> \\<Data[0-1023]\\> \\<CRC16\\>     | ---> |        Packet OK        |\n|                                                              | <--- |           ACK           |\n|     \\<STX\\> \\<0x03\\> \\<0xFC\\> \\<Data[0-1023]\\> \\<CRC16\\>     | ---> |        Packet OK        |\n|                                                              | <--- |           ACK           |\n|     \\<STX\\> \\<0x04\\> \\<0xFB\\> \\<Data[0-1023]\\> \\<CRC16\\>     | ---> |        Packet OK        |\n|                                                              | <--- |           ACK           |\n| \\<SOH\\> \\<0x05\\> \\<0xFA\\> \\<Data[0-99]\\> \\<CPMEOF[0-27]\\> \\<CRC16\\> | ---> |        Packet OK        |\n|                                                              | <--- |           ACK           |\n|                             EOT                              | ---> |        Packet OK        |\n|                                                              | <--- |         **NAK**         |\n|                             EOT                              | ---> |        Packet OK        |\n|                                                              | <--- |           ACK           |\n|                                                              | <--- |           'C'           |\n|      \\<SOH\\> \\<0x00\\> \\<0xFF\\> \\<NUL[0-127]\\> \\<CRC16\\>      | ---> |        Packet OK        |\n|                           Finished                           | <--- |           ACK           |\n\n\n\n# 参考\n\nhttps://en.wikipedia.org/wiki/XMODEM\n\nhttps://en.wikipedia.org/wiki/YMODEM\n\nhttps://en.wikipedia.org/wiki/ZMODEM\n\n[XMODEM, YMODEM, and ZMODEM](http://web.cecs.pdx.edu/~rootd/catdoc/guide/TheGuide_toc.html#SEC237)\n\n[Transmisja modemowa - Xmodem, Ymodem, Zmodem](https://slideplayer.pl/slide/434572/)\n\n[lrzsz: free x/y/zmodem implementation](https://www.ohse.de/uwe/software/lrzsz.html)\n\n\n\n# 附录\n\nCRC校验计算：\n\n```c\nint calcrc(char *ptr, int count)\n{\n    int  crc;\n    char i;\n    crc = 0;\n    while (--count >= 0)\n    {\n        crc = crc ^ (int) *ptr++ << 8;\n        i = 8;\n        do\n        {\n            if (crc & 0x8000)\n                crc = crc << 1 ^ 0x1021;\n            else\n                crc = crc << 1;\n        } while(--i);\n    }\n    return (crc);\n}\n```\n\n","tags":["history","Modem"],"categories":["传输协议"]},{"title":"Modbus家族之 ASCII","url":"/docs/Modbus/Modbus家族之 ASCII/","content":"\n\n\n> 嗨，相信在上一篇经过我的兄弟 RTU的介绍之后，已经对 Modbus有了一定的了解了吧；那么本篇就跟紧我的脚步一起学习新的知识吧。\n>\n\n\n\n# 描述\n\nModbus在串行设备中通过实现主从模型结构，解决了电子设备之间的数据通讯问题；在采用 Modbus协议时，它有两种主要的原始传输方式 ---- Modbus RTU 和 Modbus ASCII。而 Modbus RTU已经在上一篇介绍了，那么就在本篇中瞅瞅 ASCII吧。\n\n\n\n# 通讯方式\n\n## 帧格式\n\n|   Name   | Length (bytes) |                         Description                          |\n| :------: | :------------: | :----------------------------------------------------------: |\n|  Start   |       1        | Starts with colon : (ASCII hex value is 3A)<br/>（以冒号 `:` 开头，ASCII十六进制值为 3A） |\n| Address  |       2        |    Node address in hex<br/>（十六进制节点地址，字符表示）    |\n| Function |       2        |    Function code in hex<br/>（十六进制功能码，字符表示）     |\n|   Data   |     n x 2      | n is the number of data bytes, it depends on function<br/>（n是数据字节数，它取决于功能码） |\n|   LRC    |       2        |       Longitudinal redundancy check<br/>（LRC校验码）        |\n|   End    |       2        |                           CR / LF                            |\n\n注：地址、功能、数据和 LRC都是表示 8位值 (0-255) 的**大写**十六进制可读字符对；即：在 Modbus ASCII中，每个数据字节被分割成表示十六进制值中的两个 ASCII字符的两个字节。\n\n在 ASCII模式下，消息以冒号 `:` 字符开头（ASCII表示为 0x3A），以回车换行对 `\\r\\n` （ASCII表示为 0x0D和 0x0A）结尾；所有其他字段传输的数据所允许的十六进制表示字符为的 `0-9`、`A-F`。\n\n|    START     | ADDRESS | FUNCTION |  DATA   | LRC CHECK |       END        |\n| :----------: | :-----: | :------: | :-----: | :-------: | :--------------: |\n| 1 CHAR<br/>: | 2 CHARS | 2 CHARS  | n CHARS |  2 CHARS  | 2 CHARS<br/>CRLF |\n\n![image-20220326235527004](image-20220326235527004.png)\n\n## 功能码\n\nASCII最常用的功能代码跟 RTU的功能代码定义是一样的，这里就不多说了，可以去查看 《[Modbus家族之 RTU](https://blog.csdn.net/qq_42992084/article/details/123605912)》篇章的功能码部分，这里只是格式上有所不同而已，~~下一篇会对这两个原始传输方式进行对比的。~~ 嘛，还是直接合并到本篇，对 RTU和 ASCII进行对比分析吧，顺便回顾一下 RTU协议。\n\n| 访问地址：address |   映射地址    |       描述        |   功能   | R/W  |\n| :---------------: | :-----------: | :---------------: | :------: | :--: |\n|     1 ~ 10000     |   address-1   |       Coils       | 01/05/15 | R/W  |\n|   10001 ~ 20000   | address-10001 |  Discrete Inputs  |    02    |  R   |\n|   30001 ~ 40000   | address-30001 |  Input Registers  |    04    |  R   |\n|   40001 ~ 50000   | address-40001 | Holding Registers | 03/06/16 | R/W  |\n\n在这里，简单的举个 ASCII传输例子：\n\n例如，要读取 VAR1，你需要从地址 0x20C1读取 2个寄存器，所以你需要发送以下 ASCII消息：\n\n`:010420C1000218<CRLF>`\n\n- 请求：\n\n  |      Name       |                      Description                       |\n  | :-------------: | :----------------------------------------------------: |\n  |       ‘:’       |                Start of message - 0x3A                 |\n  |     ‘0’ ‘1’     |                  Node address – 0x01                   |\n  |     ‘0’ ‘4’     |      Function code (Read Input Registers) – 0x04       |\n  | ‘2’ ‘0’ ‘C’ ‘1’ |       Register address for reading VAR1 – 0x20C1       |\n  | ‘0’ ‘0’ ‘0’ ‘2’ |  Length of registers to be read (must be 2) – 0x0002   |\n  |     ‘1’ ‘8’     |                          LRC                           |\n  |    \\<CRLF\\>     | End of message, carriage return and line feed – 0x0D0A |\n\n此消息的响应如下：\n\n`:01040400001234B1<CRLF>`\n\n- 响应：\n\n  |              Name               |                      Description                       |\n  | :-----------------------------: | :----------------------------------------------------: |\n  |               ‘:’               |                Start of message - 0x3A                 |\n  |             ‘0’ ‘1’             |                  Node address – 0x01                   |\n  |             ‘0’ ‘4’             |      Function code (Read Input Registers) – 0x04       |\n  |             ‘0’ ‘4’             |           Read data length (4 bytes) – 0x04            |\n  | ‘0’ ‘0’ ‘0’ ‘0’ ‘1’ ‘2’ ‘3’ ‘4’ |           Value read from VAR1 – 0x00001234            |\n  |             ‘B’ ‘1’             |                          LRC                           |\n  |            \\<CRLF\\>             | End of message, carriage return and line feed – 0x0D0A |\n\n好了，那么就直入主题吧，常用功能码部分依然是如下几个：\n\n### 功能 01（01H）读线圈\n\n- 请求\n\n  读取从机中线圈的 ON/OFF 状态。不支持广播。请求消息指定了开始线圈和要读取的线圈数量。\n\n  下面是一个请求读取线圈的例子：19 - 55（Coil 20 to 56），37个线圈，从设备节点 3（注意起始地址是 19或 0x13，比线圈 20小 1）：\n\n  ![image-20220327151916968](image-20220327151916968.png)\n\n- 响应\n\n  线圈状态响应消息被打包为数据字段的每比特表示一个线圈。状态表示为：1 = ON，0 = OFF。第一个数据字节的 LSB包含请求中寻址的线圈。其他线圈跟随这个字节的高阶末端，并在随后的字节中从低阶到高阶。\n\n  例如，当线圈 20 - 27的状态显示 `ON - ON - OFF - OFF - ON - OFF - ON - OFF - ON - OFF` 时，以字节值二进制 `0101 0011 (0x53)` 表示。一个字节包含八个线圈的状态。如果返回的线圈数量不是 8的倍数，则最终数据字节中的剩余位将用 0填充(朝向字节的高阶末端)；字节计数字段指定数据的完整字节数。\n\n  > Figure 6 shows an example of a response to the query shown in Figure 5：\n\n  ![image-20220327152253123](image-20220327152253123.png)\n\n### 功能 02（02H）读离散输入\n\n- 请求\n\n  读取从机中离散输入的 ON/OFF 状态。不支持广播。请求消息指定起始输入和要读取的输入数量。\n\n  下面是一个从从设备节点 3读取离散输入 10101 - 10120，总共 20个输入的例子（注意起始地址是 100或 0x64，比输入 10101小 10001）：\n\n  ![image-20220327155421391](image-20220327155421391.png)\n\n- 响应\n\n  离散输入状态响应消息的构造与线圈状态(01H) 操作相同。\n\n  > Figure 8 shows an example of a response to the query shown in Figure 7：\n\n  ![image-20220327155851480](image-20220327155851480.png)\n\n### 功能 03（03H）读保持寄存器\n\n- 请求\n\n  读取从机中保持寄存器的二进制内容。不支持广播。请求消息指定起始寄存器和要读取的寄存器数量。\n\n  下面是一个从从设备节点 7读取保持寄存器 40201 - 40203，总共 3个寄存器的请求的例子（注意起始地址是 200或 0xC8，比寄存器 40201小 40001）：\n\n  ![image-20220327160332698](image-20220327160332698.png)\n\n- 响应\n\n  响应消息中的保持寄存器数据在每个寄存器中打包为两个字节，二进制内容在每个字节中右对齐；对于每个寄存器，第一个字节包含高阶位，第二个字节包含低阶位。\n\n  > Figure 10 shows an example of a response to the query shown in Figure 9：\n\n  ![image-20220327160607639](image-20220327160607639.png)\n\n### 功能 04（04H）读输入寄存器\n\n- 请求\n\n  读取从机中保持寄存器的二进制内容。不支持广播。请求消息指定起始寄存器和要读取的寄存器数量。\n\n  下面是一个从从设备节点 7读取输入寄存器 30301 - 30303，总共 3个寄存器的请求的例子（注意起始地址是300或0x12C，比寄存器 30301小 30001）：\n\n  ![image-20220327171629490](image-20220327171629490.png)\n\n- 响应\n\n  读输入寄存器数据的响应消息的构造与读取保持寄存器(03H) 操作相同。\n\n  > Figure 12 shows an example of a response to the query shown in Figure 11：\n\n  ![image-20220327171942458](image-20220327171942458.png)\n\n### 功能 05（05H）写单线圈\n\n- 请求\n\n  将单个线圈写入 ON或 OFF。当广播时，该函数强制所有附加的从机使用相同的线圈引用。请求消息指定要写入的线圈引用（启动线圈和状态）。\n\n  `FF 00` 的值要求线圈打开，值为 `00 00` 的请求为关闭，所有其他值都是非法的，不会影响线圈。\n\n  下面是一个在从设备节点 3中请求打开线圈 150的例子（注意起始地址是 149或 0x95，比线圈 150小 1）：\n\n  ![image-20220327172937327](image-20220327172937327.png)\n\n- 响应\n\n  正常的响应是请求的回显，在写入线圈状态之后返回。\n\n  > Figure 14 shows an example of a response to the query shown in Figure 13：\n\n  ![image-20220327173100544](image-20220327173100544.png)\n\n### 功能 06（06H）写单个保持寄存器\n\n- 请求\n\n  将一个值写入单个保持寄存器中。当广播时，该函数在所有附加的从机上设置相同的寄存器引用。请求消息指定要写入的寄存器引用（指定地址和数值）。\n\n  下面是一个请求从从设备节点 3中的保持寄存器 40150写入 1000数值的例子（注意起始地址为 149或 0x95，比寄存器 40150小 40001）：\n\n  ![image-20220327175033869](image-20220327175033869.png)\n\n- 响应\n\n  正常的响应是请求的回显，在写入保持寄存器内容之后返回。\n\n  > Figure 16 shows an example of a response to the query shown in Figure 15：\n\n  ![image-20220327175344005](image-20220327175344005.png)\n\n### 功能 15（0FH）写多个线圈\n\n- 请求\n\n  将一个线圈序列中的每个线圈写入 ON或 OFF。当广播时，该函数强制所有附加的从机使用相同的线圈引用。请求消息指定要写入的线圈引用（起始线圈和状态）。\n\n  下面的示例显示了从设备节点 5中的线圈 20开始写入一系列 10个线圈状态的请求。二进制位与线圈的对应方式如下（注意起始地址是 19或 0x13，比线圈 20小 1）：\n\n  | Bit  | 1    | 1    | 0    | 1    | 0    | 0    | 0    | 1    | 0    | 0    | 0    | 0    | 0    | 1    | 0    | 1    |\n  | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n  | Coil | 27   | 26   | 25   | 24   | 23   | 22   | 21   | 20   | ...  | ...  | ...  | ...  | ...  | 30   | 29   | 28   |\n  \n  ![image-20220327182406708](image-20220327182406708.png)\n\n- 响应\n\n  正常响应返回从地址、功能代码、起始地址和写入的线圈数量，不包括字节数和对应写入的状态。\n\n  > Figure 24 shows an example of a response to the query shown in Figure 23：\n\n  ![image-20220327182618637](image-20220327182618637.png)\n\n### 功能 16（10H）写多个保持寄存器\n\n- 请求\n\n  将值写入到一个保持寄存器序列中。当广播时，该函数在所有附加的从机上设置相同的寄存器引用。请求消息指定要写入的寄存器引用（起始寄存器和数值）。\n\n  下面是一个请求从从设备节点 5中的保持寄存器 40020到 40022写入以下数据的示例（注意起始地址是 19或 0x13，比寄存器 40020小 40001）：\n\n  | address | data   |\n  | ------- | ------ |\n  | 40020   | 0x0164 |\n  | 40021   | 0x0165 |\n  | 40022   | 0x0166 |\n  \n  ![image-20220327184941057](image-20220327184941057.png)\n\n- 响应\n\n  正常响应返回从地址、功能代码、起始地址和写入的寄存器数量，不包括字节数和对应写入的数据。\n\n  > Figure 26 shows an example of a response to the query shown in Figure 25：\n\n  ![image-20220327185223421](image-20220327185223421.png)\n\n## LRC校验\n\n```c\nunsigned char\nucMBLRC( unsigned char * pucFrame, unsigned short usLen )\n{\n    unsigned char ucLRC = 0;  /* LRC char initialized */\n\n    while( usLen-- )\n    {\n        ucLRC += *pucFrame++;   /* Add buffer byte without carry */\n    }\n\n    /* Return twos complement */\n    ucLRC = ( UCHAR ) ( -( ( CHAR ) ucLRC ) );\n    return ucLRC;\n}\n```\n\n校验原理可看 [常用校验算法](https://blog.csdn.net/qq_42992084/article/details/116466029)-LRC章节","tags":["history","modbus"],"categories":["传输协议"]},{"title":"Modbus家族之 RTU","url":"/docs/Modbus/Modbus家族之 RTU/","content":"\n\n\n> 您好啊，我是 Modbus家族成员的 RTU，同时期诞生的还有我的兄弟，它就是 ASCII。本篇呢就来让大家熟悉一下我吧，下一篇则由我兄弟 ASCII进行介绍。好了，废话不多说，接下来就带你们来认识一下我吧。\n>\n\n\n\n# 描述\n\nModbus RTU（远程终端单元）是原始 Modbus规范中定义的两种传输模式之一。 这两种模式是 Modbus RTU和 ASCII，它们被设计用于支持 RS232，RS485和 RS422接口的串行设备。 Modbus RTU的一个显着特点是它使用二进制编码和强大的 CRC错误检查。 Modbus RTU是 Modbus协议的实现，最常用于工业应用和自动化生产设施。嘻嘻，我可是很受工业场景应用的哦。\n\n\n\n# 通讯方式\n\n## 帧格式\n\n|   Name   | Length (bytes) |                         Description                          |\n| :------: | :------------: | :----------------------------------------------------------: |\n| Address  |       1        |                   Node address（节点地址）                   |\n| Function |       1        |                  Function code（功能代码）                   |\n|   Data   |       n        | n is the number of data bytes, it depends on function<br/>（n是数据字节数，它取决于功能码） |\n|   CRC    |       2        |          Cyclic redundancy check<br/>（CRC校验码）           |\n\n在 RTU模式下，消息以至少 3.5个字符的静默间隔为开始，以至少 3.5个字符的类似间隔结束。这是最容易实现的以波特率在网络上使用的字符次数的倍数(如下图中所示的 T1 - T2 - T3 - T4)。\n\n| START             | ADDRESS | FUNCTION | DATA       | CRC CHECK | END               |\n| ----------------- | ------- | -------- | ---------- | --------- | ----------------- |\n| **\\*T1–T2–T3–T4** | 8 BITS  | 8 BITS   | n x 8 BITS | 16 BITS   | **\\*T1–T2–T3–T4** |\n\n**\\*T1-T2-T3-T4**：表示不通信时的 3.5个字符。\n\n所有其他字段都由 8位数据组成。\n\n![image-20220319201759692](image-20220319201759692.png)\n\n## 功能码\n\nModbus设备最常用的功能代码如下表所示：\n\n![image-20220319195917761](image-20220319195917761.png)\n\n### 功能 01（01H）读线圈\n\n- 请求：\n\n  | 名称      | 长度   | 说明              |\n  | --------- | ------ | ----------------- |\n  | 设备地址  | 1 字节 |                   |\n  | 功能码    | 1 字节 | **0x01**          |\n  | 开始地址  | 2 字节 | 0x0000 to 0xFFFF  |\n  | 线圈数量  | 2 字节 | 1 to 2000 (0x7D0) |\n  | CRC校验码 | 2 字节 |                   |\n  \n  指令：设备地址（1byte）+ **0x01**（1byte）+ 起始地址（2byte）+ 线圈数（2byte）+ CRC（2byte）\n  \n- 应答：\n\n  | 名称                 | 长度   | 说明         |\n  | -------------------- | ------ | ------------ |\n  | 设备地址             | 1 字节 |              |\n  | 功能码               | 1 字节 | **0x01**     |\n  | 线圈数量对应的字节数 | 1 字节 | **\\*N**      |\n  | 线圈数据1            | 1 字节 |              |\n  | 线圈数据2            | 1 字节 |              |\n  | 线圈数据n            | 1 字节 | n = N or N+1 |\n  | CRC校验码            | 2 字节 |              |\n\n  **\\*N** = 线圈数量 / 8，如果余数非 0，则 N = N+1\n  \n  指令：设备地址（1byte）+ **0x01**（1byte）+ 字节数（1byte）+ 线圈状态（Nbyte）+ CRC（2byte）\n  \n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x81**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n\n**流程图：**\n\n![image-20220319211327513](image-20220319211327513.png)\n\n### 功能 02（02H）读离散输入\n\n- 请求：\n\n  | 名称         | 长度   | 说明              |\n  | ------------ | ------ | ----------------- |\n  | 设备地址     | 1 字节 |                   |\n  | 功能码       | 1 字节 | **0x02**          |\n  | 开始地址     | 2 字节 | 0x0000 to 0xFFFF  |\n  | 离散状态数量 | 2 字节 | 1 to 2000 (0x7D0) |\n  | CRC校验码    | 2 字节 |                   |\n  \n  指令：设备地址（1byte）+ **0x02**（1byte）+ 起始地址（2byte）+ 离散数（2byte）+ CRC（2byte）\n\n- 应答：\n\n  | 名称                     | 长度   | 说明         |\n  | ------------------------ | ------ | ------------ |\n  | 设备地址                 | 1 字节 |              |\n  | 功能码                   | 1 字节 | **0x02**     |\n  | 离散状态数量对应的字节数 | 1 字节 | **\\*N**      |\n  | 离散数据1                | 1 字节 |              |\n  | 离散数据2                | 1 字节 |              |\n  | 离散数据n                | 1 字节 | n = N or N+1 |\n  | CRC校验码                | 2 字节 |              |\n  \n  **\\*N** = 离散状态数量 / 8，如果余数非 0，则 N = N+1\n  \n  指令：设备地址（1byte）+ **0x01**（1byte）+ 字节数（1byte）+ 离散状态（Nbyte）+ CRC（2byte）\n  \n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x82**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n  \n\n**流程图：**\n\n![image-20220319212623922](image-20220319212623922.png)\n\n### 功能 03（03H）读保持寄存器\n\n- 请求：\n\n  | 名称           | 长度   | 说明             |\n  | -------------- | ------ | ---------------- |\n  | 设备地址       | 1 字节 |                  |\n  | 功能码         | 1 字节 | **0x03**         |\n  | 开始地址       | 2 字节 | 0x0000 to 0xFFFF |\n  | 保持寄存器数量 | 2 字节 | 1 to 125 (0x7D)  |\n  | CRC校验码      | 2 字节 |                  |\n\n  指令：设备地址（1byte）+ **0x03**（1byte）+ 起始地址（2byte）+ 保持寄存器数（2byte）+ CRC（2byte）\n\n- 应答：\n\n  | 名称                       | 长度   | 说明     |\n  | -------------------------- | ------ | -------- |\n  | 设备地址                   | 1 字节 |          |\n  | 功能码                     | 1 字节 | **0x03** |\n  | 保持寄存器数量对应的字节数 | 1 字节 | 2 \\* N   |\n  | 寄存器数值1                | 2 字节 |          |\n  | 寄存器数值2                | 2 字节 |          |\n  | 寄存器数值n                | 2 字节 | n = N    |\n  | CRC校验码                  | 2 字节 |          |\n\n  指令：设备地址（1byte）+ **0x03**（1byte）+ 字节数（1byte）+ 保持寄存器值（2 \\* Nbyte）+ CRC（2byte）\n\n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x83**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n\n**流程图：**\n\n![image-20220319213419588](image-20220319213419588.png)\n\n### 功能 04（04H）读输入寄存器\n\n- 请求：\n\n  | 名称           | 长度   | 说明             |\n  | -------------- | ------ | ---------------- |\n  | 设备地址       | 1 字节 |                  |\n  | 功能码         | 1 字节 | **0x04**         |\n  | 开始地址       | 2 字节 | 0x0000 to 0xFFFF |\n  | 输入寄存器数量 | 2 字节 | 1 to 125 (0x7D)  |\n  | CRC校验码      | 2 字节 |                  |\n\n  指令：设备地址（1byte）+ **0x04**（1byte）+ 起始地址（2byte）+ 输入寄存器数（2byte）+ CRC（2byte）\n\n- 应答：\n\n  | 名称                       | 长度   | 说明     |\n  | -------------------------- | ------ | -------- |\n  | 设备地址                   | 1 字节 |          |\n  | 功能码                     | 1 字节 | **0x04** |\n  | 保持寄存器数量对应的字节数 | 1 字节 | 2 \\* N   |\n  | 寄存器数值1                | 2 字节 |          |\n  | 寄存器数值2                | 2 字节 |          |\n  | 寄存器数值n                | 2 字节 | n = N    |\n  | CRC校验码                  | 2 字节 |          |\n\n  指令：设备地址（1byte）+ **0x04**（1byte）+ 字节数（1byte）+ 输入寄存器值（2 \\* Nbyte）+ CRC（2byte）\n\n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x84**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n\n**流程图：**\n\n![image-20220319214513539](image-20220319214513539.png)\n\n### 功能 05（05H）写单线圈\n\n- 请求：\n\n  | 名称           | 长度   | 说明             |\n  | -------------- | ------ | ---------------- |\n  | 设备地址       | 1 字节 |                  |\n  | 功能码         | 1 字节 | **0x05**         |\n  | 输出地址       | 2 字节 | 0x0000 to 0xFFFF |\n  | **\\*线圈数值** | 2 字节 | 0x0000 or 0xFF00 |\n  | CRC校验码      | 2 字节 |                  |\n\n  ***线圈数值** ：0xFF00 -> 请求线圈状态为 ON\n\n  ​\t\t\t\t\t\t0x0000 -> 请求线圈状态为 OFF\n\n  ​\t\t\t\t\t\t其他值 -> 非法且对线圈不起作用\n\n  指令：设备地址（1byte）+ **0x05**（1byte）+ 输出地址（2byte）+ 线圈值（2byte）+ CRC（2byte）\n\n- 应答：\n\n  | 名称      | 长度   | 说明             |\n  | --------- | ------ | ---------------- |\n  | 设备地址  | 1 字节 |                  |\n  | 功能码    | 1 字节 | **0x05**         |\n  | 输出地址  | 2 字节 | 0x0000 to 0xFFFF |\n  | 线圈数值  | 2 字节 | 0x0000 or 0xFF00 |\n  | CRC校验码 | 2 字节 |                  |\n\n  指令：正常响应是请求的应答\n\n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x85**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n\n**流程图：**\n\n![image-20220319215633462](image-20220319215633462.png)\n\n### 功能 06（06H）写单个保持寄存器\n\n- 请求：\n\n  | 名称       | 长度   | 说明             |\n  | ---------- | ------ | ---------------- |\n  | 设备地址   | 1 字节 |                  |\n  | 功能码     | 1 字节 | **0x06**         |\n  | 寄存器地址 | 2 字节 | 0x0000 to 0xFFFF |\n  | 寄存器数值 | 2 字节 | 0x0000 to 0xFFFF |\n  | CRC校验码  | 2 字节 |                  |\n  \n  指令：设备地址（1byte）+ **0x06**（1byte）+ 保持寄存器地址（2byte）+ 保持寄存器值（2byte）+ CRC（2byte）\n\n- 应答：\n\n  | 名称       | 长度   | 说明             |\n  | ---------- | ------ | ---------------- |\n  | 设备地址   | 1 字节 |                  |\n  | 功能码     | 1 字节 | **0x06**         |\n  | 寄存器地址 | 2 字节 | 0x0000 to 0xFFFF |\n  | 寄存器数值 | 2 字节 | 0x0000 to 0xFFFF |\n  | CRC校验码  | 2 字节 |                  |\n\n  指令：正常响应是请求的应答\n\n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x86**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n\n**流程图：**\n\n![image-20220319220604204](image-20220319220604204.png)\n\n### 功能 15（0FH）写多个线圈\n\n- 请求：\n\n  | 名称                 | 长度   | 说明              |\n  | -------------------- | ------ | ----------------- |\n  | 设备地址             | 1 字节 |                   |\n  | 功能码               | 1 字节 | **0x0F**          |\n  | 开始地址             | 2 字节 | 0x0000 to 0xFFFF  |\n  | 线圈输出数量         | 2 字节 | 1 to 1968 (0x7B0) |\n  | 线圈数量对应的字节数 | 1 字节 | **\\*N**           |\n  | 线圈输出数据1        | 1 字节 |                   |\n  | 线圈输出数据2        | 1 字节 |                   |\n  | 线圈输出数据n        | 1 字节 | n = N or N+1      |\n  | CRC校验码            | 2 字节 |                   |\n\n  **\\*N** = 线圈输出数量 / 8，如果余数非 0，则 N = N+1\n\n  指令：设备地址（1byte）+ **0x0F**（1byte）+ 起始地址（2byte）+ 线圈输出数（2byte）+ 字节数（1byte）+ 线圈输出数据（Nbyte）+ CRC（2byte）\n\n- 应答：\n\n  | 名称         | 长度   | 说明              |\n  | ------------ | ------ | ----------------- |\n  | 设备地址     | 1 字节 |                   |\n  | 功能码       | 1 字节 | **0x0F**          |\n  | 开始地址     | 2 字节 | 0x0000 to 0xFFFF  |\n  | 线圈输出数量 | 2 字节 | 1 to 1968 (0x7B0) |\n  | CRC校验码    | 2 字节 |                   |\n\n  指令：设备地址（1byte）+ **0x0F**（1byte）+ 起始地址（2byte）+ 线圈输出数（2byte）+ CRC（2byte）\n\n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x8F**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n\n**流程图：**\n\n![image-20220319223636555](image-20220319223636555.png)\n\n### 功能 16（10H）写多个保持寄存器\n\n- 请求：\n\n  | 名称                   | 长度   | 说明             |\n  | ---------------------- | ------ | ---------------- |\n  | 设备地址               | 1 字节 |                  |\n  | 功能码                 | 1 字节 | **0x10**         |\n  | 开始地址               | 2 字节 | 0x0000 to 0xFFFF |\n  | 寄存器数量             | 2 字节 | 1 to 123 (0x7B)  |\n  | 寄存器数量对应的字节数 | 1 字节 | 2 * N            |\n  | 寄存器数值1            | 2 字节 |                  |\n  | 寄存器数值2            | 2 字节 |                  |\n  | 寄存器数值n            | 2 字节 | n = N            |\n  | CRC校验码              | 2 字节 |                  |\n\n  指令：设备地址（1byte）+ **0x10**（1byte）+ 起始地址（2byte）+ 寄存器数（2byte）+ 字节数（1byte）+ 寄存器数值（2 * Nbyte）+ CRC（2byte）\n\n- 应答：\n\n  | 名称       | 长度   | 说明             |\n  | ---------- | ------ | ---------------- |\n  | 设备地址   | 1 字节 |                  |\n  | 功能码     | 1 字节 | **0x10**         |\n  | 开始地址   | 2 字节 | 0x0000 to 0xFFFF |\n  | 寄存器数量 | 2 字节 | 1 to 123 (0x7B)  |\n  | CRC校验码  | 2 字节 |                  |\n\n  指令：设备地址（1byte）+ **0x10**（1byte）+ 起始地址（2byte）+ 保持寄存器数（2byte）+ CRC（2byte）\n\n- 错误返回：\n\n  | 名称      | 长度   | 说明                 |\n  | --------- | ------ | -------------------- |\n  | 设备地址  | 1 字节 |                      |\n  | 功能码    | 1 字节 | **0x90**             |\n  | 错误码    | 1 字节 | 01 or 02 or 03 or 04 |\n  | CRC校验码 | 2 字节 |                      |\n\n**流程图：**\n\n![image-20220319224924985](image-20220319224924985.png)\n\n## CRC校验\n\n- CRC16_MODBUS查表法：\n\n    ```c\n    static const unsigned char aucCRCHi[] = {\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n        0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, \n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, \n        0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, \n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,\n        0x00, 0xC1, 0x81, 0x40\n    };\n\n    static const unsigned char aucCRCLo[] = {\n        0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,\n        0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,\n        0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,\n        0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,\n        0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,\n        0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,\n        0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,\n        0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, \n        0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,\n        0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,\n        0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,\n        0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,\n        0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, \n        0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,\n        0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,\n        0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,\n        0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,\n        0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,\n        0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,\n        0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,\n        0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,\n        0x41, 0x81, 0x80, 0x40\n    };\n\n    unsigned short\n    usMBCRC16( unsigned char * pucFrame, unsigned short usLen )\n    {\n        unsigned char   ucCRCHi = 0xFF;\n        unsigned char   ucCRCLo = 0xFF;\n        int             iIndex;\n\n        while( usLen-- )\n        {\n            iIndex = ucCRCLo ^ *( pucFrame++ );\n            ucCRCLo = ( unsigned char )( ucCRCHi ^ aucCRCHi[iIndex] );\n            ucCRCHi = aucCRCLo[iIndex];\n        }\n        return ( unsigned short )( ucCRCHi << 8 | ucCRCLo );\n    }\n    ```\n\n- CRC16_MODBUS运算法：\n\n  运算分析及计算，可看文章 [常用校验算法](https://blog.csdn.net/qq_42992084/article/details/116466029)-CRC章节\n\n\n\n# 实例应用\n\n测试应用可看以前的文章：\n\n[Nano130之 FreeModbus移植](https://blog.csdn.net/qq_42992084/article/details/107590803)","tags":["history","modbus"],"categories":["传输协议"]},{"title":"RT-Thread 应用总结","url":"/docs/RTOS/RT-Thread 应用总结/","content":"\n\n\n官方文档介绍：[RT-Thread文档中心](https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/README)\n\n\n\n# 各模块 API接口\n\n由于 RT-Thread实时操作系统跟各大类 RTOS应用原理大致相同，因此不再详述各模块功能的作用了（各模块功能的详细信息可参考以前的 《[FreeRTOS专栏](https://blog.csdn.net/qq_42992084/category_9684254.html)》），只总结各类功能接口的 API调用函数。\n\n\n\n官方 API参考手册：[RT-Thread API参考手册](https://www.rt-thread.org/document/api/index.html)\n\n\n\n![](04thread_sta.png)\n\n\n\n## 线程管理\n\n### A、线程使用\n\n![线程相关操作](04thread_ops.png)\n\n| 函数功能 | API 接口                                                     | 函数描述                                                     | 与 FreeRTOS相匹配的函数 |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------- |\n| 创建线程 | rt_thread_t rt_thread_create(const char \\*name, void (\\*entry)(void \\*parameter), void \\*parameter, rt_uint32_t stack_size, rt_uint8_t priority, rt_uint32_t tick); | 该函数将**从动态堆内存中**创建一个线程对象并分配线程对象内存和堆栈。 | xTaskCreate()           |\n| 删除线程 | rt_err_t rt_thread_delete(rt_thread_t thread);               | 调用该函数后，线程对象将会被移出线程队列并且从内核对象管理器中删除，线程占用的堆栈空间也会被释放，收回的空间将重新用于其他的内存分配。 | vTaskDelete()           |\n|          |                                                              |                                                              |                         |\n| 初始线程 | rt_err_t rt_thread_init(struct rt_thread \\*thread, const char \\*name, void (\\*entry)(void \\*parameter),  void \\*parameter, void \\*stack_start,  rt_uint32_t stack_size, rt_uint8_t priority,  rt_uint32_t tick); | 使用该函数创建的线程，线程句柄(或者说线程控制块指针) 、线程栈所占用的内存空间，均通过全局变量的方式进行分配，内核不负责动态分配内存空间（即由用户提供，**属于静态分配**，在编译时就被确定、被分配处理）。 | xTaskCreateStatic()     |\n| 脱离线程 | rt_err_t rt_thread_detach (rt_thread_t thread);              | 与 rt_thread_delete() 函数相对应，使线程对象在线程队列和内核对象管理器中被脱离。注：线程本身不应调用这个接口脱离线程本身 | vTaskDelete()           |\n|          |                                                              |                                                              |                         |\n| 启动线程 | rt_err_t rt_thread_startup(rt_thread_t thread);              | 当调用这个函数时，将把线程的状态更改为就绪状态，并放到相应优先级队列中等待调度。 |                         |\n|          |                                                              |                                                              |                         |\n| 线程睡眠 | rt_err_t rt_thread_sleep(rt_tick_t tick); rt_err_t rt_thread_delay(rt_tick_t tick); rt_err_t rt_thread_mdelay(rt_int32_t ms); | 这三个函数接口的作用相同，调用它们可以使当前线程挂起一段指定的时间，当这个时间过后，线程会被唤醒并再次进入就绪状态。 | vTaskDelay()            |\n\n对比：[FreeRTOS篇章之任务管理](https://blog.csdn.net/qq_42992084/article/details/104360962)\n\n\n\n### B、挂起和恢复\n\n- **线程挂起的函数接口：**\n\n  `rt_err_t rt_thread_suspend (rt_thread_t thread);`\n\n  线程挂起接口 rt_thread_suspend() 的参数和返回值见下表：\n\n  | **参数** | **描述**                                     |\n  | -------- | -------------------------------------------- |\n  | thread   | 线程句柄                                     |\n  | **返回** | ——                                           |\n  | RT_EOK   | 线程挂起成功                                 |\n  | RT_ERROR | 线程挂起失败，因为该线程的状态并不是就绪状态 |\n\n- [ ] 注：RT-Thread对此此函数有严格的使用限制，该函数只能使用来挂起当前线程（即自己挂起自己），不可以在线程A中尝试挂起线程B，而且在挂起线程自己后，需要立刻调用 `rt_schedule()` 函数进行手动的线程上下文切换。用户只需要了解该接口的作用即可，强烈不建议在程序中使用该接口，该接口可以视为是内部接口。这是因为A线程在尝试挂起B线程时，A线程并不清楚B线程正在运行什么程序，一旦B线程正在使用例如互斥量、信号量等影响、阻塞其他线程的内核对象，那么A线程尝试挂起B线程的操作将会引发连锁反应，严重危及系统的实时性（有些地方会将其描述为死锁，实际上这种现象不是死锁，但是也不比死锁好到哪去）。\n\n- **线程恢复的函数接口：**\n\n  `rt_err_t rt_thread_resume (rt_thread_t thread);`\n\n  线程恢复接口 rt_thread_resume() 的参数和返回值见下表：\n\n  | **参数** | **描述**                                                     |\n  | -------- | ------------------------------------------------------------ |\n  | thread   | 线程句柄                                                     |\n  | **返回** | ——                                                           |\n  | RT_EOK   | 线程恢复成功                                                 |\n  | RT_ERROR | 线程恢复失败，因为该个线程的状态并不是 RT_THREAD_SUSPEND 状态 |\n\n以上这两个函数类似于 [FreeRTOS篇章之临界区与调度器](https://blog.csdn.net/qq_42992084/article/details/104498558) 里面的调度器中的操作，但其要求并不一样。\n\n\n\n## 信号量\n\n![信号量相关接口](06sem_ops.png)\n\n| 函数功能         | API 接口                                                     | 函数描述                                                     | 与 FreeRTOS相匹配的函数                    |\n| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------ |\n| 创建信号量       | rt_sem_t rt_sem_create(const char \\*name, rt_uint32_t value, rt_uint8_t flag); | 系统**动态分配**一个 semaphore 对象，并初始化这个对象，然后初始化父类 IPC 对象以及与 semaphore 相关的部分。 | xSemaphoreCreateBinary()                   |\n| 删除信号量       | rt_err_t rt_sem_delete(rt_sem_t sem);                        | 通过删除信号量以释放系统资源，适用于动态创建的信号量。       | vSemaphoreDelete()                         |\n|                  |                                                              |                                                              |                                            |\n| 初始信号量       | rt_err_t rt_sem_init(rt_sem_t sem, const char \\*name, rt_uint32_t value, rt_uint8_t flag); | **属于静态分配**，它的内存空间在编译时期就被编译器分配出来，放在读写数据段或未初始化数据段上。 | xSemaphoreCreateBinaryStatic()             |\n| 脱离信号量       | rt_err_t rt_sem_detach(rt_sem_t sem);                        | 让信号量对象从内核对象管理器中脱离，适用于静态初始化的信号量。 | vSemaphoreDelete()                         |\n|                  |                                                              |                                                              |                                            |\n| 获取信号量       | rt_err_t rt_sem_take (rt_sem_t sem, rt_int32_t time);        | 通过获取信号量来获得信号量资源实例，当信号量值大于零时，线程将获得信号量，并且相应的信号量值会减 1。 | xSemaphoreTake() / xSemaphoreTakeFromISR() |\n| 无等待获取信号量 | rt_err_t rt_sem_trytake(rt_sem_t sem);                       | 与 `rt_sem_take(sem, RT_WAITING_NO)` 的作用相同，即当线程申请的信号量资源实例不可用的时候，它不会等待在该信号量上，而是直接返回 - `RT_ETIMEOUT`。 |                                            |\n|                  |                                                              |                                                              |                                            |\n| 释放信号量       | rt_err_t rt_sem_release(rt_sem_t sem);                       | 释放之前所获得的信号量资源实例。                             | xSemaphoreGive() / xSemaphoreGiveFromISR() |\n\n对比：[FreeRTOS篇章之二值信号量](https://blog.csdn.net/qq_42992084/article/details/104412659)\n\n\n\n## 互斥量\n\n![互斥量相关接口](06mutex_ops.png)\n\n| 函数功能         | API 接口                                                     | 函数描述                                                     | 与 FreeRTOS相匹配的函数       |\n| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------------- |\n| 创建互斥量       | rt_mutex_t rt_mutex_create (const char \\*name, rt_uint8_t flag); | 系统将先从对象管理器中**动态分配**一个 mutex 对象，并初始化这个对象，然后初始化父类 IPC 对象以及与 mutex 相关的部分。 | xSemaphoreCreateMutex()       |\n| 删除互斥量       | rt_err_t rt_mutex_delete (rt_mutex_t mutex);                 | 通过删除互斥量以释放系统资源，适用于动态创建的互斥量。       | vSemaphoreDelete()            |\n|                  |                                                              |                                                              |                               |\n| 初始互斥量       | rt_err_t rt_mutex_init (rt_mutex_t mutex, const char \\*name, rt_uint8_t flag); | **属于静态分配**，它的内存空间在编译时期就被编译器分配出来，放在读写数据段或未初始化数据段上。 | xSemaphoreCreateMutexStatic() |\n| 脱离互斥量       | rt_err_t rt_mutex_detach (rt_mutex_t mutex);                 | 把互斥量对象从内核对象管理器中脱离，适用于静态初始化的互斥量。 | vSemaphoreDelete()            |\n|                  |                                                              |                                                              |                               |\n| 获取互斥量       | rt_err_t rt_mutex_take (rt_mutex_t mutex, rt_int32_t time);  | 当线程获取了互斥量，那么线程就有了对该互斥量的所有权，即某一个时刻一个互斥量只能被一个线程持有。 | xSemaphoreTake()              |\n| 无等待获取互斥量 | rt_err_t rt_mutex_trytake(rt_mutex_t mutex);                 | 与 `rt_mutex_take(mutex, RT_WAITING_NO)` 的作用相同，即当线程申请的互斥量资源实例不可用的时候，它不会等待在该互斥量上，而是直接返回 - `RT_ETIMEOUT`。 |                               |\n|                  |                                                              |                                                              |                               |\n| 释放互斥量       | rt_err_t rt_mutex_release(rt_mutex_t mutex);                 | 使用该函数接口时，只有已经拥有互斥量控制权的线程才能释放它，每释放一次该互斥量，它的持有计数就减 1。 | xSemaphoreGive()              |\n\n对比：[FreeRTOS篇章之互斥量](https://blog.csdn.net/qq_42992084/article/details/104479069)\n\n\n\n## 事件集\n\n![事件相关接口](06event_ops.png)\n\n| 函数功能   | API 接口                                                     | 函数描述                                                     | 与 FreeRTOS相匹配的函数                            |\n| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------------- |\n| 创建事件集 | rt_event_t rt_event_create(const char \\*name, rt_uint8_t flag); | 系统从对象管理器中**动态分配**事件集对象，并初始化这个对象，然后初始化父类 IPC 对象。 | xEventGroupCreate()                                |\n| 删除事件集 | rt_err_t rt_event_delete(rt_event_t event);                  | 通过删除事件集对象控制块来释放系统资源，适用于动态创建的事件集。 | vEventGroupDelete()                                |\n|            |                                                              |                                                              |                                                    |\n| 初始事件集 | rt_err_t rt_event_init(rt_event_t event, const char \\*name, rt_uint8_t flag); | **属于静态分配**，它的内存空间在编译时期就被编译器分配出来，放在读写数据段或未初始化数据段上。 | xEventGroupCreateStatic()                          |\n| 脱离事件集 | rt_err_t rt_event_detach(rt_event_t event);                  | 将该事件集从内核对象管理器中脱离，适用于静态初始化的事件集。 | vEventGroupDelete()                                |\n|            |                                                              |                                                              |                                                    |\n| 发送事件   | rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set);   | 通过参数 set 指定的事件标志来设定 event 事件集对象的事件标志值，然后遍历等待在 event 事件集对象上的等待线程链表，判断是否有线程的事件激活要求与当前 event 对象事件标志值匹配，如果有，则唤醒该线程。 | xEventGroupSetBits() / xEventGroupSetBitsFromISR() |\n|            |                                                              |                                                              |                                                    |\n| 接收事件   | rt_err_t rt_event_recv(rt_event_t event, rt_uint32_t set, rt_uint8_t option, rt_int32_t timeout, rt_uint32_t \\*recved); | 系统首先根据 set 参数和接收选项 option 来判断它要接收的事件是否发生，如果已经发生，则根据参数 option 上是否设置有 `RT_EVENT_FLAG_CLEAR` 来决定是否重置事件的相应标志位，然后返回（其中 recved 参数返回接收到的事件）；如果没有发生，则把等待的 set 和 option 参数填入线程本身的结构中，然后把线程挂起在此事件上，直到其等待的事件满足条件或等待时间超过指定的超时时间。如果超时时间设置为零，则表示当线程要接受的事件没有满足其要求时就不等待，而直接返回 - `RT_ETIMEOUT`。 | xEventGroupWaitBits()                              |\n\n对比：[FreeRTOS篇章之事件位和事件组](https://blog.csdn.net/qq_42992084/article/details/104602274)\n\n\n\n## 邮箱\n\n![邮箱相关接口](07mb_ops.png)\n\n| 函数功能         | API 接口                                                     | 函数描述                                                     | 与 FreeRTOS相匹配的函数                      |\n| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------- |\n| 创建邮箱         | rt_mailbox_t rt_mb_create (const char \\*name, rt_size_t size, rt_uint8_t flag); | 创建邮箱对象时会先从对象管理器中分配一个邮箱对象，然后给邮箱**动态分配一块内存空间**用来存放邮件，这块内存的大小等于邮件大小（4 字节）与邮箱容量的乘积，接着初始化接收邮件数目和发送邮件在邮箱中的偏移量。 | xQueueCreate()                               |\n| 删除邮箱         | rt_err_t rt_mb_delete (rt_mailbox_t mb);                     | 释放相应的系统资源，当操作一旦完成，邮箱将被永久性的删除。   | vQueueDelete()                               |\n|                  |                                                              |                                                              |                                              |\n| 初始邮箱         | rt_err_t rt_mb_init(rt_mailbox_t mb, const char \\*name, void \\*msgpool, rt_size_t size, rt_uint8_t flag); | **属于静态分配**，与创建邮箱不同的是，静态邮箱对象的内存是在系统编译时由编译器分配的，一般放于读写数据段或未初始化数据段中，其余的初始化工作与创建邮箱时相同。 | xQueueCreateStatic()                         |\n| 脱离邮箱         | rt_err_t rt_mb_detach(rt_mailbox_t mb);                      | 把静态初始化的邮箱对象从内核对象管理器中脱离。               | vQueueDelete()                               |\n|                  |                                                              |                                                              |                                              |\n| 发送邮件         | rt_err_t rt_mb_send (rt_mailbox_t mb, rt_uint32_t value);    | 发送的邮件可以是 32 位任意格式的数据，一个整型值或者一个指向缓冲区的指针；当邮箱中的邮件已经满时，发送邮件的线程或者中断程序会收到 -`RT_EFULL` 的返回值。 | xQueueOverwrite() / xQueueOverwriteFromISR() |\n| 等待方式发送邮件 | rt_err_t rt_mb_send_wait (rt_mailbox_t mb, rt_uint32_t value, rt_int32_t timeout); | 与 rt_mb_send() 的区别在于有等待时间，如果邮箱已经满了，那么发送线程将根据设定的 timeout 参数等待邮箱中因为收取邮件而空出空间；如果设置的超时时间到达依然没有空出空间，这时发送线程将被唤醒并返回错误码。 |                                              |\n| 发送紧急邮件     | rt_err_t rt_mb_urgent (rt_mailbox_t mb, rt_ubase_t value);   | 与发送邮件几乎一样，唯一的不同是，当发送紧急邮件时，邮件被**直接插队放入了邮件队首**，这样，接收者就能够优先接收到紧急邮件，从而及时进行处理。 |                                              |\n|                  |                                                              |                                                              |                                              |\n| 接收邮件         | rt_err_t rt_mb_recv (rt_mailbox_t mb, rt_uint32_t \\*value, rt_int32_t timeout); | 只有当接收者接收的邮箱中有邮件时，接收者才能立即取到邮件并返回 `RT_EOK` 的返回值，否则接收线程会根据超时时间设置，或挂起在邮箱的等待线程队列上，或直接返回。 | xQueueReceive() / xQueueReceiveFromISR()     |\n\n对比：[FreeRTOS篇章之队列管理](https://blog.csdn.net/qq_42992084/article/details/104399531) 中的消息数目为 1的队列\n\n注：由于 FreeRTOS中并没有邮箱这一概念（邮箱这概念在 uCOS中有），但是其原理类似于利用队列发送单一数目的信息，由于在 32 系统上 4 字节（32 bit）的内容恰好可以放置一个指针，因此该信息通常为**数据指针**。\n\n\n\n## 消息队列\n\n![消息队列相关接口](07msg_ops.png)\n\n| 函数功能         | API 接口                                                     | 函数描述                                                     | 与 FreeRTOS相匹配的函数                                      |\n| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 创建队列         | rt_mq_t rt_mq_create(const char \\*name, rt_size_t msg_size, rt_size_t max_msgs, rt_uint8_t flag); | 从对象管理器中**动态分配**一个消息队列对象，然后给消息队列对象分配一块内存空间，组织成空闲消息链表，这块`内存的大小 = [消息大小 + 消息头（用于链表连接）的大小] x 消息队列最大个数`，接着再初始化消息队列，此时消息队列为空。 | xQueueCreate()                                               |\n| 删除队列         | rt_err_t rt_mq_delete(rt_mq_t mq);                           | 删除它以释放系统资源，一旦操作完成，消息队列将被永久性地删除。 | vQueueDelete()                                               |\n|                  |                                                              |                                                              |                                                              |\n| 初始队列         | rt_err_t rt_mq_init(rt_mq_t mq, const char \\*name, void \\*msgpool, rt_size_t msg_size, rt_size_t pool_size, rt_uint8_t flag); | **属于静态分配**，跟创建消息队列对象类似，只是静态消息队列对象的内存是在系统编译时由编译器分配的，一般放于读数据段或未初始化数据段中。 | xQueueCreateStatic()                                         |\n| 脱离队列         | rt_err_t rt_mq_detach(rt_mq_t mq);                           | 将使消息队列对象被从内核对象管理器中脱离。                   | vQueueDelete()                                               |\n|                  |                                                              |                                                              |                                                              |\n| 发送信息         | rt_err_t rt_mq_send (rt_mq_t mq, void \\*buffer, rt_size_t size); | 线程或者中断服务程序都可以给消息队列发送消息。当发送消息时，消息队列对象先从空闲消息链表上取下一个空闲消息块，把线程或者中断服务程序发送的消息内容复制到消息块上，然后把该消息块挂到消息队列的尾部。当且仅当空闲消息链表上有可用的空闲消息块时，发送者才能成功发送消息；当空闲消息链表上无可用消息块，说明消息队列已满，此时，发送消息的的线程或者中断程序会收到一个错误码（-`RT_EFULL`）。 | xQueueSend() / xQueueSendFromISR() xQueueSendToFront() / xQueueSendToFrontFromISR() |\n| 等待方式发送信息 | rt_err_t rt_mq_send_wait(rt_mq_t     mq, const void \\*buffer, rt_size_t size, rt_int32_t  timeout); | 与 rt_mq_send() 的区别在于有等待时间，如果消息队列已经满了，那么发送线程将根据设定的 timeout 参数进行等待。如果设置的超时时间到达依然没有空出空间，这时发送线程将被唤醒并返回错误码。 |                                                              |\n| 发送紧急信息     | rt_err_t rt_mq_urgent(rt_mq_t mq, void \\*buffer, rt_size_t size); | 与发送消息几乎一样，唯一的不同是，当发送紧急消息时，从空闲消息链表上取下来的消息块不是挂到消息队列的队尾，而是挂到队首，这样，接收者就能够优先接收到紧急消息，从而及时进行消息处理。 |                                                              |\n|                  |                                                              |                                                              |                                                              |\n| 接收信息         | rt_err_t rt_mq_recv (rt_mq_t mq, void \\*buffer, rt_size_t size, rt_int32_t timeout); | 当消息队列中有消息时，接收者才能接收消息，否则接收者会根据超时时间设置，或挂起在消息队列的等待线程队列上，或直接返回。 | xQueueReceive() / xQueueReceiveFromISR()                     |\n\n对比：[FreeRTOS篇章之队列管理](https://blog.csdn.net/qq_42992084/article/details/104399531)\n\n\n\n# 中断管理\n\n![中断相关接口](09interrupt_ops.png)\n\n对于上图，通常用的较多的是：\n\n## 全局中断开关\n\n**全局中断开关也称为**中断锁，是禁止多线程访问临界区最简单的一种方式，即通过关闭中断的方式，来保证当前线程不会被其他事件打断（因为整个系统已经不再响应那些可以触发线程重新调度的外部事件），也就是当前线程不会被抢占，除非这个线程主动放弃了处理器控制权。\n\n| 函数功能           | API 接口                                      | 函数描述                 | 与 FreeRTOS相匹配的函数                               |\n| ------------------ | --------------------------------------------- | ------------------------ | ----------------------------------------------------- |\n| 关闭整个系统的中断 | rt_base_t rt_hw_interrupt_disable(void);      | 关闭整个系统的中断       | taskENTER_CRITICAL() / taskENTER_CRITICAL_FROM_ISR()  |\n| 恢复整个系统的中断 | void rt_hw_interrupt_enable(rt_base_t level); | 恢复系统的上一个中断状态 | taskEXIT_CRITICAL() / taskEXIT_CRITICAL_FROM_ISR( x ) |\n\n**（1）rt_hw_interrupt_disable() API 函数**\n\n原型：`rt_base_t rt_hw_interrupt_disable(void);`\n\n返回参数：\n\n- rt_hw_interrupt_disable 函数运行前的中断状态\n\n\n\n**（2）rt_hw_interrupt_enable() API 函数**\n\n原型：`void rt_hw_interrupt_enable(rt_base_t level);`\n\n输入参数：\n\n- 前一次 rt_hw_interrupt_disable 返回的中断状态\n\n\n\n注：在这里就相当于 [FreeRTOS篇章之临界区与调度器](https://blog.csdn.net/qq_42992084/article/details/104498558) 里面的临界段中的操作。\n\n\n\n## 中断通知\n\n当整个系统被中断打断，进入中断处理函数时，需要通知内核当前已经进入到中断状态。\n\n针对这种情况，RT-Thread 提供如下两个接口：\n\n```c\nvoid rt_interrupt_enter(void);\t\t// 用于通知内核，当前已经进入了中断状态，并增加中断嵌套深度（执行 rt_interrupt_nest++）\nvoid rt_interrupt_leave(void);\t\t// 用于通知内核，当前已经离开了中断状态，并减少中断嵌套深度（执行 rt_interrupt_nest--）\n\n注：不要在应用程序中调用这两个接口函数。\n```\n\n其实这两个函数等同于 FreeRTOS中带 FromISR后缀的函数说明。\n\n\n\n# RT-Thread Studio上手\n\n安装及环境搭建过程可以直接参看官方的指导文档：[RT-Thread Studio使用文档](https://www.rt-thread.org/document/site/#/development-tools/rtthread-studio/um/studio-user-begin)\n\n**以下只是简单记录部分关键点：**\n\n## 控制台调试口修改\n\n在新建项目过程中，可从 GUI窗口中选择配置，如下图：\n\n![TIM截图20220226114622](TIM截图20220226114622.png)\n\n当后期需要重新分配时，则需要在代码和 RT-Thread setting中修改了，（以修改为 `UART 3` 为例）修改内容如下：\n\n![TIM截图20220226120341](TIM截图20220226120341.png)\n\n\n\n## 串口终端集成显示\n\n在 RT-Thread Studio上，是可以通过点击工具栏 `终端` 按钮，来打开对应的终端功能窗口查看输出信息的，并且同样支持与 RT-Thread特有的 `finsh` 命令进行交互，串口终端显示操作如下：\n\n![TIM截图20220226141345](TIM截图20220226141345.png)\n\n![TIM截图20220226142044](TIM截图20220226142044.png)\n\n\n\n## 与 CubeMX联合编程\n\n此操作的前提条件是已经安装了 STM32CubeMX\n\n### A、启动 CubeMX settings配置\n\n新建的工程，都是优先使用内部时钟源（如下图），但实际情况下，大部分是使用外部时钟的，因为其稳定性比较好；因此，以修改外部时钟为例。\n\n![TIM截图20220226115723](TIM截图20220226115723.png)\n\n由于 RT-Thread Studio支持与 CubeMX联合编程，所以我们只需在项目资源管理器中启动 `CubeMX settings` 进行配置就好（如下图），进入界面后，其操作实际等同于操作 STM32CubeMX。\n\n![image-20220226210308862](image-20220226210308862.png)\n\n### B、CubeMX settings配置生成注意点\n\n- 尽量生成 GCC工程，因为 RT-Thread Studio用的是 gcc编译器\n  ![image-20220226233830986](image-20220226233830986.png)\n\n- 选择生成独立的 .c .h文件\n  ![img](313583-20201110104753899-295524523.png)\n\n- 生成完成后返回界面，会提示替换了 `stm32xxx_hal_conf.h` 文件，因此，我们需要把原来的配置，同步过去，该哪些配置需要打开的，都一一打开。\n\n### C、添加编译规则\n\n在生成 CubeMX产生的工程后，打开 `drv_clk.c` 文件，你会发现 `clk_init()` 函数里面被自动更改了（如下图）；这也就意味着什么呢？记得备份啦，或者上 git / svn进行版本管理啦。\n\n![TIM截图20220226143627](TIM截图20220226143627.png)\n\n于是乎，对工程进行编译时，发现一堆报错，不禁怀疑 RT-Thread Studio是否支持与 CubeMX联合编程的。。。\n\n在这里就需要对编译做相关操作了：\n\n（1）在生成的 cubemx文件夹里，先检查 cubemx文件夹下有没有 `SConscript` 文件，如果有就跳过创建环节，检查内容。\n\n（2）核查并更改 `SConscript` 文件里面的内容。\n\n（3）有时候在生成 CubeMX产生的工程后，RT-Thread Studio会帮你生成一个 `SConscript` 文件，并写好了规则，如果是已有的，那么可以尝试先编译一下是否有新增的源码进行编译，如果没有，那么可以仿照如下的代码进行修改：\n\n![TIM截图20220226150650](TIM截图20220226150650.png)\n\n其中，上面规则里的 `src` 部分，需要根据实际内容增删需要编译的源文件（如下）：\n\n```markdown\nsrc = Split('''\nSrc/stm32g4xx_hal_msp.c\nSrc/main.c\nSrc/dma.c\nSrc/gpio.c\nSrc/usart.c\n''')\n```\n\n当然，为了一劳永逸，你也可以把它修改成这样子：\n\n```python\n# 引入 building 模块中所有的东西\nfrom building import *\n\n# 获取当前路径。\ncwd = GetCurrentDir()\n\n# 使能选择\nsearch_EN = 1\n\n# add cubemx drivers\n# search_EN为 0时，手动选择添加需要编译的源文件\n# search_EN为 1时，自动搜寻与 SrcRemove匹配以外的源文件\nif (0 == search_EN):\n\tsrc = Split('''\n\tSrc/stm32f4xx_hal_msp.c\n\tSrc/main.c\n\t''')\nelse:\n\tsrc = Glob('Src/*.c')\t\n\tSrcRemove(src, ['Src/stm32f4xx_it.c'])\n\tSrcRemove(src, ['Src/system_stm32f4xx.c'])\n\n# 创建头文件路径列表，并保存至 path中\npath = [cwd + '/Inc']\n\n# 这是 RT-Thread 基于 SCons 扩展的一个方法（函数）。\ngroup = DefineGroup('cubemx', src, depend = [''], CPPPATH = path)\n\nReturn('group')\n\n```\n\n通过上面，你可能发现，为什么文件中的 `stm32f4xx_it.c` 和 `system_stm32f4xx.c` 不加入构建；其实你可以尝试一下加入编译一下，你就会发现玄机了。\n\n更多的关于 SCons工具的使用可以观看如下链接：\n\n[https://www.rt-thread.org/document/site/#/development-tools/scons/scons?id=scons-%e7%ae%80%e4%bb%8b](https://www.rt-thread.org/document/site/#/development-tools/scons/scons?id=scons-简介)\n\n[https://scons.org/doc/production/HTML/scons-user/index.html](https://scons.org/doc/production/HTML/scons-user/index.html)\n\n最后记得更新 Sconscripts（在项目资源管理器选择目标工程 -> 右键 -> 更新 `Sconscripts`）：\n\n![image-20220226231733878](image-20220226231733878.png)\n\n### D、迁移 CubeMX产生的代码\n\n当完成上面操作后，再次构建工程，或多或少还会出现错误，大概率是函数重复定义导致，比如 `multiple definition of main`。这时候可以如下操作：\n\n![20220226173146](20220226173146.png)\n\n嘛，或许有时候在 CubeMX初次生成的 main()函数上自带了 `__WEAK` 弱处理关键字，但后期在多次更改 CubeMX settings配置后，会有出现去掉 `__WEAK` 的情况，所以为了安全，还是把 `__WEAK` 添加到上述的保护区域位置去吧。\n\n除了以上情况，在 CubeMX settings配置更多外设时，需要把 cubemx/Src里的 main.c文件里的配置函数，手动移加到 RT-Thread工程的 main.c主文件函数中（一些 RTT配置里面有的，就不用添加过去了，避免功能出错，例如 ETH 的配置）。如下图：\n\n![20220226172930](20220226172930.png)","tags":["history","RTOS"],"categories":["实时系统"]},{"title":"Modbus家族之开篇","url":"/docs/Modbus/Modbus家族之开篇/","content":"\n\n\n\n# 历史溯源\n\nModbus是由 Modicon公司（现在的施耐德电气 Schneider Electric）在 1979年开发的一种消息传递结构，为使用可编程逻辑控制器（PLC）通信而发表，用于在智能设备之间建立客户端 - 服务器通信；这是一个划时代、里程碑式的网络协议，因此为工业网络拉开了序幕。Modbus已经成为工业领域通信协议事实上的业界标准，并且现在是工业电子设备之间常用的连接方式。\n\nModbus在工业环境下很流行，因为它是公开发表并且无著作权要求的。它是为工业应用开发的，与其他标准相比，它相对易于部署和维护，除了要传输的数据格式的大小外，几乎没有其他限制。Modbus通常使用 **RS485**作为其物理层。\n\n## 发展史\n\nModicon，即今天的施耐德电气，于 1979 年向市场推出了 Modbus原始协议（Modbus ASCII和 Modbus RTU）；随着通信领域的迅速发展以及传输速度的提高，扩展版本 Modbus Plus（Modbus+或者MB+）紧接着出现，不过此协议是 Modicon专有的，**和 Modbus并不相同**；直到以太网技术的标准化和商品化，以太网成为了企业系统的业界标准，同时也成为了工业网络的业界标准；为了将 Modbus带入 21 世纪，一个开放的 Modbus TCP/IP规范于 1999 年修订发行；到了 2004 年 4 月，Modbus 协议从施耐德电气转移到 Modbus组织，这标志着对开放的承诺（**该规范可免费下载，并且**使用 Modbus 或 Modbus TCP/IP 协议无需后续许可费用）；至此，在 Modbus TCP/IP 因为它的开放性、简单、低成本的开发以及支持它所需的最少硬件等特点，存在多个 Modbus TCP变种，而 Modbus ASCII和 Modbus RTU在小型的嵌入式设备当中得到广泛应用。\n\n<br/>\n\n# 协议版本\n\nModbus协议目前存在用于**串口**、**以太网**以及其他支持**互联网协议**的网络的版本。\n\nModbus是一种请求 / 回复协议，提供由功能代码指定的服务。Modbus功能代码是 Modbus Request(请求) / Response(响应)  PDU 的元素。\n\n串行端口和以太网存在多种版本的 Modbus协议，最常见的是：\n\n- Modbus RTU\n- Modbus ASCII\n- Modbus TCP\n- Modbus Plus\n\n![](Modbus-Different-Types.jpg)\n\n\n\n## Modbus RTU\n\n`Modbus RTU` 是一种紧凑的，采用二进制表示数据的方式；因为使用二进制编码和 CRC错误检查的结合使得 Modbus RTU适用于工业应用，因为它比 ASCII字符的替代方案更有效地传输。在 Modbus RTU与 ASCII之间进行选择时，如果考虑性能，则 RTU是首选。\n\n\n\n## Modbus ASCII\n\n`Modbus ASCII` 是当设备设置为使用 `ASCII` （**美国信息交换标准代码**）模式时，在 `MODBUS` 串行线上把通信消息中的每个 8位字节将作为两个 ASCII 4位字符发送。当物理通信链路或设备的功能不允许符合 RTU计时器管理要求时，使用此模式。所以此模式的效率不如 RTU，因为每个字节需要两个字符。示例：字节0x7D编码为两个字符： `0x35`和 `0x42`（在 `ASCII`表中为 `0x37` = `'7'`，而 `0x44` = `'D'`）。\n\n\n\n## Modbus TCP\n\n`Modbus TCP` 是在 `TCP/IP` 网络上运行的 Modbus的实现，旨在允许 Modbus ASCII / RTU协议在基于 TCP / IP的网络上传输。Modbus / TCP将 Modbus消息嵌入 TCP / IP帧内。尽管实现起来非常简单，但是与网络相关的特性增加了一些挑战。例如，由于Modbus主机期望并要求在一定时间范围内对其轮询做出响应，因此必须考虑 TCP / IP网络的不确定性（和其他方面）。Modbus ASCII和 Modbus TCP之间的主要区别在于，Modbus ASCII所需的 LRC错误检查由 IP层执行。\n\n\n\n> 对于以上 `TCP`/ `RTU`/ `ASCII`的这三种通信协议在数据模型和功能调用上都是相同的，只有封装方式是不同的。\n\n\n\n## Modbus Plus\n\n`Modbus Plus` （Modbus+或者MB+）属于 Modbus的一个扩展版本，不过此协议是Modicon专有的，和 Modbus不同。它需要一个专门的协处理器来处理类似 HDLC的高速令牌旋转。它使用 1Mbit/s的双绞线，并且每个节点都有转换隔离设备，是一种采用转换／边缘触发而不是电压／水平触发的设备。连接 Modbus Plus到计算机需要特别的接口，通常是支持 ISA（SA85），PCI或者 PCMCIA总线的板卡。\n\n\n\n# 通信和设备\n\nModbus有下列三种通信方式：\n\n（1）以太网：对应的通信模式是 **Modbus TCP/IP**\n\n（2）异步串行传输（各种介质如有线 RS-232/422/485/、光纤、无线等）：对应的通信模式是 **Modbus RTU**或 **Modbus ASCII**\n\n（3）高速令牌传递网络：对应的通信模式是 **Modbus PLUS**\n\n\n\nModbus通过多种类型的物理介质进行通信，例如：\n\n- 串行RS-232\n- 串行RS-485\n- 串行RS-422\n- 以太网\n\nModbus RTU和 Modbus ASCII协议应用于串口链接（RS232、RS485、RS422），Modbus TCP/IP协议应用于以太网链接。\n\n![img](Modbus-Communication-Physical-Media.gif)\n\n\n\n# 消息结构\n\nModbus的主要消息结构是点对点，能够在点对点和多点网络上运行。\n\n![image-20220208222537825](image-20220208222537825.png)\n\nModbus协议遵循**主 / 从（客户端 / 服务器）**架构，主（客户端）向从（服务器）发送请求并等待响应。注意！目前 Modbus中使用的术语 “主” 和 “从” 已被术语 “客户端” 和 “服务器” 所取代了。\n\n![image-20220209165731722](image-20220209165731722.png)\n\n\n\n# 常见 Modbus开源库\n\n## [FreeModbus](https://www.embedded-experts.at/en/freemodbus/)\n\nFreeMODBUS 是流行的 Modbus 协议的免费实现，专门针对嵌入式系统。FreeMODBUS 提供了 *Modbus 应用协议 v1.1a* 的实现，并支持 *Modbus over serial line 规范 1.0* 中定义的 **RTU/ASCII** 传输模式 ；自 0.7 版以来，FreeModbus 还支持 **Modbus/TCP**；0.9 版添加了第一个 Modbus/TCP 端口嵌入式使用 LWIP TCP/IP 堆栈的系统。唯一可惜的是，该 FreeMODBUS 只对从机开放了源码，主机部分并未实现开源。\n\n以下是该 FreeMODBUS 的下载链接：\n\nhttps://www.embedded-experts.at/en/freemodbus-downloads/\n\n\n\n## [libmodbus](https://libmodbus.org/)\n\nlibmodbus是一个多平台的 Modbus 源库，适用于 Linux、Mac OS X、FreeBSD、QNX 和 Win32 等操作系统；可以根据 Modbus协议发送和接收数据。支持 RTU（串行）和 TCP（以太网）通信。\n\n以下是该 libmodbus 的下载链接：\n\nhttps://libmodbus.org/download/\n\n\n\n# 参考\n\n[Modbus主页](https://modbus.org/)\n\n[Modbus](https://zh.wikipedia.org/wiki/Modbus) - wiki\n\n[WHAT IS MODBUS?](https://realpars.com/modbus/)\n\n《[modbus communication manual](https://process.honeywell.com/us/en/support/product-documents-downloads?search=modbus%20communication%20manual)》\n\n《[MODBUS APPLICATION PROTOCOL SPECIFICATION V1.1b](https://modbus.org/docs/Modbus_Application_Protocol_V1_1b.pdf)》\n\n《[Modbus Fieldbus Networking](https://www.generationrobots.com/media/roboteq/modbus-manual.pdf)》\n\n《[Modbus Protocol Reference Guide](https://www.m-system.co.jp/mssenglish/service/emmodbus.pdf)》\n\n[Modbus RTU通信指南](https://www.virtual-serial-port.org/cn/articles/modbus-rtu-guide/)\n\n[高级Modbus ASCII教程](https://www.virtual-serial-port.org/cn/articles/modbus-ascii-guide/)\n\n[modbus tools](https://www.modbustools.com/modbus.html)\n\n","tags":["history","modbus"],"categories":["传输协议"]},{"title":"步进电机及丝杆","url":"/docs/步进电机及丝杆/","content":"\n\n\n# 步进电机\n\n## 介绍\n\n步进电机（英语：Stepper motor、Step motor）是直流无刷电机的一种，为具有如齿轮状突起（小齿）相锲合的定子和转子，可借由切换流向定子线圈中的电流，以一定角度逐步转动的电动机，能将电脉冲信号转换成相应角位移或线位移。\n\n\n\n### A、构造上\n\n步进电机在构造上有三种主要类型：反应式（Variable Reluctance, VR）、永磁式（Permanent Magnet, PM）和混合式（Hybrid Stepping, HS）\n\n![](15350977719637sn7os61sp.jpg)\n\n- 反应式：也叫感应式、磁滞式或磁阻式步进电机。定子上有绕组、转子由软磁材料组成；定、转子周边均匀分布小齿和槽，通电后利用磁导的变化产生转矩。结构简单、成本低、步距角小，可达1.2°、但动态性能差、效率低、发热大，可靠性难保证。\n\n  ![](2_10.png)\n\n- 永磁式：永磁式步进电机的转子用永磁材料制成，转子的极数与定子的极数相同。其特点是动态性能好、输出力矩大，但这种电机精度差，步矩角大（一般为7.5°或15°）。\n\n  ![](3_11.png)\n\n- 混合式：也叫永磁反应式、永磁感应式步进电机，综合了反应式和永磁式的优点。其定子上有多相绕组、转子上采用永磁材料，转子和定子上均有多个小齿以提高步矩精度。其特点是输出力矩大、动态性能好，步距角小，但结构复杂、成本相对较高。\n\n  ![](4_10.png)\n\n结构区别：\n\n![](step%20motor.jpg)\n\n### B、相数上\n\n从定子上绕组来分类，共有二相、三相和五相等系列。目前最受欢迎的是两相混合式步进电机，约占 97%以上的市场份额，其原因是性价比高，配上细分驱动器后效果良好。\n\n![](1535097802673o0o22s1864.jpg)\n\n- 两相：\n\n  ![](5_6%20-%20%E5%89%AF%E6%9C%AC.png)\n\n- 三相：\n\n  ![](5_6.png)\n\n### C、极数上\n\n按照接线方式的不同，步进电机又可以分为单极步进电机（Unipolar Stepper Motor），和双极步进电机（Bipolar Stepper Motor）。\n\n![](153509774969411451pn716%20-%20%E5%89%AF%E6%9C%AC.jpg)\n\n- 单极型：采用电流在一个绕组中始终沿固定方向流动的驱动方式（单极驱动）。虽然步进电机的结构较为复杂，但是由于仅需要电流 ON /OFF的控制，因此步进电机的驱动电路较简单。\n\n  ![](MT1-30_f02.gif)\n\n- 双极型：采用电流在一个绕组中双向流动的驱动方式（双极驱动）。这种方式电机的结构比较简单，端子数也较少，但由于必须控制一个端子的极性，因此驱动电路较为复杂。\n\n  ![](MT1-30_f01.gif)\n\n单极跟双极比较：\n\n・双极连接\n －采用电流在一个绕组中双向流动的驱动方式（双极驱动）。\n －结构简单，但步进电机的驱动电路复杂。\n －绕组利用率好，且可以进行精细的控制，因此步进电机能够获得很高的输出转矩。\n －可以减小在线圈中产生的反电动势，因此可以使用耐压低的电机驱动器。\n\n・单极连接\n －具有中心抽头，采用电流在一个绕组中始终沿固定方向流动的驱动方式（单极驱动）。\n －结构复杂，但步进电机的驱动电路简单。\n －绕组利用率差，与双极连接相比，步进电机只能获得约一半的输出转矩。\n －由于会在线圈中产生较高的反电动势，因此需要使用高耐压的电机驱动器。\n\n\n\n## 步进模式\n\n主要有 3种步进模式 ：\n\n- 整步\n- 半步\n- 微步\n\n### A、整步\n\n![](full-step-mode-stepper-motor.png)\n\n顾名思义，就是每走一步都是取整的意思。而在整步控制上，也可分成**单相通电驱动**和**双相通电驱动**：\n\n![](11_2.png)\n\n![](full_step_driving_1.png)\n\n它们之间最大的区别在于，双相通电驱动下，由于电机中流动的电流更多，产生的磁场也更强，因此扭矩也更大。\n\n### B、半步\n\n![](half-step-operation-of-stepper-motor.png)\n\n半步模式属于单相通电驱动和双相通电驱动的组合，这种模式可以将步距减小一倍（旋转45°，而不是90°）。其唯一的缺点是电机产生的扭矩不是恒定的，当两相都通电时扭矩较高，只有一相通电时扭矩较小。\n\n![](half_step_driving.png)\n\n### C、微步\n\n![](modes-of-excitation-of-stepper-motor-stepper-microstepping.png)\n\n在微步模式下，可以看作是半步模式的增强版，因为它可以进一步减小步距，并且具有恒定的扭矩输出。这是通过控制每相流过的电流强度来实现的。最多可将电机步距角细分 256倍，提高了低速光滑度和低速谐振效果。\n\n![](microstepping.png)\n\n\n\n## 运作方式\n\n步进电机的运行一般分为三个部分：\n\n- 控制器\n- 驱动器\n- 电机马达\n\n![](TIM%E6%88%AA%E5%9B%BE20211031144528.png)\n\n### A、控制器\n\n控制器类似于人的大脑，指引着电机转动的方向以及操控着电机运转的快慢；当配合着一些控制策略，如：PID 控制、自适应控制等等，会使得其运作效果相当出色；而对于常见的控制方式有：传统方式的步进电机控制系统、基于 PLC的步进电机控制系统、基于 DSP的步进电机控制系统、基于 ARM的步进电机控制系统等。\n\n### B、驱动器\n\n驱动器一般作两个功能：电机的精度控制和驱动运转控制。可分为恒流驱动与恒压驱动两种；恒压驱动方式因其电路构造简单，在高速领域时不易获得转矩的特性，现今已经很少使用；然而恒流驱动方式则是现在广为使用的驱动方式，在高速领域中能掌 握优良的转矩特性。\n\n常见的驱动电路有：\n\n- 单极步进电机驱动电路\n\n  ![](9_5.png)\n\n- 双极步进电机驱动电路\n\n  ![](10_4.png)\n\n### C、电机马达\n\n![](Image_506.png)\n\n略\n\n<br>\n\n# 滚珠丝杆\n\n## 种类\n\n![](TIM%E6%88%AA%E5%9B%BE20211101201524.png)\n\n![](TIM%E6%88%AA%E5%9B%BE20211101201817.png)\n\n## 型号\n\n![image-20211101202146111](image-20211101202146111.png)\n\n![image-20211101202211688](image-20211101202211688.png)\n\n![image-20211101202236464](image-20211101202236464.png)\n\n![image-20211101202300243](image-20211101202300243.png)\n\n![image-20211101202323044](image-20211101202323044.png)\n\n![image-20211101202343698](image-20211101202343698.png)\n\n![image-20211101202416290](image-20211101202416290.png)\n\n![image-20211101202437316](image-20211101202437316.png)\n\n![image-20211101202459745](image-20211101202459745.png)\n\n![image-20211101202522600](image-20211101202522600.png)\n\n\n\n# 传动装置\n\n## 通电自锁\n\n绕组通电时步进电机具有全部的保持力矩。这就意味着步进电机可以在不使用机械刹车的情况下保持在停止位置。\n\n![](stop_position_self_hold.jpg)\n\n## 刹车抱闸\n\n一旦电源被切断，电机自身的保持力矩丢失，电机不能在垂直操作中或施加外力作用下保持在停止位置。在提升和其它相似应用中需要使用带电磁刹车的电机。\n\n![](electromagnetic_brake_motor.jpg)\n\n<br>\n\n# 常用知识归纳\n\n## 细分与步进数\n\n### A、定义\n\n- **什么是步进数**\n\n  步进数，也叫脉冲数，是指步进电机转动一圈或是前进一段距离，需要电机需要接受的信号个数，单位为步。 因为电机的转动最终还是转化为直线运动，所以通常步进数指的是电机推动、拉动主轴，龙门等配件前进 1毫米所需要的步数。\n\n  当步进数不对的后果：\n\n  例如当一台雕刻机的电机步进数不对，直接影响雕刻出来的结果大小不对。比如步进为 100的机器，雕刻 1毫米的直线，电机需要的信号是 100，如果设置步进数为 200，那就多走了一倍的距离，实际雕刻出来的线条就为 2毫米了。\n\n- **什么是细分**\n\n  细分是步进电机驱动器的功能。步进电机的精度有限，一般的步进电机为 200步走一圈，走一步转动的角度是 1.8度。当我们需要电机走 0.9度时，电机就没有办法了。好在步进电机驱动器，可以帮助步进电机把精度提高，把精度提高一倍，叫做半步细分，也叫 1/2细分，此时电机一个信号脉冲就可以转动 0.9度。再把精度提高一倍，叫 1/4细分，走一步，相当于 0.45度。细分都是一倍倍上去的，有 1/2, 1/4, 1/8, 1/16, 1/32等，最大可达 256细分。\n\n### B、应用\n\n- **步进数计算三要素**\n\n  一个是电机转动一圈所需的脉冲数（原始步数）。这个一般为 200，对应的步进角为 1.8度；当然也有其他的，像一些小电机只有 15度，那么转一圈只需 24个脉冲。\n\n  二是所采用的传动结构。如果用丝杆，要知道丝杆的导程，就是说丝杆转一圈时，前进的毫米数（这个稍后说）。如果是皮带轮，就要知道齿数和齿距，两个相乘得到皮带轮转一圈，皮带前进的毫米数。\n\n  三是步进电机驱动器的细分数。计算的公式是： **原始脉冲数** 除于 **毫米数** 再乘于 **细分数**。\n\n- **合理的步进数**\n\n  步进数越大，理论上来说精度越高；然在实际应用中，精度是由很多因素决定的，比如说齿轮可能有间隙，皮带有弹性，机架会抖动等。因此小于 0.01精度的步进数是大部分是没有意义的。\n\n- **如何纠正步进参数**\n\n  有些不是我们自己购买的机器，我们可能不知道具体的电机，传动参数，那么还有一种调整的办法。 先随便设置一个步进数，如 200，然后在软件上控制电机走100毫米，如果设置对，实际走的距离就是100毫米，如果不对，那么有偏差，比如实际它只走了 80毫米。那么可以用以下方式计算正确的步进数。\n\n  原理： 正确的步进数跟正确的距离之比 = 错误的步进数跟错误的距离之比\n\n  公式：正确的步进数 = 正确的距离 乘于 错误的步进数 除于 错误的距离 = 100 * 200 / 80= 250 设置步进数为 250后，你会发现，走 100mm，就是100mm，校对成功。\n\n\n\n## 丝杆脉冲计算\n\n1. 首先认识丝杆的导程，一般来说常见的有 1205、1210、1605、1610等这些说法，然后前两位是直径，后两位表示导程，导程 05的丝杆就是每两个丝的间距为 5（单位：mm）。\n2. 以常规的步进电机 1.8度 200步进，那么走一圈就是 200 * 1.8 = 360度\n3. 假设驱动器是 8细分，那就是把 1.8度再分成 8份；所以经过驱动器的电机每一步进就是 1.8度 / 8 = 0.225度；最终在 8细分下每转一圈就是 200 * 8 = 1600步进。\n4. 当导程为 5的丝杠，则每转一圈走 5毫米，每一步进就是 5 / 1600 = 0.003125毫米，这就是**电机参数**。如果是导程为 3的参数，那就是 0.001875毫米，以次类推。\n5. 用 1除以电机参数就是**脉冲当量**，例如: 1 / 0.003125 = 320步进，就是每走 1毫米需要多少步进。\n\n## 常规公式\n\n$ 步进电机运行步数 = 运行位移 / 导程 * 360 / 步距角 * 细分数 $\n\n这是用步进电机接丝杆做驱动时用的，就是计算步进数的式子：各个变量如下：\n\n1. 步进电机运行步进数 —— 这是你要计算的（也可以说是脉冲的数量），\n2. 运行位移 / 导程 —— 这是位移和导程的关系，这个除出来，就是移动这一段距离螺杆需要转几圈。\n3. 360 / 步距角 —— 因为正常步进电机是一个脉冲转一个步距角，这个算出来就是多少步电机转一圈。例如：步距角 = 7.5度，这样算出来是 48，这就是 48步就走一圈。\n4. 细分数 —— 一般情况这个数值是 1，但是采用了细分的方式驱动，可以控制电机一步只转半个步距角，这时细分数就为 2。合在上面式子里就会算出 96步转一圈。\n5. 最后将 2、3、4 相乘。\n\n\n\n# 参考：\n\n[步进电机驱动器简介（上）——步进电机的特点、分类和工作原理](http://news.eeworld.com.cn/mp/TOSHIBA/a22212.jspx)\n\n[步进电机驱动器简介（下）——步进电机的控制驱动和安全技术](http://news.eeworld.com.cn/mp/TOSHIBA/a22342.jspx)\n\n[步进电机基础知识：类型、用途和工作原理](https://www.monolithicpower.cn/cn/stepper-motors-basics-types-uses)","tags":["history","电机"]},{"title":"Kicad应用总结","url":"/docs/Kicad应用总结/","content":"\n\n\n> 在当前这个时代，对于 PCB设计，有太多的 EDA设计软件了，如：Cadence、PADS、Altium等，但绝大多数是要授权的，而且如今人们版权意识正在提高；这对电子爱好者来说，要想 DIY一个好东西，免不了依赖于这些设计软件，但如果有开源的、顺手的软件，那么我们更倾于应用这些软件，毕竟从版权意识上看以及投向开源社区来讲都是好的。\n\n\n\n## 简介\n\nKiCad 是一个开源软件工具，用于设计电子原理图和 PCB 图形。 \n\n其官网地址：https://www.kicad.org/\n\n各操作文档说明：https://docs.kicad.org/\n\n由于 KiCad 是一个开源软件，所以我们可以获取到它的源码：https://github.com/KiCad/kicad-source-mirror\n\n当然，基于开源，它实现了跨平台：\n\n![image-20210814170409099](image-20210814170409099.png)\n\n\n\n然后在正式开篇之前，以下这些说明都是基于 V5.1.9版本（最新版为 V5.1.10，修正了部分 Bug）；该死 V6.0版本居然还没发布，对于想要了解 V6.0版本的一些升级功能的，可以移到 [KiCad 6 is coming!](https://techexplorations.com/blog/kicad/kicad-6-review-new-and-improved-features/#t-1611031599240)\n\n<br/>\n\n## 入门\n\n### 工作流程\n\nKicad有着其独特的工作流程：\n\n![kicad_flowchart](kicad_flowchart.png)\n\n设计一个 PCB板，主要由两个任务来完成：绘制原理图和布置电路板。\n\n### 文件说明\n\nKiCad在创建并使用时具有以下特定扩展名文件和文件夹，其主要用于原理图和电路板编辑。\n\n1. 项目管理文件\n\n   | 文件扩展名 | 描述                                                         |\n   | ---------- | :----------------------------------------------------------- |\n   | *.pro      | Small file containing a few parameters for the current project, including the component library list. |\n\n2. 原理图编辑器文件\n\n   | 文件扩展名    | 描述                                                         |\n   | ------------- | :----------------------------------------------------------- |\n   | *.sch         | Schematic files, which do not contain the components themselves. |\n   | *.lib         | Schematic component library files, containing the component descriptions: graphic shape, pins, fields. |\n   | *.dcm         | Schematic component library documentation, containing some component descriptions: comments, keywords, reference to data sheets. |\n   | *_cache.lib   | Schematic component library cache file, containing a copy of the components used in the schematic project. |\n   | sym-lib-table | Symbol library list (symbol library table): list of symbol libraries available in the schematic editor. |\n\n3. 制板编辑文件和文件夹\n\n   | 文件扩展名   | 描述                                                         |\n   | ------------ | :----------------------------------------------------------- |\n   | *.kicad_pcb  | Board file containing all info but the page layout.          |\n   | *.pretty     | Footprint library folders. The folder itself is the library. |\n   | *.kicad_mod  | Footprint files, containing one footprint description each.  |\n   | *.brd        | Board file in the legacy format. Can be read, but not written, by the current board editor. |\n   | *.mod        | Footprint library in the legacy format. Can be read by the footprint or the board editor, but not written. |\n   | fp-lib-table | Footprint library list (footprint library table): list of footprint libraries (various formats) which are loaded by the board or the footprint editor or CvPcb. |\n\n4. 通用文件\n\n   | 文件扩展名  | 描述                                                         |\n   | ----------- | :----------------------------------------------------------- |\n   | *.kicad_wks | Page layout description files, for people who want a worksheet with a custom look. |\n   | *.net       | Netlist file created by the schematic, and read by the board editor. This file is associated to the .cmp file, for users who prefer a separate file for the component/footprint association. |\n\n5. 特殊文件\n\n   | 文件扩展名 | 描述                                                         |\n   | ---------- | ------------------------------------------------------------ |\n   | *.cmp      | Association between components used in the schematic and their footprints. It can be created by Pcbnew and imported by Eeschema. Its purpose is to import changes from Pcbnew to Eeschema, for users who change footprints inside Pcbnew (for instance using Exchange Footprints command) and want to import these changes in schematic. |\n\n6. 其他文件\n\n   主要是生产生成文件\n\n   | 文件扩展名 | 描述                                                         |\n   | ---------- | ------------------------------------------------------------ |\n   | *.gbr      | Gerber files, for fabrication.                               |\n   | *.drl      | Drill files (Excellon format), for fabrication.              |\n   | *.pos      | Position files (ASCII format), for automatic insertion machines. |\n   | *.rpt      | Report files (ASCII format), for documentation.              |\n   | *.ps       | Plot files (Postscript), for documentation.                  |\n   | *.pdf      | Plot files (PDF format), for documentation.                  |\n   | *.svg      | Plot files (SVG format), for documentation.                  |\n   | *.dxf      | Plot files (DXF format), for documentation.                  |\n   | *.plt      | Plot files (HPGL format), for documentation.                 |\n\n<br/>\n\n## 常用快捷键\n\n首先说明一下，热键（即单个按键）直接用字母表示；组合键（是指先按住第一个键不放，然后按下第二个键，再放开这两个键。）则用 “ + ” 表示；多次按键（是指先按下第一个键并放开，然后按下第二个键并放开，以此类推。）则用 “ - ” 表示。\n\n### 常规\n\n| 快捷键           | 功能     |\n| ---------------- | -------- |\n| Ctrl + N         | 新建     |\n| Ctrl + O         | 打开     |\n| Ctrl + S         | 保存     |\n| Ctrl + Shift + S | 另存为   |\n| Ctrl + Z         | 撤销     |\n| Ctrl + Y         | 重做     |\n| Ctrl + X         | 剪切     |\n| Ctrl + C         | 复制     |\n| Ctrl + V         | 粘贴     |\n| Ctrl + F         | 查找     |\n| F1               | 放大     |\n| F2               | 缩小     |\n| F3               | 缩放重绘 |\n| F4               | 缩放中心 |\n| Home             | 适合屏幕 |\n| E                | 编辑     |\n\n### 原理图\n\n| 快捷键   | 功能                 |\n| -------- | -------------------- |\n| C        | 重复的器件符号或标签 |\n| R        | 旋转                 |\n| M        | 移动                 |\n| A        | 添加器件符号         |\n| P        | 添加电源符号         |\n| X        | X轴镜像              |\n| Y        | Y轴镜像              |\n| W        | 画线                 |\n| B        | 放置总线             |\n| L        | 添加标签             |\n| H        | 添加分层标签         |\n| Ctrl + L | 添加全局标签         |\n| J        | 添加连接点           |\n| Q        | 添加禁止连接标志     |\n| F8       | 更新到 PCB           |\n\n### PCB\n\n| 快捷键           | 功能                                             |\n| ---------------- | ------------------------------------------------ |\n| O                | 放置封装                                         |\n| D                | 保持角度拖动布线                                 |\n| X                | 布线                                             |\n| Q                | 编辑线宽/过孔尺寸                                |\n| L                | 锁定/解锁封装                                    |\n| V                | 常规状态下，切换层；布线状态下，放置过孔并切换层 |\n| N / Shift + N    | 切换网格大小                                     |\n| Ctrl + H         | 板层高对比模式（单层显示）                       |\n| W / Shift + W    | 切换线宽                                         |\n| Ctrl             | 保持角度                                         |\n| /                | 布线轨迹切换                                     |\n| B                | 填充所有铜层区域                                 |\n| Ctrl + Shift + M | 测量                                             |\n| Alt + 6          | 差分布线                                         |\n| G                | 调整铜层区域                                     |\n\n### 库封装\n\n| 快捷键  | 功能     |\n| ------- | -------- |\n| M       | 移动     |\n| X       | X轴镜像  |\n| Y       | Y轴镜像  |\n| Instert | 重复引脚 |\n\n<br/>\n\n## 常用插件\n\n### 主题配色\n\n地址链接：https://github.com/pointhi/kicad-color-schemes\n\n例如笔者当前的主题配色为（**behave-dark**）：\n\n![eeschema](eeschema.png)\n\n![pcbnew](pcbnew.png)\n\n### 动态 BOM\n\n吾称之为最硬合交互式 BOM操作：\n\n![Interactive HTML BOM](capture.gif)\n\n地址链接：https://github.com/openscopeproject/InteractiveHtmlBom\n\n### 泪滴生成\n\n地址链接：https://github.com/NilujePerchut/kicad_scripts\n\n泪滴的作用，这里就不说啦，以前有讲过，然后演示：\n\n焊盘：\n\n![image-20210814210020179](image-20210814210020179.png)\n\n通孔：\n\n![image-20210814211109805](image-20210814211109805.png)\n\n<br/>\n\n## Pcbnew中各层用途说明\n\n### 所支持的板层\n\nKiCAD在 Pcbnew中总计提供了 32个铜层供导线走线（可覆铜），12个固定技术层（按照正反面分为 6对），2个独立技术层，4个辅助层。\n\n在 KiCad里 Pcbnew的层描述中：\n\n- F.代表电路板上层（Front），B.代表电路板的下层（Back）；\n\n- 6对固定技术层：Adhesive、Solder Paste、Silk Screen、Solder Mask、Courtyard、Fabrication；\n\n- 2个独立技术层：Edge Cuts、Margin；\n\n- 4个辅助层：Comments、E.C.O. 1、E.C.O. 2、Drawings；\n\n![image-20210814212055614](image-20210814212055614.png)\n\n### 层的使用说明\n\n#### 固定技术层\n\nKiCad中12个技术层分为 6对：上层一个，下层一个。可以通过 F.或者 B.来区分它们的位置。\n\n| 技术层名称                                | 功能描述                                                     |\n| ----------------------------------------- | ------------------------------------------------------------ |\n| Adhesive (F.Adhes and B.Adhes) 粘合层     | 用于在波峰焊前将 SMD元件的粘合剂粘贴到电路板上的粘合层。     |\n| Solder Paste (F.Paste and B.Paste) 焊膏层 | 用于在回流焊接之前生产掩模以允许焊膏放置在 SMD元件的焊盘上；通常这些层只有表面安装元件的焊盘。 |\n| Silk Screen (F.SilkS and B.SilkS) 丝印层  | 主要用于放置印制信息，如元件的轮廓和标注，各种注释字符等。   |\n| Solder Mask (F.Mask and B.Mask) 阻焊层    | 这两个层定义了焊接的掩模，即不过绿油的区域；所有焊盘都要出现在这两个层的其中一个层（SMD元件）或者所有两个层（通孔元件）以防止焊盘被过油，影响导电。 |\n| Courtyard (F.CrtYd and B.CrtYd) 空间层    | 用于显示元件在 PCB上实际占用的空间大小。                     |\n| Fabrication (F.Fab and B.Fab) 制造层      | 用于辅助元件贴装；主要用于记录目的，以将信息传达给例如 PCB 制造商或组装厂。 |\n\n#### 独立技术层\n\n| 技术层名称        | 功能描述                                                     |\n| ----------------- | ------------------------------------------------------------ |\n| Edge.Cuts 边界层  | 用于绘制电路板轮廓。一般用于设置电路板的外形尺寸，数据标记，对齐标记，装配说明以及其它的机械信息。所以请仅使用此图层绘制 PCB的轮廓。 |\n| Margin 电气边界层 | 用于定义在电路板上能够有效放置元件和布线的区域。             |\n\n#### 辅助层\n\n| 技术层名称            | 功能描述      |\n| --------------------- | ------------- |\n| E.C.O. 1/2 用户自定层 | 2层，用于拓展 |\n| Comments 注释层       | 描述性注释    |\n| Drawings 图层         | 图形说明      |\n\n这些层可以任意使用，它们可以是组装或布线等的说明文本，也可以是组装或加工的构造图，嘛，一般没啥用。\n\n#### 铜层\n\n该层在 Kicad中最多可拓展 32层。\n\n在 Pcbnew中任何铜层的名字都是可以编辑的，我们一般使用默认的名称。当电路板是 2层板时，只有 F.Cu层和 B.Cu层。当增加相应的层级数时，在 F.Cu层和 B.Cu层之间，将插入从上层到下层的顺序依次为 In1.Cu，In2.Cu，In3.Cu和 In4.Cu等的名称板层。\n\n1. 通常，电路板是 2层时，采用如下结构：\n\n   | 层编号 | 层名称 | 用途描述  |\n   | ------ | ------ | --------- |\n   | 1      | F.Cu   | Signal    |\n   | 2      | B.Cu   | GND Plane |\n\n2. 通常，电路板是 4层时，采用如下结构：\n\n   | 层编号 | 层名称 | 用途描述  |\n   | ------ | ------ | --------- |\n   | 1      | F.Cu   | Signal    |\n   | 2      | In1.Cu | GND Plane |\n   | 3      | In2.Cu | VCC Plane |\n   | 4      | B.Cu   | Signal    |\n\n3. 通常，电路板是 6层时，采用如下结构：\n\n   | 层编号 | 层名称 | 用途描述  |\n   | ------ | ------ | --------- |\n   | 1      | F.Cu   | Signal    |\n   | 2      | In1.Cu | GND Plane |\n   | 3      | In2.Cu | Signal    |\n   | 4      | In3.Cu | Signal    |\n   | 5      | In4.Cu | VCC Plane |\n   | 6      | B.Cu   | Signal    |\n\n4. 通常，电路板是 8层时，采用如下结构：\n\n   | 层编号 | 层名称 | 用途描述  |\n   | ------ | ------ | --------- |\n   | 1      | F.Cu   | Signal    |\n   | 2      | In1.Cu | GND Plane |\n   | 3      | In2.Cu | Signal    |\n   | 4      | In3.Cu | VCC Plane |\n   | 5      | In4.Cu | GND Plane |\n   | 6      | In5.Cu | Signal    |\n   | 7      | In6.Cu | VCC Plane |\n   | 8      | B.Cu   | Signal    |\n\n5. 通常，电路板是 10层时，采用如下结构：\n\n   | 层编号 | 层名称 | 用途描述  |\n   | ------ | ------ | --------- |\n   | 1      | F.Cu   | Signal    |\n   | 2      | In1.Cu | GND Plane |\n   | 3      | In2.Cu | Signal    |\n   | 4      | In3.Cu | Signal    |\n   | 5      | In4.Cu | VCC Plane |\n   | 6      | In5.Cu | GND Plane |\n   | 7      | In6.Cu | Signal    |\n   | 8      | In7.Cu | Signal    |\n   | 9      | In8.Cu | VCC Plane |\n   | 10     | B.Cu   | Signal    |\n\n<br/>\n\n## 生产制造\n\n在使用本操作时，假定您已经在 KiCad中完成了 PCB的设计。\n\n### 设置 PCB原点坐标\n\n选择 “菜单栏”，放置 -> 钻孔和位置偏移（或者在右边菜单栏直接选择），将原点放置到 PCB板框左下角位置，再放置【层对齐标记】到刚刚放置的原点位置。\n\n![image-20210814222049491](image-20210814222049491.png)\n\n### Gerber导出\n\n从菜单栏中点击绘制按键：\n\n![image-20210814220901206](image-20210814220901206.png)\n\n绘制 Gerber，并输出到相应文件夹：\n\n![image-20210814221059310](image-20210814221059310.png)\n\n绘制完后，点击旁边的 “生成钻孔文件” 进入设置生成：\n\n![image-20210814222350241](image-20210814222350241.png)\n\n生成文件放置到同样的文件夹，同时需要注意一下钻孔单位一般要对应 Pcbnew中所使用的单位。\n\n### BOM输出\n\n1. 从原理图输出\n\n   点击生成 BOM：\n\n   ![image-20210814230416366](image-20210814230416366.png)\n\n   选择生成插件：\n\n   ![image-20210814230521885](image-20210814230521885.png)\n\n   值得注意的是，在箭头处需要添加后缀 “**.csv**\"\n\n2. 从 PCB中输出\n\n   ![image-20210814231010230](image-20210814231010230.png)","tags":["history","EDA"]},{"title":"Cortex-M3/M4/M7 故障异常分析","url":"/docs/Cortex-M3M4M7 故障异常分析/","content":"\n\n\n> 在程序开发阶段，少不了 Debug调试，除去编程架构搭建不稳定所造成的错误外，大部分会出现或多或少的故障异常，而这些异常有可能是粗心或者对编程了解不到位所导致的 ‘ 堆栈溢出 ’ 、‘ 数组下标越界 ’ 、‘ 数学运算异常 ’ 等等；而本篇则主要以常见的进入 Hardfault中断来进行分析错误来源。\n\n\n\n# ARM Cortex-M核心\n\n**ARM** 架构，过去称作**高级精简指令集机器**（英语：Advanced RISC Machine，更早称作艾康精简指令集机器，Acorn RISC Machine），是一个精简指令集（RISC）处理器架构家族，其广泛地使用在许多嵌入式系统设计。\n\n而对于 **ARM Cortex-M** 是 ARM架构处理器核心中，低阶系列的统称，由安谋控股所授权。这组核心的特点为低成本以及高能源效率的微处理器而优化设计，已有上千万个消费性设备中有此系列的微处理器。此系列核心包括 Cortex-M0、Cortex-M0+、Cortex-M1、Cortex-M3、Cortex-M4、Cortex-M7、Cortex-M23、Cortex-M33、Cortex-M35P和 Cortex-M55。其中 Cortex-M4 / M7 / M33 / M35P / M55 核心有浮点运算器的选项，若有浮点运算器的选项，会在型号后面说明，例如 Cortex-Mx with FPU或 Cortex-MxF，其中 x是核心编号。\n\n如标题所述，其中 Cortex-M3/M4/M7同属 **ARMv7-M**架构，再细分一点，Cortex-M3实现的是 **ARMv7-M**架构，Cortex-M4 /Cortex-M7实现的是 **ARMv7E-M**架构。\n\n\n\n# ARMv7-M和 ARMv7E-M架构区别\n\n如果有玩过过 Cortex-M3系列的芯片跟 Cortex-M4/M7的芯片，或多或少都知道 Cortex-M4/M7比 Cortex-M3多了 **DSP**跟**硬件浮点运算**，以下是 ARMv7E-M架构的拓展功能介绍：\n\n![image-20210717125804779](image-20210717125804779.png)\n\n由于 ARMv7E-M是 ARMv7-M的一个拓展子集，所以以下统称 **ARMv7-M**为 “ ARMv7-M ” 和 “ ARMv7E-M ” 的集合。\n\n\n\n# ARM 寄存器\n\n![image-20210717153032356](image-20210717153032356.png)\n\n## 通用寄存器（R0 - R12）\n\nR0-R7被称为低组寄存器。所有指令都能访问它们。它们的字长全是 32位，复位后的初始值是不可预料的。\n\nR8-R12被称为高组寄存器。这是因为只有很少的 16位 Thumb指令能访问它们，32位的 thumb-2指令则不受限制。它们也是 32位字长，且复位后的初始值是不可预料的。\n\n## 堆栈指针寄存器（SP）\n\n在 ARMv7-M架构中，共有两个堆栈指针 `SP_main` 和 `SP_process`，有时候也会把这个堆栈指针寄存器称为 **R13**。\n\n- 主堆栈指针（MSP），或写作 `SP_main`。这是缺省的堆栈指针，它由 OS内核、异常服务例程以及所有需要特权访问的应用程序代码来使用。\n- 进程堆栈指针（PSP），或写作 `SP_process`。用于常规的应用程序代码（不处于异常服用例程中时）。\n\n## 链接寄存器（LR）\n\n链接寄存器（LR） 主要用于在调用子程序时存储返回地址；有时候也会把这个链接寄存器称为 **R14**。\n\n## 程序计数器（PC）\n\n程序计数器作为 PC（或称为 R15）访问，它根据所执行指令的大小（在 ARM 状态下始终为 4 个字节）递增；并通过分支指令将目标地址加载到 PC 中。 您还可以使用数据处理指令直接加载 PC。\n\n\n\n**Note：** 寄存器 R0-R12、SP、LR和 PC被称为 Arm核心寄存器。这些寄存器可以描述为 R0-R15。更详细的说明可以看《ARMv7-M Architecture Reference Manual》B1.4章 Registers部分\n\n\n\n# 异常定义\n\n## 异常类型\n\n![image-20210717132436090](image-20210717132436090.png)\n\n## 异常更新\n\n在入栈和取向量操作完成之后，执行服务例程之前，需要更新一系列的寄存器：\n\n- SP：在入栈后会把堆栈指针（PSP或 MSP）更新到新的位置。在执行服务例程时，将由 MSP负责对堆栈的访问。\n- PSR：更新 IPSR位段（地处PSR的最低部分）的值为新响应的异常编号。\n- PC：在取向量完成后，PC将指向服务例程的入口地址，\n- LR：在出入 ISR的时候，LR的值将得到重新的诠释，这种特殊的值称为 “EXC_RETURN”，在异常进入时由系统计算并赋给 LR，并在异常返回时使用它。EXC_RETURN的二进制值除了最低 4位外全为 1，而其最低4位则有另外的含义。\n\n以上是在响应异常时核心寄存器的变化。另一方面，在 NVIC中，也会更新若干个相关有寄存器。例如，新响应异常的悬起位将被清除，同时其活动位将被置位。\n\n## 异常返回值\n\n在进入异常服务程序后，将自动更新 LR的值为特殊的 EXC_RETURN。这是一个高 28位全为 1的值，只有[3:0]的值有特殊含义，如下图所示。当异常服务例程把这个值送往 PC时，就会启动处理器的中断返回序列。因为 LR的值是由内核自动设置的，所以只要没有特殊需求，就不要改动它。\n\n![image-20210717203515783](image-20210717203515783.png)\n\n![image-20210717203628501](image-20210717203628501.png)\n\n\n\n# 异常入口的堆栈对齐\n\nArmv7-M 架构保证堆栈指针值至少是 4 字节对齐的。 但是，某些软件标准要求堆栈指针按 8 字节对齐，并且体系结构可以强制执行这种对齐。 在配置和控制寄存器的 CCR. STKALIGN 位指示中作为异常入口的一部分，决定着处理器是将 SP 对齐到 4 个字节还是 8 个字节。 该位是由编译器决定是否为：\n• RW，在这种情况下，它的复位值是由编译器决定的。\n• RO，在这种情况下它是 RAO，表示 8 字节 SP 对齐。\n**Arm 不赞成实现或使用 4 字节 SP 对齐。**\n\n\n\nRegister --- CCR. STKALIGN bit：\n\n![image-20210717172228588](image-20210717172228588.png)\n\n下图显示了在异常发生时进入堆栈的信息框架，以及处理器如何在堆栈上保留一个额外的字（如果需要的话），以获得 8字节堆栈对齐。（这里就是我们要分析地方）\n\n![image-20210717172649123](image-20210717172649123.png)\n\n\n\n# HardFault异常分析处理\n\nHardFault是一种通用故障，它适用于所有不能被任何其他异常机制处理的故障类。通常，HardFault用于不可恢复的系统故障，尽管这不是必需的，而且 HardFault的某些用途可能是可恢复的。HardFault永久启用，优先级固定为 -1。\n\n\n\n## 方法一：先来个简单的，使用第三方组件 “cm_backtrace”\n\n项目地址：https://github.com/armink/CmBacktrace\n\n怎么用这里就不说了，毕竟官方已经写得很清楚了，而且还有相应的 Demo例程。\n\n使用该方法的特点是不需要过多的关注更底层的东西，只需移植好后配置相应的功能就好了，而且它可以离线（脱离仿真器）来寻找错误点；但是前提是你的串口正常，而且还需要预留部分内存供其执行。\n\n## 方法二：仿真情况下的 bug寻找\n\n如果是平常的 while循环执行，导致挂掉了无法切换任务，那么我们可以轻松通过上下文切换寻找问题；但是在 HardFault异常中它并不给你显示执行错误的所在地方，而是直接跳到 HardFault中断中，这往往让我们头大。\n\nKeil平台的可以看：\n\nhttps://www.keil.com/appnotes/files/apnt209.pdf\n\nIAR平台的可以看：\n\nhttps://www.iar.com/knowledge/support/technical-notes/debugger/debugging-a-hardfault-on-cortex-m/\n\nGCC平台的可以看：\n\n方法三。。。\n\n## 方法三：通过 ARM 寄存器逆向推导 \n\n使用该方法的前提是获取到第五个大点最后一张图展示的核心寄存器（R0-R3、R12、LR、PC、xPSR以及原 SP）的数值。\n\n**1、常见的核心寄存器数据获取**\n\n一般地，我们会使用以下代码嵌入到 HardFault中断中，使其在入口处打印服务异常时各核心寄存器的值：\n\n```c\n/* Exception frame without floating-point storage\n* hard fault handler in C,\n* with stack frame location as input parameter\n*/\nvoid\nhard_fault_handler_c(unsigned int * hardfault_args)\n{\n    unsigned int stacked_r0;\n    unsigned int stacked_r1;\n    unsigned int stacked_r2;\n    unsigned int stacked_r3;\n    unsigned int stacked_r12;\n    unsigned int stacked_lr;\n    unsigned int stacked_pc;\n    unsigned int stacked_psr;\n   \n    //Exception stack frame\n    stacked_r0 = ((unsigned long) hardfault_args[0]);\n    stacked_r1 = ((unsigned long) hardfault_args[1]);\n    stacked_r2 = ((unsigned long) hardfault_args[2]);\n    stacked_r3 = ((unsigned long) hardfault_args[3]);\n   \n    stacked_r12 = ((unsigned long) hardfault_args[4]);\n    stacked_lr = ((unsigned long) hardfault_args[5]);\n    stacked_pc = ((unsigned long) hardfault_args[6]);\n    stacked_psr = ((unsigned long) hardfault_args[7]);\n   \n    printf (\"[Hard fault handler]\\n\");\n    printf (\"R0 = %x\\n\", stacked_r0);\n    printf (\"R1 = %x\\n\", stacked_r1);\n    printf (\"R2 = %x\\n\", stacked_r2);\n    printf (\"R3 = %x\\n\", stacked_r3);\n    printf (\"R12 = %x\\n\", stacked_r12);\n    printf (\"LR = %x\\n\", stacked_lr);\n    printf (\"PC = %x\\n\", stacked_pc);\n    printf (\"PSR = %x\\n\", stacked_psr);\n#ifndef CW\n    printf (\"BFAR = %x\\n\", (*((volatile unsigned long *)(0xE000ED38))));\n    printf (\"CFSR = %x\\n\", (*((volatile unsigned long *)(0xE000ED28))));\n    printf (\"HFSR = %x\\n\", (*((volatile unsigned long *)(0xE000ED2C))));\n    printf (\"DFSR = %x\\n\", (*((volatile unsigned long *)(0xE000ED30))));\n    printf (\"AFSR = %x\\n\", (*((volatile unsigned long *)(0xE000ED3C))));\n#else\n    printf (\"BFAR = %x\\n\", (*((volatile unsigned int *)(0xE000ED38))));\n    printf (\"CFSR = %x\\n\", (*((volatile unsigned int *)(0xE000ED28))));\n    printf (\"HFSR = %x\\n\", (*((volatile unsigned int *)(0xE000ED2C))));\n    printf (\"DFSR = %x\\n\", (*((volatile unsigned int *)(0xE000ED30))));\n    printf (\"AFSR = %x\\n\", (*((volatile unsigned int *)(0xE000ED3C))));\n#endif\n    for(;;)\n    {}\n}\n\n/* The prototype shows it is a naked function - in effect this is just an\nassembly function. */\nvoid HardFault_Handler( void ) __attribute__( ( naked ) );\n\n/* The fault handler implementation calls a function called\nprvGetRegistersFromStack(). */\nvoid HardFault_Handler(void)\n{\n  #ifdef CORTEX_M3_M4_M7\n    asm volatile(\n        \" tst lr, #4                        \\n\" /* Check EXC_RETURN[2] */\n        \" ite eq                            \\n\"\n        \" mrseq r0, msp                     \\n\"\n        \" mrsne r0, psp                     \\n\"\n        \"b hard_fault_handler_c             \\n\"\n        : /* no output */\n        : /* no input */\n        : \"r0\" /* clobber */\n    );\n  #else\n    asm volatile(\n        \"movs r0, #4                        \\n\"\n        \"mov  r1, lr                        \\n\"\n        \"tst  r0, r1                        \\n\" /* Check EXC_RETURN[2] */\n        \"beq 1f                             \\n\"\n        \"mrs r0, psp                        \\n\"\n        \"ldr r1,=hard_fault_handler_c       \\n\"\n        \"bx r1                              \\n\"\n        \"1:mrs r0,msp                       \\n\"\n        \"ldr r1,=hard_fault_handler_c       \\n\"\n        : /* no output */\n        : /* no input */\n        : \"r0\" /* clobber */\n    );\n  #endif\n}\n```\n\nNote：\n\n1. 值得注意的是 void HardFault_Handler(void);函数是相应的 HardFault中断函数，不同的厂家会定义不同的名称。\n\n2. 对于不同的编译器，如：armcc、iar、gcc for arm等，需要把相应的关键字替换掉（eg：`asm`、`naked`）。\n\n   `naked` 拓展：https://www.keil.com/support/man/docs/armclang_ref/armclang_ref_jhg1476893564298.htm\n\n   https://zhuanlan.zhihu.com/p/33933891\n\n**2、逆向定位入口**\n\n如果有看过方法二的两个链接，那么就很容易理解以下的分析了：\n\n1. 确保你能正常获取输出数据（包括但不限于仿真查看、串口打印、SWO输出、SEGGER_RTT输出等等）。\n2. 由于我们在第一点修改过代码，所以可以直接查看 LR和 PC两个的值；因为这两个的值是关键。\n3. 使用 addr2line软件定位故障代码位置（使用方法：https://sourceware.org/binutils/docs-2.27/binutils/addr2line.html#addr2line）\taddr2line属于 GNU Binutils组件之一，获取可以从方法一里面的 tools文件夹里获取，也可以从 `安装路径\\GNU Tools ARM Embedded\\5.4 2016q3\\bin\\arm-none-eabi-addr2line.exe` 提取出来。\n\n**3、使用演示**\n\n先制造一个 HardFault：\n\n```c\nvoid fault_test_by_div0(void) {\n    volatile int * SCB_CCR = (volatile int *) 0xE000ED14; // SCB->CCR\n    int x, y, z;\n\n    *SCB_CCR |= (1 << 4); /* bit4: DIV_0_TRP. */\n\n    x = 10;\n    y = 0;\n    z = x / y;\n    printf(\"z:%d\\n\", z);\n}\n\n/************************************************\n函数名称 ： main\n功    能 ： 主函数入口\n参    数 ： 无\n返 回 值 ： 无\n*************************************************/\nint main( void )\n{\n#ifdef DEBUG\n    debug();\n#endif\n\n    BaseType_t xReturn = pdPASS; /* 定义一个创建信息返回值，默认为 pdPASS */\n\n    prvSetupHardware();\n\n    fault_test_by_div0();\n\n    /* Start the tasks defined within this file/specific to this demo. */\n    xReturn = xTaskCreate( (TaskFunction_t)prvUser_Task,\t\t\t/* 任务入口函数 */\n                           (const char *)\"prvUser_Task\",\t\t\t/* 任务名字 */\n                           (uint16_t)configMINIMAL_STACK_SIZE,\t\t/* 任务栈大小 */\n                           (void *)NULL,\t\t\t\t\t\t\t/* 任务入口函数参数 */\n                           (UBaseType_t)mainCREATOR_TASK_PRIORITY,\t/* 任务的优先级 */\n                           (TaskHandle_t *)UserTaskCreate_Handle );\t/* 任务控制块指针 */\n\n    if(pdPASS == xReturn) {\n        /* Start the scheduler. */\n        vTaskStartScheduler();\n    }\n\n    /* Will only get here if there was not enough heap space to create the\n    idle task. */\n    return 0;\n}\n\n/*----------------------------- End -----------------------------*/\n```\n\n接着可以观察到程序已经跑到 HardFault_Handler里并输出相应信息了：\n\n![image-20210718160907873](image-20210718160907873.png)\n\n然后利用 addr2line，执行命令 `arm-none-eabi-addr2line.exe -e \"可执行映像\" -a -f \"相应的值\"` （注：实际命令并不需要双引号 `“ ”`，应用可看下图）：\n\n- `-e` ：指定可执行映像名称\n- `-a` ：显示函数地址\n- `-f` ：显示函数名称\n\n![image-20210718160622030](image-20210718160622030.png)\n\n然后，对于不同的编译器，可执行映像并不一样（像 Keil是 `.axf`、IAR是 `.out`）；最后，如果细心的可以看到命令后面的两个值只有 PC的值是对应上，第二个值并不是 LR的值，而是其减去 4的结果；若果你直接使用 LR值，你会发现定位出来的下一条指令要执行的地方，至于为什么要减掉 4，是因为在 ARM下执行指令的大小始终为 4 个字节递增，所以可以通过减掉 4，使其指向上一条内容。\n\n![image-20210718163058462](image-20210718163058462.png)\n\n![image-20210718163412930](image-20210718163412930.png)\n\n## 方法四：透过最底层进行分析\n\n这种方法不需要修改什么，在进入 HardFault_Handler后直接分析核心寄存器。\n\n同样的，还是先制造一个 HardFault，沿用方法三的 fault_test_by_div0();函数代码，然后直到进入 HardFault_Handler后，（注意，这里的 HardFault_Handler中断函数并没有像方法三那样区嵌入代码，而是保持其原始的样子）：\n\n![image-20210718204135298](image-20210718204135298.png)\n\n接着跟上面的一样，获取各核心寄存器的值（ps：这里用的仿真查看）：\n\n![image-20210718204626787](image-20210718204626787.png)\n\n在这里就不是像方法三那样直接拿 LR和 PC这两个值来用了，必须进行层层分析：\n\n1. 查看 LR值是对应下图的哪个：\n\n   ![image-20210718205017651](image-20210718205017651.png)\n\n   通过转换，-7为 0xFFFFFFF9，然后在第四大点的第三小点有讲过 LR=0xFFFF_FFF9时是使用 MSP，而 LR=0xFFFF_FFFD时则使用 PSP；所以我们可以确定该返回值是被压入到主堆栈指针（MSP）中。\n\n2. 找到 MSP指示的值：\n\n   ![image-20210718205953987](image-20210718205953987.png)\n\n   得到该值为 0x2002ffc8。\n\n3. 查看该值所对应的内存块：\n\n   ![image-20210718210515637](image-20210718210515637.png)\n\n   得到紫色框里的两个数据（嘿嘿，是不是很神奇，居然跟方法三的 LR、PC值一样），可能你会疑惑，为什么是提取该地址往后第六、七个数（4 字节递增），而不是其他呢？这就看第五个大点了，它的入栈顺序以及地址位置都是有规律的，可以归纳为下图：\n\n   ![image-20210718211434499](image-20210718211434499.png)\n\n   按箭头方向，顺数第六、七是不是就是 LR、PC值啊，而这里就是旧的内容信息；所以跟方法三比较一下，其实方法三的那段嵌入代码，就是让其改变各个核心寄存器的信息内容，使其不要存储跳转到 HardFault_Handler，而是存储跳转前的数据信息。\n\n4. 到了这步，就是使用 addr2line来定位，这里就不说了，方法三里面有写。\n\n\n\n# 参考：\n\n[ARM架构](https://zh.wikipedia.org/wiki/ARM%E6%9E%B6%E6%A7%8B)\n\n[ARM Cortex-M](https://zh.wikipedia.org/wiki/ARM_Cortex-M)\n\n[Arm® Cortex®-M4 in a nutshell](https://www.st.com/content/st_com/zh/arm-32-bit-microcontrollers/arm-cortex-m4.html)\n\n<<ARM Cortex-M3 权威指南>>\n\n[ARMv7-M Architecture Reference Manual](https://developer.arm.com/documentation/ddi0403/ee/?lang=en)\n\n[Overview of the ARM Architecture](https://www.keil.com/support/man/docs/armasm/armasm_dom1359731124840.htm)\n\n[error: Hard Fault Handler](https://community.arm.com/developer/ip-products/system/f/embedded-forum/4749/error-hard-fault-handler)\n\n[How to debug a HardFault on an ARM Cortex-M MCU](https://interrupt.memfault.com/blog/cortex-m-fault-debug)\n\n[Debugging a ARM Cortex-M Hard Fault](https://forums.freertos.org/t/debugging-a-arm-cortex-m-hard-fault/9873)\n\n[Analyzing HardFaults on Cortex-M CPU](https://www.segger.com/downloads/application-notes/AN00016)\n\n[ARM Cortex M3: Recovering from a Hard Fault](https://gist.github.com/hossboss/e1d0e51fdb99bc125aadac64f5d67f04)\n\n[Debug a HardFault](https://www.silabs.com/community/mcu/32-bit/knowledge-base.entry.html/2014/05/26/debug_a_hardfault-78gc)","tags":["MCU","history"]},{"title":"常用校验算法","url":"/docs/算法/常用校验算法/","content":"\n\n\n# 奇偶校验\n\n## 介绍\n\n**奇偶校验位**（英语：**parity bit**）或**校验比特**（英语：**check bit**）是一个表示给定位数的二进制数中1的个数是奇数还是偶数的二进制数。奇偶校验位是最简单的错误检测码。\n\n## 原理\n\n奇偶校验常见于串口数据收发，如其名，可分为奇校验和偶校验：\n\n- **奇校验：原始码流+校验位，其 “1” 的个数为奇数，则校验位为 “0”；若为偶数，则校验位为 “1”。**\n\n- **偶校验：原始码流+校验位，其 “1” 的个数为奇数，则校验位为 “1”；若为偶数，则校验位为 “0”。**\n\n奇校验是在每个字节后增加一个附加位，使得 “1” 的总数为奇数；而偶校验是在每个字节后增加一个附加位，使得 “1” 的总数为偶数。\n\neg：\n\n以**偶校验位**来说，如果一组给定数据位中1的个数是奇数，补一个bit为1，使得总的1的个数是偶数。例：0000001, 补一个bit为1, 0000001**1**。\n\n以**奇校验位**来说，如果给定一组数据位中1的个数是奇数，补一个bit为0，使得总的1的个数是奇数。例：0000001, 补一个bit为0, 0000001**0**。\n\n其原理是：假如采用奇校验，发送端发送的一个字符编码（含校验位）中，“1” 的个数一定为奇数个，在接收端对接收字符二进制位中的 “1” 的个数进行统计，若统计出 “1” 的个数为偶数个，则意味着传输过程中有 1位（或奇数位）发生差错。\n\n## 应用场景\n\n奇校验通常用于同步传输；偶校验常用于异步传输或低速传输。\n\n## 总结\n\n虽然这个校验应该算是校验算法中最简单的，可是它却有不足之处：\n\n如果数据传输过程只有奇数个码位变化，那么不管变化在哪我们都可以直接判断数据传输是错误的，但是一旦有偶数位发生了变化，或者出现移位情况，我们就无法检测到错误，该方法的校错率是 50%。\n\neg：\n\n奇校验 正确码流 `11000001`\n\n**错 1位** `11000011` 变成了偶数个 1，能检测出错误\n\n错 2位 `11001011` 变成了奇数个 1，检测不出错误\n\n出现移位 `11000010` 变成了奇数个 1，检测不出错误\n\n\n\n# 校验和\n\n## 介绍\n\n**校验和**（英语：Checksum）是冗余校验的一种形式。 它是通过错误检测方法，对经过空间（如通信）或时间（如计算机存储）所传送数据的完整性进行检查的一种简单方法。\n\n## 原理\n\n所谓校验和，就是将被校验数据进行 “累加”，并省略 “累加” 溢出的位，最终得到的 1个或多个字节的结果。这个 “累加”，可以是简单的整数加法校验，又或者是反码加法校验等等。\n\n一般常用的有：\n\n**A、整数加法校验和（Integer Addition Checksum）**\n\n其操作如加法运算一样，把数据值累加，最后省略高位。\n\n![image-20210506204818892](image-20210506204818892.png)\n\n在熟知其操作后，我们来看下误码率；假设传输数据以两个 bit为单位，进行传输两个两位数 `00b` 和 `00b` ，则该校验和为：00+00=00，那么在传输过程中其出现错码的数据有以下，那么来简单分析下本次校验出错的概率有多少：\n\n|         | 00b  | 01b  | 10b  | 11b  |\n| ------- | ---- | ---- | ---- | ---- |\n| **00b** | 00b  | 01b  | 10b  | 11b  |\n| **01b** | 01b  | 10b  | 11b  | 00b  |\n| **10b** | 10b  | 11b  | 00b  | 01b  |\n| **11b** | 11b  | 00b  | 01b  | 00b  |\n\n如上表所示，在传输两个两位数 `00b` 和 `00b` 时，会有其余三种组合相加校验和也是 00，所以有 3/16 的概率会校验出错的，约为 1/4；但当数据的位宽越大，校验出错概率越低。\n\n**B、反码加法校验和（One’s Complement Addition Checksum）**\n\n反码加法校验，实际就是先进行整数加法运算，然后将进位加回来。\n\n![image-20210506205712724](image-20210506205712724.png)\n\n该处理相对于上一个的整数加法校验，由于需要加上进位操作，所以校验出错概率比它低一点。\n\n## 补充\n\n由于有讲到 `One’s Complement`，所以在这里稍微说一下：one's-complement 和 two's-complement以及 one's complement sum和 two's complement sum。\n\n- **one's-complement 和 two's-complement**\n\n  前者表示：反码，高位为符号位；后者表示：补码，高位为符号位。\n\n  ![image-20210506210446251](image-20210506210446251.png)\n\n  参考：https://tutorialspoint.dev/computer-science/computer-organization-and-architecture/whats-difference-between-1s-complement-and-2s-complement\n\n- **one's complement sum和 two's complement sum**\n\n  前者表示：反码加法，需要加上进位；\n\n  ![image-20210506210955942](image-20210506210955942.png)\n\n  后者表示：补码加法，舍弃进位。\n\n  ![image-20210506210936345](image-20210506210936345.png)\n\n  参考：《Short description of the Internet checksum》\n\n\n\n# 纵向冗余校验（LRC）\n\n## 介绍\n\n纵向冗余校验（LRC）是一种从纵向通道上的特定比特串产生校验比特的错误检测方法；而最常用的是 **LRC-8**错误检验，除此之外，还有 **LRC-16**、 **LRC-32**，它们是逐字节的奇偶校验计算，通过将数据字的所有字节异或在一起，生成一个对应字节的校验数。下面以 LRC-8为说明。\n\n## 原理\n\n通过对数据拆分为单字节，并利用纵向排列，把对应的字节位异或计算，最终得到一个单字节校验数：\n\n![image-20220327112126895](image-20220327112126895.png)\n\n## 应用处理\n\n![image-20220327113147917](image-20220327113147917.png)\n\n然后，它有什么特点呢：\n\n- 可以检测垂直切片分析中所有奇数的比特错误\n- 无法检测垂直切片分析中偶数个比特的错误\n- 可以检测所有 1位错误或检测单个字节内的所有错误\n- 可以检测多个 2位错误，但并不是所有的 2位错误类型都可检测到\n\n所以，最终得到的是：在检测同一垂直切片分析中的任何 2位（bit）出现错误都是不可检测的。\n\n最后附一张到目前介绍为止的检测概率图：\n\n![image-20220327114446012](image-20220327114446012.png)\n\n\n\n# 循环冗余校验（CRC）\n\n## 介绍\n\n**循环冗余校验**（英语：**Cyclic redundancy check**，通称“**CRC**”）是一种根据网络数据包或电脑文件等数据产生简短固定位数校验码的一种散列函数，主要用来检测或校验数据传输或者保存后可能出现的错误。生成的数字在传输或者存储之前计算出来并且附加到数据后面，然后接收方进行检验确定数据是否发生变化。由于本函数易于用二进制的电脑硬件使用、容易进行数学分析并且尤其善于检测传输通道干扰引起的错误，因此获得广泛应用。\n\n## CRC多项式\n\n多项式的选择是 CRC算法实现中最重要的部分，所选择的多项式必须有最大的错误检测能力，同时保证总体的碰撞概率最小。多项式最重要的属性是它的长度，也就是最高非零系数的数值，因为它直接影响着计算的校验和的长度。\n\n最常用的多项式长度有\n\n- 9位（CRC-8）\n- 17位（CRC-16）\n- 33位（CRC-32）\n- 65位（CRC-64）\n\n在构建一个新的 CRC多项式或者改进现有的 CRC时，一个通用的数学原则是使用满足所有模运算不可分解多项式约束条件的多项式。\n\n- 这种情况下的不可分解是指多项式除了 1与它自身之外不能被任何其它的多项式整除。\n\n生成多项式的特性可以从算法的定义中推导出来：\n\n- 如果 CRC有多于一个的非零系数，那么 CRC能够检查出输入消息中的所有单数据位错误。\n- CRC可以用于检测短于 2k的输入消息中的所有双位错误，其中k是多项式的最长的不可分解部分的长度。\n- 如果多项式可以被 x+1整除，那么不存在可以被它整除的有奇数个非零系数的多项式。因此，它可以用来检测输入消息中的奇数个错误，就像奇偶校验函数那样。\n\n## 多项式与二进制数码\n\n假设一个多项式为 `G(x)=x^4+x^3+x+1`， 可转换为二进制数码 `11011b`。\n\n等式 `G(X)=x^4+x^3+x+1`，可以写成 `G(X) = 1*(X^4) + 1*(X^3) + 0*(X^2) + 1*(X^1) + 1*(X^0)`\n\n总结：有幂次就为 1，没有幂次就为 0，首尾一定要是 1， 所以 `G(x)=x^4+x^3+x+1`为 `11011b`。\n\n## CRC校验核心\n\n从上面可以看出，CRC校验中有两个关键点：\n\n- 一是要预先确定一个发送端和接收端都用来作为除数的二进制比特串（或多项式）；\n- 二是把原始帧与上面选定的除进行二进制除法运算，计算出 FCS。\n\n前者可以随机选择，也可按国际上通行的标准选择，但**最高位和最低位必须均为 “1”**，如在 IBM的 SDLC（同步数据链路控制）规程中使用的 CRC-16（也就是这个除数一共是17位）生成多项式 `G（x）= x^16 + x^15 + x^2 +1`（对应二进制比特串为：`11000000000000101b`）；而在 ISO HDLC（高级数据链路控制）规程、ITU的 SDLC、X.25、V.34、V.41、V.42等中使用 CCITT-16生成多项式 `G（x）= x^16 + x^15 + x^5 +1`（对应二进制比特串为：`11000000000100001b`）。\n\n## 校验原理\n\nCRC算法的是以GF(2)(2元素伽罗瓦域)多项式算术为数学基础的，原理看起来比较复杂、好难懂，但实际上它的主要特点和运算规则是很好理解的。\n\n在 CRC算法中，其运算法制使用 “模 2算术”运算。\n\n**A、模 2加减法运算**\n\n- 模 2加法运算：1+1=0，0+1=1，0+0=0，无进位，也无借位\n- 模 2减法运算：1-1=0，0-1=1，1-0=1，0-0=0，无进位，也无借位\n\n   显然，加和减是一样的效果(故在GF(2)多项式中一般不出现 \"-\" 号)，相当于二进制中的逻辑异或运算；也就是相互比较后，两者对应位相同则结果为 “0”，不同则结果为 “1”。\n\neg：\n\n多项式：`P1 = x^3 + x^2 + 1，P2 = x^3 + x^1 + 1，P1 + P2 = `\n\n```\n      x^3 + x^2       + 1\n  +   x^3       + x^1 + 1\n  ------------------------------\n            x^2 + x^1\n```\n二进制：`P1 = 1101，P2 = 1011，P1 + P2 = `\n\n```\n      1 1 0 1\n  +   1 0 1 1\n  --------------\n        1 1 0\n```\n\n**B、模 2乘法运算**\n\nGF(2)多项式乘法和一般多项式乘法基本一样，只是在各项相加的时候按模 2算术进行，同样的，无进位，也无借位。\n\neg：\n多项式：`P1 = x^3 + x^2 + 1，P2 = x^3 + x^1 + 1，P1 x P2 = `\n\n```\n  (x^3 + x^2 + 1) (x^3 + x^1 + 1)  \n  = (x^6 + x^4 + x^3\n    + x^5 + x^3 + x^2\n    + x^3 + x + 1)\n  = x^6 + x^5 + x^4 + x^3 + x^2 + x + 1\n```\n二进制：`P1 = 1101，P2 = 1011，P1 x P2 = `\n\n```\n          1 1 0 1\n x        1 0 1 1\n --------------------\n\t      1 1 0 1\n\t    1 1 0 1\n\t  0 0 0 0\n +  1 1 0 1     \n --------------------\n    1 1 1 1 1 1 1\n```\n**C、模 2除法运算**\n\n多项式：`P1 = x^5 + x^2 + 1，P2 = x^3 + x^2 + x^1，P1 / P2 = `\n\n```\n                                      x^2   x^1\n                   ----------------------------------\n x^3 + x^2 + x^1  ) x^5             + x^2       + 1\n                    x^5 + x^4 + x^3\n                   ----------------------------------\n                          x^4 + x^3 + x^2\n                          x^4 + x^3 + x^2\n                   ----------------------------------\n                                                  1                          \n```\n二进制：`P1 = 100101，P2 = 1110，P1 x P2 = `\n\n```\n                          1 1\n                   ---------------\n          1 1 1 0 ) 1 0 0 1 0 1\n                    1 1 1 0\n                   ---------------\n                      1 1 1 0\n                      1 1 1 0\n                   ---------------\n                              1         \n```\n\n\n 具体来说，CRC校验原理就是以下几个步骤：\n\n   （1）先选择（可以随机选择，也可按标准选择，具体在后面介绍）一个用于在接收端进行校验时，对接收的帧进行除法运算的除数（是二进制比较特串，通常是以多项方式表示，所以 CRC又称多项式编码方法，这个多项式也称之为“生成多项式”）。\n\n   （2）看所选定的除数二进制位数（假设为k位），然后在要发送的数据帧（假设为m位）后面加上 k-1位 “0”，然后以这个加了 k-1个 “0“的新帧（一共是 m+k-1位）以 “模 2除法”方式除以上面这个除数，所得到的余数（也是二进制的比特串）就是该帧的 CRC校验码，也称之为 FCS（帧校验序列）。但要注意的是，余数的位数一定要是比除数位数只能少一位，哪怕前面位是 0，甚至是全为 0（附带好整除时）也都不能省略。\n\n   （3）再把这个校验码附加在原数据帧（就是 m位的帧，注意不是在后面形成的 m+k-1位的帧）后面，构建一个新帧发送到接收端，最后在接收端再把这个新帧以 “模 2除法” 方式除以前面选择的除数，如果没有余数，则表明该帧在传输过程中没出错，否则出现了差错。\n\n![image-20210523204223295](image-20210523204223295.png)\n\n## 计算步骤\n\n假设以最常用的 CRC-16_MODBUS为例：\n\n（1）、预置 1个16位的寄存器值 0xFFFF，称此寄存器为CRC寄存器；\n\n（2）、把第一个 8位二进制数据（既通讯信息帧的第一个字节）与 16位的 CRC寄存器的低 8位相异或，把结果放于 CRC寄存器，高八位数据不变；\n\n（3）、把 CRC寄存器的内容右移一位（朝高位）用 0填补最高位，并检查右移后的移出位；\n\n（4）、如果移出位为 0则重复第 3步（再次右移一位）；如果移出位为1，那么将 CRC寄存器与一多项式（A001）进行异或；\n\n（5）、重复步骤 3和 4，直到右移 8次，这样整个 8位数据全部进行了处理；\n\n（6）、重复步骤 2到步骤 5，进行通讯信息帧下一个字节的处理；\n\n（7）、将该通讯信息帧所有字节按上述步骤计算完成后，得到的 16位CRC寄存器的高、低字节进行交换；\n\n（8）、最后得到的 CRC寄存器内容即为：CRC码。\n\n以上计算步骤中的多项式 A001是 8005按位颠倒后的结果。\n\n## CRC-16实现代码\n\n常用 CRC-16码表：\n\n| Algorithm         | Poly   | Init   | RefIn | RefOut | XorOut |\n| ----------------- | ------ | ------ | ----- | ------ | ------ |\n| CRC16_CCITT       | 0x1021 | 0x0000 | true  | true   | 0x0000 |\n| CRC16_CCITT_FALSE | 0x1021 | 0xFFFF | false | false  | 0x0000 |\n| CRC16_XMODEM      | 0x1021 | 0x0000 | false | false  | 0x0000 |\n| CRC16_X25         | 0x1021 | 0xFFFF | true  | true   | 0xFFFF |\n| CRC16_MODBUS      | 0x8005 | 0xFFFF | true  | true   | 0x0000 |\n| CRC16_IBM         | 0x8005 | 0x0000 | true  | true   | 0x0000 |\n| CRC16_MAXIM       | 0x8005 | 0x0000 | true  | true   | 0xFFFF |\n| CRC16_USB         | 0x8005 | 0xFFFF | true  | true   | 0xFFFF |\n\n这里只演示常用的 CRC-16的部分程序：\n\n![image-20210506233502474](image-20210506233502474.png)\n\n","tags":["history","算法"],"categories":["算法"]},{"title":"cJSON库 API解析（下）","url":"/docs/cJSON/cJSON库 API解析（下）/","content":"\n\n\n> 继上一篇 [cJSON库 API解析（上）]()，本篇为下篇，以解析 JSON数据包为主\n\n\n\n# JSON数据解析\n\n在 cJSON里，解析 JSON数据包，其实就是通过搜寻对应的配对关键符号或者关键字，然后一个一个剥离成为链表节点(键值对)的过程。\n\n其所支持的解析函数有以下几个：\n\n- `CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value);`\n\n- `CJSON_PUBLIC(cJSON *) cJSON_ParseWithLength(const char *value, size_t buffer_length);`\n\n- `CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated);`\n\n- `CJSON_PUBLIC(cJSON *) cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated);`\n\n但一般来说，平常我们只需要用到 cJSON_Parse();函数来解析。同样的，在调用了 parse函数后，使用完毕需要调用 cJSON_Delete();及时释放；\n\n整个解析过程，其核心操作函数为：\n\n```c\n/* Parser core - when encountering text, process appropriately. */\nstatic cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)\n{\n    if ((input_buffer == NULL) || (input_buffer->content == NULL))\n    {\n        return false; /* no input */\n    }\n\n    /* parse the different types of values */\n    /* null */\n    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), \"null\", 4) == 0))\n    {\n        item->type = cJSON_NULL;\n        input_buffer->offset += 4;\n        return true;\n    }\n    /* false */\n    if (can_read(input_buffer, 5) && (strncmp((const char*)buffer_at_offset(input_buffer), \"false\", 5) == 0))\n    {\n        item->type = cJSON_False;\n        input_buffer->offset += 5;\n        return true;\n    }\n    /* true */\n    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), \"true\", 4) == 0))\n    {\n        item->type = cJSON_True;\n        item->valueint = 1;\n        input_buffer->offset += 4;\n        return true;\n    }\n    /* string */\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '\\\"'))\n    {\n        return parse_string(item, input_buffer);\n    }\n    /* number */\n    if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9'))))\n    {\n        return parse_number(item, input_buffer);\n    }\n    /* array */\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '['))\n    {\n        return parse_array(item, input_buffer);\n    }\n    /* object */\n    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '{'))\n    {\n        return parse_object(item, input_buffer);\n    }\n\n    return false;\n}\n```\n\n就像前面说的，通过搜寻对应的配对关键符号或者关键字去调用不同的处理函数，然后配对校验，并把相应的数据插入到根结点，形成一个个相连的子节点链表。\n\n\n\n# JSON数据获取\n\n当调用完上面的解析函数后，返回的是根结点指针，通过这个 cJSON的结构指针，我们就可以利用其解析后每个节点所对应的类型，快速寻找同类型的数据，再根据提供的键（名称）来获取数据。\n\n下面就来认识一下常用的 API函数：\n\n**1、类型校验：**\n\n- False：`CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item);`\n\n- True：`CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item);`\n\n- 布尔值：`CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item);`\n\n- null：`CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item);`\n\n- 数值：`CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item);`\n\n- 字符串：`CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item);`\n\n- 数组：`CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item);`\n\n- 对象：`CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item);`\n\n不难发现，这些函数都是用于判断参数的类型的，因此返回值只有 true（真）和 false（假）；用的比较多的是 cJSON_IsFalse();和 cJSON_IsTrue();，直接判断 JSON数据包里的布尔变量。\n\n**2、信息提取：**\n\n- 数组：`CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index);`\n\n- 对象：`CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string);`\n\n- 对象（名称区分大小写）：`CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string);`\n\n**3、校验类型并返回值：**\n\n- 字符串：`CJSON_PUBLIC(char *) cJSON_GetStringValue(const cJSON * const item);`\n\n- 数值：`CJSON_PUBLIC(double) cJSON_GetNumberValue(const cJSON * const item);`\n\n**4、获取项目数：**\n\n- `CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array);`\n\n**5、错误分析：**\n\n- `CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void);`\n\n\n\n# 示例\n\n以上篇打印的封装的数据信息为例；\n\n原封装的 JSON数据包：\n\n```json\n{\n  \"name\": \"cJSON\",\n  \"version\": \"v1.7.14\",\n  \"file\": {\n    \"name\": \"cJSON.c\",\n    \"size\": 75.8,\n    \"unit\": \"KB\"\n  },\n  \"released\": [\n    2020,\n    \"Sep\",\n    3\n  ],\n  \"latest\": true\n}\n```\n\n随后解析打印出来的信息：\n\n```tex\nname:cJSON\nversion:v1.7.14\n\nfile:cJSON.c\nsize:75.800000\nunit:KB\n\nreleased date:2020 Sep 3\n\nIs it necessary to update?\nnot update\n```\n\n代码执行（沿用上篇的封装代码）：\n\n```c\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include \"cJSON.h\"\n\n\nint main(int argc, char *argv[])\n{\n    cJSON *jtest = NULL;\n    cJSON *jfile = NULL;\n    cJSON *jissue = NULL;\n    cJSON *jyear = NULL;\n    cJSON *jmonth = NULL;\n    cJSON *jday = NULL;\n    char *str = NULL;\n\n    /* 创建一个 JSON格式的主对象(主链表头结点) */\n    jtest = cJSON_CreateObject();\n\n    /* 追加字符串类型的 JSON数据到主对象中(添加一个链表节点) */\n    cJSON_AddStringToObject(jtest, \"name\", \"cJSON\");\n    cJSON_AddStringToObject(jtest, \"version\", \"v1.7.14\");\n\n    /* 追加一个对象到主对象中(添加一个链表节点) */\n    jfile = cJSON_AddObjectToObject(jtest, \"file\");\n    /* 往追加的对象添加对应的值 */\n    cJSON_AddStringToObject(jfile, \"name\", \"cJSON.c\");\n    cJSON_AddNumberToObject(jfile, \"size\", 75.8);\n    cJSON_AddStringToObject(jfile, \"unit\", \"KB\");\n\n    /* 创建一个 JSON格式的数组(另一个链表头结点) */\n    jissue = cJSON_CreateArray();\n    /* 创建相应的值并把这些值添加到数组里 */\n    jyear = cJSON_CreateNumber(2020);\n    cJSON_AddItemToArray(jissue, jyear);\n    jmonth = cJSON_CreateString(\"Sep\");\n    cJSON_AddItemToArray(jissue, jmonth);\n    jday = cJSON_CreateNumber(3);\n    cJSON_AddItemToArray(jissue, jday);\n    /* 把已经填好的数据的数组插入到主对象中 */\n    cJSON_AddItemToObject(jtest, \"released\", jissue);\n\n    /* 追加一个值为 True的布尔类型的 JSON数据到主对象中(添加一个链表节点) */\n    cJSON_AddTrueToObject(jtest, \"latest\");\n\n    /* 打印 JSON对象(整条链表)的所有数据 */\n    str = cJSON_Print(jtest);\n    printf(\"%s\\n\\n\", str);\n    \n    /* 释放整条链表的内存数据 */\n    cJSON_Delete(jtest);\n\n/* ------------------------- 以上为上篇的封装代码 ------------------------- */\n\n\n/* ------------------------- 数据保留并初始化变量 ------------------------- */    \n    jtest = NULL;\n    jfile = NULL;\n    jissue = NULL;\n    jyear = NULL;\n    jmonth = NULL;\n    jday = NULL;\n    cJSON *jtemp = NULL;\n    \n/* ------------------------- 以下为本篇的解析代码 ------------------------- */\n\n    /* 解析整段 JSON数据 */\n    jtest = cJSON_Parse(str);\n    if (jtest == NULL)\n    {\n        printf(\"parse fail.\\n\");\n        return -1;\n    }\n\n    /* 依次根据名称提取 JSON数据（键值对） */\n    jtemp = cJSON_GetObjectItem(jtest, \"name\");\n    printf(\"name:%s\\n\", jtemp->valuestring);\n    jtemp = cJSON_GetObjectItem(jtest, \"version\");\n    printf(\"version:%s\\n\\n\", jtemp->valuestring);\n\n    /* 解析嵌套的 JSON对象 */\n    jfile = cJSON_GetObjectItem(jtest, \"file\");\n    jtemp = cJSON_GetObjectItem(jfile, \"name\");\n    printf(\"file:%s\\n\", jtemp->valuestring);\n    jtemp = cJSON_GetObjectItem(jfile, \"size\");\n    printf(\"size:%f\\n\", jtemp->valuedouble);\n    jtemp = cJSON_GetObjectItem(jfile, \"unit\");\n    printf(\"unit:%s\\n\\n\", jtemp->valuestring);\n\n    /* 解析嵌套的 JSON数组 */\n    jissue = cJSON_GetObjectItem(jtest, \"released\");\n    jyear = cJSON_GetArrayItem(jissue, 0);\n    jmonth = cJSON_GetArrayItem(jissue, 1);\n    jday = cJSON_GetArrayItem(jissue, 2);\n    printf(\"released date:%d \", jyear->valueint);\n    printf(\"%s \", jmonth->valuestring);\n    printf(\"%d\\n\\n\", jday->valueint);\n\n    /* 解析布尔型数据 */\n    printf(\"Is it necessary to update?\\n\");\n    jtemp = cJSON_GetObjectItem(jtest, \"latest\");\n    cJSON_IsTrue(jtemp) ? printf(\"not update\") : printf(\"update\");\n    /* 等同于 cJSON_IsFalse(jtemp) ? printf(\"update\") : printf(\"not update\"); */\n    printf(\"\\n\\r\");\n\n    cJSON_Delete(jtest);\n    \n    cJSON_free(str);\n\n    return 0;\n}\n```\n\n实例：\n\n![image-20210131224342050](image-20210131224342050.png)\n\n\n\n#  内存管理\n\n**1、cJSON_Delete();函数**\n\n```c\n/* Delete a cJSON structure. */\nCJSON_PUBLIC(void) cJSON_Delete(cJSON *item)\n{\n    cJSON *next = NULL;\n    while (item != NULL)\n    {\n        next = item->next;\n        if (!(item->type & cJSON_IsReference) && (item->child != NULL))\n        {\n            cJSON_Delete(item->child);\n        }\n        if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))\n        {\n            global_hooks.deallocate(item->valuestring);\n        }\n        if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))\n        {\n            global_hooks.deallocate(item->string);\n        }\n        global_hooks.deallocate(item);\n        item = next;\n    }\n}\n```\n\n通过上面的代码可以了解到，当调用 cJSON_Delete();函数后，会通过 while循环一直从当前节点删除释放其后面的节点，直至到尾部结点 null节点为止；因此，在应用中，一般都是传入主链表的头结点来释放整个 JSON数据包。\n\n**2、cJSON_Hooks里的钩子函数**\n\n在 cJSON项目里面，是留有 cJSON_InitHooks();外部引用内存管理函数的 API接口的，其原型：\n\n`CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks);`\n\n通过结构体 struct cJSON_Hooks跟内部调用的内存分配挂钩，其 Hooks原型：\n\n```c\ntypedef struct cJSON_Hooks\n{\n      /* malloc/free are CDECL on Windows regardless of the default calling convention of the compiler, so ensure the hooks allow passing those functions directly. */\n      void *(CJSON_CDECL *malloc_fn)(size_t sz);\n      void (CJSON_CDECL *free_fn)(void *ptr);\n} cJSON_Hooks;\n```\n\n一般情况是默认不调用 cJSON_InitHooks();函数的，因此，其内存分配管理处于默认状态，使用的是以下标准内存分配函数：\n\n```c\n#if defined(_MSC_VER)\n/* work around MSVC error C2322: '...' address of dllimport '...' is not static */\nstatic void * CJSON_CDECL internal_malloc(size_t size)\n{\n    return malloc(size);\n}\nstatic void CJSON_CDECL internal_free(void *pointer)\n{\n    free(pointer);\n}\nstatic void * CJSON_CDECL internal_realloc(void *pointer, size_t size)\n{\n    return realloc(pointer, size);\n}\n#else\n#define internal_malloc malloc\n#define internal_free free\n#define internal_realloc realloc\n#endif\n```\n\n如此一来，假设我们在系统上跑了 FreeRTOS（或者其他 RTOS），那么，在默认情况下，如果使用其标准内存分配函数，这样，对于多线程来讲是不安全的，所以，可以利用该函数重新把内存分配函数定义调用；例如在 FreeRTOS中：\n\n```c\ncJSON_Hooks cJSON_mem;\n\ncJSON_mem.malloc_fn = pvPortMalloc;\ncJSON_mem.free_fn = vPortFree;\ncJSON_InitHooks(&cJSON_mem);\n```\n\n通过该钩子函数，把 cJSON内部调用的内存分配处理，更换为线程安全的 pvPortMalloc();和 vPortFree();函数。\n\n**3、cJSON_malloc();和 cJSON_free();**\n\n其原型分别为：\n\n```c\nCJSON_PUBLIC(void *) cJSON_malloc(size_t size);\nCJSON_PUBLIC(void) cJSON_free(void *object);\n```\n一般来说，cJSON_malloc();很少用，因为 cJSON的数据处理 API函数都默认会自动分配内存；而 cJSON_free();则更多的是用来 free cJSON格式化出来的数据（即调用 print类的 API接口）。\n\n","tags":["history","JSON"],"categories":["middleware"]},{"title":"cJSON库 API解析（上）","url":"/docs/cJSON/cJSON库 API解析（上）/","content":"\n\n\n> cJSON项目可以说是一个很适合学习及应用 C语言中的链表的项目，刨析它的源码，你会惊叹它设计之巧妙，其代码为之简洁；同时，在嵌入式应用场景中也经常发现它的身影。\n>\n> 本系列分为上下两篇，其中上篇以应用分析其 JSON数据封装为主。\n\n\n\n# 介绍\n\n在认识 cJSON之前，先来认识一下 JSON：\n\n**JSON**（**J**ava**S**cript **O**bject **N**otation，JavaScript对象表示法，读作/ˈdʒeɪsən/）是一种由道格拉斯·克罗克福特构想和设计、轻量级的资料交换语言，该语言以易于让人阅读的文字为基础，用来传输由属性值或者序列性的值组成的数据对象。JSON采用完全独立于语言的文本格式，但是也使用了类似于 C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使 JSON成为理想的数据交换语言。\n\n其官网：https://www.json.org/json-en.html\n\n而 cJSON，顾名思义就是一个使用 C 语言编写的 JSON 数据解析器，目前 cJSON 项目托管在 Github上，仓库地址如下：https://github.com/DaveGamble/cJSON；以前的旧版本则是存放在：https://sourceforge.net/projects/cjson/files/上面，但现已停止更新，继而转到 Github上了。\n\n\n\n# JSON语法\n\nJSON的基本数据类型：\n\n1. 对象（*object*）：若干无序的 “键值对” (key-value pairs)，其中键是数值或字符串，以花括号 `{` 开始，并以 `}` 结束。\n2. 数组 / 值的有序列表（array）：有序的零个或者多个值，使用方括号 `[ ]` 括起来。\n3. 字符串（*string*）：以双引号 `\" \"` 括起来的零个或多个 Unicode码位。支持反斜杠开始的转义字符序列。\n\n4. 数值（*number*）：不区分整数与浮点数。JavaScript用双精度浮点数 double表示所有数值。\n5. 布尔值（*boolean*）：表示为 `true` 或者 `false` 。\n6. null 类型：值写为 `null`\n\n\n\n1、JSON 对象是一个若干无序的 \"名称 /值\" 键值对的集合：\n\n- 以 \"`{`\" 开始，以 \"`}`\" 结束，允许嵌套使用；\n- 每个名称和值成对出现，名称和值之间使用 \"`:`\" 分隔；\n- 键值对之间用 \"`,`\" 分隔\n- 在这些字符前后允许存在无意义的空白符；\n\n\n\n2、JSON 数组是一个有序的零个或者多个值的序列表：\n\n- 以 \"`[`\" 开始，以 \"`]`\" 结束，允许嵌套使用；\n- 每个值可以为任意类型，可以是双引号括起来的字符串（*string*）、数值（*number*）、`true`、`false`、 `null`、对象（*object*）或者数组（*array*）；\n- 元素之间用 \"`,`\" 分隔\n- 在这些元素前后允许存在无意义的空白符；\n\n\n\n# cJSON结构\n\n在下载的 cJSON源码中，实际用到的文件只有两个（cJSON.c和 cJSON.h），因此 cJSON具有超轻便，可移植，单文件的特点。\n\n对于 cJSON文件，整个的数据结构就主要用到以下结构体：\n\n```c\n/* The cJSON structure: */\ntypedef struct cJSON\n{\n    /* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */\n    struct cJSON *next;\n    struct cJSON *prev;\n    /* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */\n    struct cJSON *child;\n\n    /* The type of the item, as above. */\n    int type;\n\n    /* The item's string, if type==cJSON_String  and type == cJSON_Raw */\n    char *valuestring;\n    /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */\n    int valueint;\n    /* The item's number, if type==cJSON_Number */\n    double valuedouble;\n\n    /* The item's name string, if this item is the child of, or is in the list of subitems of an object. */\n    char *string;\n} cJSON;\n```\n\n从上面的代码可以看出，cJSON的设计思想是 --- 链表。\n\n然后我们分析一下各部分的成员信息：\n\n- `type`：用于表示该键值对中值的类型；\n- `valuestring`：如果键值类型 (type) 是字符串，则将该指针指向键值；\n- `valueint`：如果键值类型 (type) 是整数，则将该指针指向键值；\n- `valuedouble`：如果键值类型 (type) 是浮点数，则将该指针指向键值；\n- `String`：用于表示当前键值对的名称；\n\n还有两个 cJSON格式的结构体指针：\n\n- `next`：指向下一个键值对\n- `prev`：指向上一个键值对\n\n最后一个 cJSON格式的结构体指针：\n\n- `child`：该子指针指向当前数组 /对象中的节点\n\n\n\n如果是想要分析 cJSON它的代码设计，除开那两个承接上下节点的 `next` 和 `prev` 结构体指针，那么你还要重点关注上面说到 `type` 成员，它支持以下定义：\n\n> The type can be one of the following:\n>\n> - `cJSON_Invalid` (check with `cJSON_IsInvalid`): Represents an invalid item that doesn't contain any value. You automatically have this type if you set the item to all zero bytes.\n> - `cJSON_False` (check with `cJSON_IsFalse`): Represents a `false` boolean value. You can also check for boolean values in general with `cJSON_IsBool`.\n> - `cJSON_True` (check with `cJSON_IsTrue`): Represents a `true` boolean value. You can also check for boolean values in general with `cJSON_IsBool`.\n> - `cJSON_NULL` (check with `cJSON_IsNull`): Represents a `null` value.\n> - `cJSON_Number` (check with `cJSON_IsNumber`): Represents a number value. The value is stored as a double in `valuedouble` and also in `valueint`. If the number is outside of the range of an integer, `INT_MAX` or `INT_MIN` are used for `valueint`.\n> - `cJSON_String` (check with `cJSON_IsString`): Represents a string value. It is stored in the form of a zero terminated string in `valuestring`.\n> - `cJSON_Array` (check with `cJSON_IsArray`): Represent an array value. This is implemented by pointing `child` to a linked list of `cJSON` items that represent the values in the array. The elements are linked together using `next` and `prev`, where the first element has `prev.next == NULL` and the last element `next == NULL`.\n> - `cJSON_Object` (check with `cJSON_IsObject`): Represents an object value. Objects are stored same way as an array, the only difference is that the items in the object store their keys in `string`.\n> - `cJSON_Raw` (check with `cJSON_IsRaw`): Represents any kind of JSON that is stored as a zero terminated array of characters in `valuestring`. This can be used, for example, to avoid printing the same static JSON over and over again to save performance. cJSON will never create this type when parsing. Also note that cJSON doesn't check if it is valid JSON.\n>\n> Additionally there are the following two flags:\n>\n> - `cJSON_IsReference`: Specifies that the item that `child` points to and/or `valuestring` is not owned by this item, it is only a reference. So `cJSON_Delete` and other functions will only deallocate this item, not its `child`/`valuestring`.\n> - `cJSON_StringIsConst`: This means that `string` points to a constant string. This means that `cJSON_Delete` and other functions will not try to deallocate `string`.\n\n<br/>\n\n\n\n# JSON数据封装\n\n封装一个 JSON格式的数据包，其实就是创建链表和向链表中添加节点的过程。\n\n在 cJSON源码里面是存放着很多 API接口的，但是，一般来说我们并不是全部用到，而且有些函数是辅助函数，例如：\n\n```c\ncJSON *Info;\nInfo = cJSON_CreateObject();\ncJSON_AddStringToObject(Info, \"Nationality\", \"China\");\n\n/* 等价于 */\n\ncJSON *Info, *jtext;\nInfo = cJSON_CreateObject();\njtext = cJSON_CreateString(\"China\");\ncJSON_AddItemToObject(Info, \"Nationality\", jtext);\n```\n\n然后下面就分析一些常用的 API函数：\n\n**1、创建原始框架：**\n\n- 数组（等于创建了一个空的 `[ ]`）：`CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void);`\n- 对象（等于创建了一个空的 `{ }`）：`CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void);`\n\n**2、追加类型值：**\n\n- 数组：`CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToArray(cJSON *array, cJSON *item);`\n\n- 对象：`CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item);`\n\n**3、追加对应的值到对象中：**\n\n- null：`CJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name);`\n- True：`CJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name);`\n- False：`CJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name);`\n- 布尔值（实际为 True和 False合并）：`CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean);`\n- 数值：`CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number);`\n- 字符串：`CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string);`\n- 对象：`CJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name);`\n- 数组：`CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name);`\n\n**4、创建同一类型的值到数组中：**\n\n- 整形：`CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count);`\n- 单精度：`CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count);`\n- 双精度：`CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count);`\n- 字符串：`CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char *const *strings, int count);`\n\n**5、创建对应类型的值**\n\n- null：`CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void);`\n- True：`CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void);`\n- False：`CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void);`\n- 布尔值：`CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean);`\n- 数值：`CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num);`\n- 字符串：`CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string);`\n\n\n\n# 示例\n\n```json\n{\n  \"name\": \"cJSON\",\n  \"version\": \"v1.7.14\",\n  \"file\": {\n    \"name\": \"cJSON.c\",\n    \"size\": 75.8,\n    \"unit\": \"KB\"\n  },\n  \"released\": [\n    2020,\n    \"Sep\",\n    3\n  ],\n  \"latest\": true\n}\n```\n\n以打印输出上面为例，建立以下代码：\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include \"cJSON.h\"\n\n\nint main( int argc, char *argv[] )\n{\n    cJSON *jtest = NULL;\n    cJSON *jfile = NULL;\n    cJSON *jissue = NULL;\n    cJSON *jyear = NULL;\n    cJSON *jmonth = NULL;\n    cJSON *jday = NULL;\n    char* str = NULL;\n\n    /* 创建一个 JSON格式的主对象(主链表头结点) */\n    jtest = cJSON_CreateObject();\n\n    /* 追加字符串类型的 JSON数据到主对象中(添加一个链表节点) */\n    cJSON_AddStringToObject(jtest, \"name\", \"cJSON\");\n    cJSON_AddStringToObject(jtest, \"version\", \"v1.7.14\");\n\n    /* 追加一个对象到主对象中(添加一个链表节点) */\n    jfile = cJSON_AddObjectToObject(jtest, \"file\");\n    /* 往追加的对象添加对应的值 */\n    cJSON_AddStringToObject(jfile, \"name\", \"cJSON.c\");\n    cJSON_AddNumberToObject(jfile, \"size\", 75.8);\n    cJSON_AddStringToObject(jfile, \"unit\", \"KB\");\n    \n    /* 创建一个 JSON格式的数组(另一个链表头结点) */\n    jissue = cJSON_CreateArray();\n    /* 创建相应的值并把这些值添加到数组里 */\n    jyear = cJSON_CreateNumber(2020);\n    cJSON_AddItemToArray(jissue, jyear);\n    jmonth = cJSON_CreateString(\"Sep\");\n    cJSON_AddItemToArray(jissue, jmonth);\n    jday = cJSON_CreateNumber(3);\n    cJSON_AddItemToArray(jissue, jday);\n    /* 把已经填好的数据的数组插入到主对象中 */\n    cJSON_AddItemToObject(jtest, \"released\", jissue);\n\n    /* 追加一个值为 True的布尔类型的 JSON数据到主对象中(添加一个链表节点) */\n    cJSON_AddTrueToObject(jtest, \"latest\");\n\n    /* 打印 JSON对象(整条链表)的所有数据 */\n    str = cJSON_Print(jtest);\n    printf(\"%s\\n\", str);\n\n    cJSON_free(str);\n    cJSON_Delete(jtest);\n\n    return 0;\n}\n```\n\n实例：\n\n![image-20210130174615600](image-20210130174615600.png)\n\n\n\n# 注意事项\n\n1、在调用了 create接口的数据，并且用完一个完整的 JSON格式包后，必须要使用 cJSON_Delete();释放内存，且不说不释放会造成泄露数据，在嵌入式中，内存容量可是很少的，很容易就耗完内存。\n\n2、cJSON_Delete();函数，并不是每调用一个 create接口，等用完都要一一对应释放，而是要释放主链表，简单的来说要处理的是头一个创建的数据类型，对于后期往其追加的数据，cJSON_Delete();函数会自动把插入进来的节点删除掉，这个在下篇再详细分析。\n\n3、cJSON里面的 Print接口格式化出来返回的数据，需要调用 cJSON_free();释放。cJSON的内存申请涉及到初始化钩子函数 cJSON_InitHooks();那里，这个也是下篇分析。","tags":["history","JSON"],"categories":["middleware"]},{"title":"逻辑门、锁存器和触发器","url":"/docs/逻辑门、锁存器和触发器/","content":"\n\n> 好久没写硬件的笔记了，写这篇笔记是因为在网上或者在现有的书上查阅相关知识点的时候，发现大多数东西都是一略带过、不全面，而且内容讲的有点沉闷，容易让人呼呼入睡（ps：这里绝对没有瞧不起作者的意思哈，可能风格有点不适应），所以想着以后可能也会用到，还是自己总结一篇吧。\n>\n> 本篇主要分析半导体存储电路（其中包括时序图跟真值表），但由于涉及到逻辑门电路，所以就一并放在一起总结了。嘛，原本的标题是想写 “半导体存储电路分析” 的。。。\n>\n\n\n\n# 逻辑门电路\n\n## 与、或、非\n\n- 与门\n\n  ![AND](AND.jpg)\n\n  特点：所有输入为高电平时（逻辑 1），才会有高电平（逻辑 1）输出；其中一个输入为低电平（逻辑 0）则出低电平（逻辑 0）。\n\n  **真值表：**\n\n  | **输入** | **输入** | **输出**  |\n  | :------: | :------: | :-------: |\n  |    A     |    B     | A  and  B |\n  |    0     |    0     |     0     |\n  |    0     |    1     |     0     |\n  |    1     |    0     |     0     |\n  |    1     |    1     |     1     |\n\n  ==总结：遇 0为 0。==\n\n  \n\n- 或门\n\n  ![OR](OR.jpg)\n\n  特点：其中一个输入为高电平时（逻辑 1），输出为高电平（逻辑 1）；只有当所有输入为低电平（逻辑 0）才出低电平（逻辑 0）。\n\n  **真值表：**\n\n  | **输入** | **输入** | **输出** |\n  | :------: | :------: | :------: |\n  |    A     |    B     | A  or  B |\n  |    0     |    0     |    0     |\n  |    0     |    1     |    1     |\n  |    1     |    0     |    1     |\n  |    1     |    1     |    1     |\n\n  ==总结：遇 1为 1。==\n\n  \n\n- 非门\n\n  ![NOT](NOT.jpg)\n\n  特点：输出的电平与输入的电平（逻辑）相反。\n\n  **真值表：**\n\n  | **输入** | **输出** |\n  | :------: | :------: |\n  |    A     |  not  A  |\n  |    0     |    1     |\n  |    1     |    0     |\n  \n  ==总结：状态取反。==\n\n\n\n## 异或和同或\n\n- 异或\n\n  ![XOR](XOR.jpg)\n\n  特点：输入的电平相同时，输出为低电平（逻辑 0）；若输入的电平不同，则输出高电平（逻辑 1）。\n\n  **真值表：**\n\n  | **输入** | **输入** | **输出**  |\n  | :------: | :------: | :-------: |\n  |    A     |    B     | A  xor  B |\n  |    0     |    0     |     0     |\n  |    0     |    1     |     1     |\n  |    1     |    0     |     1     |\n  |    1     |    1     |     0     |\n\n  ==总结：相同为 0，不同为 1。==\n\n  \n\n- 同或\n\n  ![XNOR](XNOR.jpg)\n\n  特点：只有当输入的电平相同时，输出才为高电平（逻辑 1）；而输入的电平不同时，输出低电平（逻辑 0）。\n\n  **真值表：**\n\n  | **输入** | **输入** |  **输出**  |\n  | :------: | :------: | :--------: |\n  |    A     |    B     | A  xnor  B |\n  |    0     |    0     |     1      |\n  |    0     |    1     |     0      |\n  |    1     |    0     |     0      |\n  |    1     |    1     |     1      |\n\n  ==总结：不同为 0，相同为 1。==\n\n\n\n## 与非和或非\n\n与非和或非，其实相当于与门和或门输出取反：\n\n![X](X.jpg)\n\n真值表这里就不放了，其实就是把与门和或门的输出状态取反。。。\n\n\n\n## 逻辑门电路实现\n\n逻辑门电路的实现，可由三极管或者 CMOS管构建而成，可以看以前的文章：[三极管---初识(图文并茂)](https://blog.csdn.net/qq_42992084/article/details/98784963)\n\n\n\n# 存储电路\n\n**基本概念：**\n\n- **存储单元**：存储一位数据的电路。可分为**静态存储单元**和**动态存储单元**两大类。静态存储单元由门电路连接而成，其中包括各种电路结构形式的**锁存器**和**触发器**，只要保持通电，静态存储单元的状态会一直保持下去。动态存储单元则是利用**电容**的电荷存储效应来存储数据的，由于电容存储的电荷会随着时间的推移逐渐泄露，必须定期地进行 “刷新”，才能保证数据不会丢失。\n- **寄存器**：存储一组数据的电路。由 N个触发器构成的寄存器可以存储一组 N位的二值数据。\n- **存储器**：存储大量数据的电路。存储器种类虽然很多，但它们的基本结构形式都是由**存储矩阵**和**读/写控制电路**两部分组成的。从存储功能上讲，可分为**随机存储器**（Random Access  Memory，简称 RAM）和**只读存储器**（Read Only Memory ，简称 ROM）两大类。随机存储器又分成**静态随机存储器**（SRAM）和**动态随机存储器**（DRAM）两类；而只读存储器又有**掩模 ROM**、**可编程 ROM**（PRAM）和**可擦除可编程 ROM**（EPRAM）几种不同类型。\n\n\n\n# 锁存器和触发器\n\n下面主要分析硬件电路中经常接触的**静态存储单元**，那么就先来了解一下**锁存器**和**触发器**之间的关系：\n\n触发器的线路图由逻辑门组合而成，其结构均由 SR锁存器派生而来（广义的触发器包括锁存器）；\n\n**触发器**除了自身的输入信号外，还带有 CLK时钟信号线，通过时钟信号的变化，使得触发器的次态仅仅取决于 CLK信号下降沿（或上升沿）到达时刻输入信号的状态，以此来增强靠干扰能力，因此，触发器也叫边沿触发器；\n\n而**锁存器**并没有 CLK时钟信号线作为辅助，只有自身的输入信号，但是，通过改进（增加一条使能信号线）可以产生新的门控锁存器，此时锁存器上多了一条使能信号线，如果在使能信号线上给予一定频率的脉冲信号，那么门控锁存器就相当于触发器了。\n\n知识补充：https://circuitglobe.com/difference-between-latch-and-flip-flop.html\n\n\n\n# 锁存器\n\n锁存器的类型有很多种：S-R、J-K、T and D latches。这里只介绍比较常用的 S-R latch and Gated D latch。\n\n## SR锁存器\n\n![R-S_mk2](R-S_mk2.gif)\n\nSR锁存器（Set-Reset Latch）是静态存储单元当中最基本、也是电路结构最简单的一种。通常它由两个**或非门**或者**与非门**组成。\n\n\n\n**Ⅰ、电路组成：**\n\n- 由**或非门**构成\n\n  ![Logic_Design_NOR_Latches](Logic_Design_NOR_Latches.jpg)\n\n- 由**与非门**构成\n\n  ![Logic_Design_NAND_Latches](Logic_Design_NAND_Latches.jpg)\n\n**Ⅱ、状态分析：**\n\n从上面的两种构成进行比较，根据它们对应的状态表可以看出，当 S、R信号为高电平（逻辑 1）【对应的，$\\overline{S}$、$\\overline{R}$信号（由于符号表示的是非的关系）就为低电平（逻辑 0）】，就相当于这两个状态表高亮部分，所以无论是由哪个逻辑门构成，其输出状态都是一样的；因此，找其中一个表对照着理解就好了，那么就来稍微分析一下吧：\n\n- [ ] 当输入的 S = 0、R = 1（$\\overline{S}$ = 1、$\\overline{R}$ = 0），输出 Q = 0和 $\\overline{Q}$ = 1（定义为 0状态）；\n\n- [ ] 当输入的 S = 1、R = 0（$\\overline{S}$ = 0、$\\overline{R}$ = 1），输出 Q = 1和 $\\overline{Q}$ = 0（定义为 1状态）；\n- [ ] 当输入的 S = R = 0（ $\\overline{S}$ = $\\overline{R}$ = 1）；输出将会保持；\n\n- [ ] 当输入的 S = 1、R = 1（$\\overline{S}$ = 0、$\\overline{R}$ = 0），输出 Q和 $\\overline{Q}$其状态是不确定的；因此，在 SR锁存器里，有一条约束条件：S · R = 0（即不应该出现 $\\overline{S}$ = $\\overline{R}$ = 0，这种情况）。\n\n**Ⅲ、时序分析：**\n\n以**与非门**构成电路为例：\n\n![SR latch](SR%20latch.png)\n\n在上图可以看到， t3 ~ t4时刻，输入端出现了 $\\overline{S}$ = $\\overline{R}$ = 0的状态，但由于 $\\overline{S}$ 首先回到了高电平，所以 SR锁存器的次态仍是可以确定的；可能你会觉得，上面不是说了无法确定状态吗？这是由于 $\\overline{S}$ = $\\overline{R}$ = 0时会出现非定义的 Q =  $\\overline{Q}$ = 1的非法状态（要知道我们只定义了 0和 1的状态），而且当 $\\overline{S}$ 和 $\\overline{R}$ 同时回到高电平以后锁存器的状态难以确定，因此一般情况下还是避免这种 $\\overline{S}$ = $\\overline{R}$ = 0的状态；同时，由于这个缺陷，**JK触发器**产生了，下面会讲。\n\n**Ⅳ、电路改进：**\n\n从上面可以得知，由**与非门**构成的 SR触发器，输入的电平（逻辑）是反向的输入（即为  $\\overline{S}$、$\\overline{R}$ ），因此，人们在电路的前端输入部分添加了转换功能，并且引入了使能控制信号，如下图：\n\n![Logic_Design_gated_SR_latch](Logic_Design_gated_SR_latch.jpg)\n\n于是乎，把上面的电路称之为：**门控 SR锁存器**\n\n\n\n门控使能信号（一般表示为 E或者 C）的作用：\n\n| E/C  |              Action              |\n| :--: | :------------------------------: |\n|  0   |      No action (keep state)      |\n|  1   | The same as non-clocked SR latch |\n\n\n\n## 门控 D锁存器\n\n在上面已经见识到了 **门控 SR锁存器**，那么稍微修改一下就会得到 **门控 D锁存器**，由于是从 SR锁存器上进行的修改，所以也存在着由**或非门**或者**与非门**所组成电路。\n\n**Ⅰ、电路组成：**\n\n- 基于 SR NAND锁存器的门控 D锁存器\n\n  ![676px-D-Type_Transparent_Latch.svg](676px-D-Type_Transparent_Latch.svg.png)\n\n- 基于 SR NOR锁存器的门控 D锁存器\n\n  ![676px-D-type_Transparent_Latch_(NOR).svg](676px-D-type_Transparent_Latch_(NOR).svg.png)\n\n对应上面两个门控 D锁存器，其真值表都是一样的：\n\n|  E   |   D   |   Q   |   $\\overline{Q}$   |  Comment  |\n| :--: | :---: | :---: | :----------------: | :-------: |\n|  0   | **X** | Qprev | $\\overline{Q}$prev | No change |\n|  1   |   0   |   0   |         1          |   Reset   |\n|  1   |   1   |   1   |         0          |    Set    |\n\n从真值表上看，可以知道，在使能信号输入为高电平（逻辑 1）时，D锁存器才起作用，否则，输出信号将保持原状态；并且，当 D锁存器起作用时，输出的信号 Q状态跟 D输入状态一致，因此，D锁存器也叫 D跟随。\n\n**Ⅱ、时序分析**\n\n![Gated D latch](Gated%20D%20latch.png)\n\n\n\n锁存器部分相关链接：https://learn.circuitverse.org/docs/Latches\n\n\n\n# 触发器\n\n触发器的类型同样也有很多种：S-R、J-K、T and D Flip flops。这里也只是分析常见的 J-K、T and D Flip flops。\n\n根据时钟信号触发的不同，可以分为两种情况（上升沿触发和下降沿触发）：\n\n![Logic_Design_SR_flip_flop_symbol](Logic_Design_SR_flip_flop_symbol.jpg)\n\n从上图可以看到，上升沿触发和下降沿触发根本区别在于时钟信号输入端是否多了个非门。\n\n## JK触发器\n\n根据边沿触发的不同，有以下两种逻辑符号：\n\n![Logic_Design_JK_flip_flop_symbol](Logic_Design_JK_flip_flop_symbol.jpg)\n\n**以上升沿为例，其电路组成如下：**\n\n![jk flip flop](jk%20flip%20flop.png)\n\n**对应的真值表：**\n\n|    触发    |   J   |   K   |   Q   | Qnext |  Comment   |\n| :--------: | :---: | :---: | :---: | :---: | :--------: |\n| $\\searrow$ | **X** | **X** | Qprev |   Q   | No change  |\n| $\\nearrow$ |   0   |   0   |   0   |   0   | Hold state |\n| $\\nearrow$ |   0   |   0   |   1   |   1   | Hold state |\n| $\\nearrow$ |   0   |   1   |   0   |   0   |   Reset    |\n| $\\nearrow$ |   0   |   1   |   1   |   0   |   Reset    |\n| $\\nearrow$ |   1   |   0   |   0   |   1   |    Set     |\n| $\\nearrow$ |   1   |   0   |   1   |   1   |    Set     |\n| $\\nearrow$ |   1   |   1   |   0   |   1   |   Toggle   |\n| $\\nearrow$ |   1   |   1   |   1   |   0   |   Toggle   |\n\n**时序分析：**\n\n![JK Flip-Flop](JK%20Flip-Flop.png)\n\n**特征方程式：**\n\n![JK](JK.png)\n\n\n\n## T触发器\n\n根据边沿触发的不同，有以下两种逻辑符号：\n\n![Logic_Design_T_flip_flop_symbol](Logic_Design_T_flip_flop_symbol.jpg)\n\n**以上升沿为例，其电路组成如下：**\n\n![T flip flop](T%20flip%20flop.png)\n\n**对应的真值表：**\n\n|    触发    |   T   |   Q   | Qnext |  Comment   |\n| :--------: | :---: | :---: | :---: | :--------: |\n| $\\searrow$ | **X** | Qprev |   Q   | No change  |\n| $\\nearrow$ |   0   |   0   |   0   | Hold state |\n| $\\nearrow$ |   0   |   1   |   1   | Hold state |\n| $\\nearrow$ |   1   |   0   |   1   |   Toggle   |\n| $\\nearrow$ |   1   |   1   |   0   |   Toggle   |\n\n**时序分析：**\n\n![T Filp-Flop](T%20Filp-Flop.png)\n\n**特征方程式：**\n\n![T](T.png)\n\n\n\n## D触发器\n\n根据边沿触发的不同，有以下两种逻辑符号：\n\n![Logic_Design_D_flip_flop_symbols](Logic_Design_D_flip_flop_symbols.jpg)\n\n**以上升沿为例，其电路组成如下：**\n\n![D flip flop](D%20flip%20flop.png)\n\n**对应的真值表：**\n\n|    触发    |   D   |   Q   | Qnext |  Comment  |\n| :--------: | :---: | :---: | :---: | :-------: |\n| $\\searrow$ | **X** | Qprev |   Q   | No change |\n| $\\nearrow$ |   0   |   0   |   0   |   Reset   |\n| $\\nearrow$ |   0   |   1   |   0   |   Reset   |\n| $\\nearrow$ |   1   |   0   |   1   |    Set    |\n| $\\nearrow$ |   1   |   1   |   1   |    Set    |\n\n**时序分析：**\n\n![D Filp-Flop](D%20Filp-Flop.png)\n\n**特征方程式：**\n\n![D](D.png)\n\n\n\n触发器部分相关链接：https://learn.circuitverse.org/docs/flipflop\n\n\n\n# 相关资料\n\nhttps://en.wikipedia.org/wiki/Flip-flop_(electronics)\n\nhttps://www.youtube.com/watch?v=-aQH0ybMd3U&list=RDCMUCSX3MR0gnKDxyXAyljWzm0Q&start_radio=1\n\nhttp://yhhuang1966.blogspot.com/2019/06/latch-flip-flop.html\n\nhttps://www.electronics-tutorials.ws/sequential/seq_1.html\n\n","tags":["history","电子电路"]}]