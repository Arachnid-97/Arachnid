{
    "version": "https://jsonfeed.org/version/1",
    "title": "命运转轮 • All posts by \"gcc\" tag",
    "description": "不曾亏欠, 不曾辜负, 如此足矣",
    "home_page_url": "https://arachnid.cc",
    "items": [
        {
            "id": "https://arachnid.cc/gcc-compiler-summary/",
            "url": "https://arachnid.cc/gcc-compiler-summary/",
            "title": "GCC 应用总结",
            "date_published": "2024-07-07T12:45:26.000Z",
            "content_html": "<h1 id=\"关键字\"><a class=\"anchor\" href=\"#关键字\">#</a> 关键字</h1>\n<h2 id=\"weak-关键字\"><a class=\"anchor\" href=\"#weak-关键字\">#</a> weak 关键字</h2>\n<p>一般用法： <code>__attribute__((weak))</code>  ，用于定义或声明对应的函数是一个 weak 属性。</p>\n<p>在 Linux 开发环境中，有强符号和弱符号，符号简单来说就是函数、变量的名字，对于全局（非局部、非 <code>static</code> ）的函数和变量，能不能重名是有一定规矩的，强、弱符号就是针对这些全局函数和变量来说的。</p>\n<table>\n<thead>\n<tr>\n<th>符号类型</th>\n<th>对象</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>强</td>\n<td>函数名，赋初值的全局变量</td>\n</tr>\n<tr>\n<td>弱</td>\n<td>未初始化的全局变量</td>\n</tr>\n</tbody>\n</table>\n<p>当代码中同时存在多个强或弱的全局变量时，要遵守如下规则：</p>\n<ul>\n<li>强符号只能定义一次，否则编译错误；</li>\n<li>强弱符号同时存在，以强符号为准；</li>\n<li>没有强符号，则从多个弱符号中任选一个，用  <code>–fno-common</code>  编译选项可以在这种情况下输出 warning 提示。</li>\n</ul>\n<h2 id=\"constructor-和-destructor-关键字\"><a class=\"anchor\" href=\"#constructor-和-destructor-关键字\">#</a> constructor 和 destructor 关键字</h2>\n<p><code>__attribute__((constructor))</code>  与  <code>__attribute__((destructor))</code>  的用法。</p>\n<p><code>__attribute__((constructor))</code>  与  <code>__attribute__((destructor))</code>  是 GCC 中用来修饰函数的，constructor 可以使被修饰的函数在 main () 执行前被调用，destructor 可以使被修饰的函数在 main () 执行结束或 exit () 调用结束后被执行。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">__attribute__</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>constructor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">void</span> <span class=\"token function\">constructor_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// ...</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre> </pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">__attribute__</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>destructor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">void</span> <span class=\"token function\">destructor_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// ...</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>一个程序中可以存在多个 constructor 和 destructor，使用优先级区分执行顺序，数字越小表示优先级越高（100 以内的优先级为保留数字不能设置）。constructor 中优先级越高越靠前执行，destructor 中优先级越高越靠后执行。不加优先级参数相当于最低优先级。</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">__attribute__</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>priority<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">void</span> <span class=\"token function\">constructor_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token comment\">// ...</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre> </pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token keyword\">__attribute__</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token function\">destructor</span><span class=\"token punctuation\">(</span>priority<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">void</span> <span class=\"token function\">destructor_func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token comment\">// ...</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h2 id=\"unused-关键字\"><a class=\"anchor\" href=\"#unused-关键字\">#</a> unused 关键字</h2>\n<p><code>__attribute__((used))</code> ，表示对于这个函数可能不会调用它、可能用不到它，编译器不用进行 warning 提示。<br />\n而在嵌入式中 中断函数都是由内部的中断处理机制通过中断向量做跳转调用的，不是开发人员 “显式” 去调用的，因此在一些规则检查比较严格的编译器上编译时，就会出现类似于上面的警告，为了视野干净我们就添加这个属性。</p>\n<h1 id=\"option\"><a class=\"anchor\" href=\"#option\">#</a> option</h1>\n<h2 id=\"nanospecs-选项\"><a class=\"anchor\" href=\"#nanospecs-选项\">#</a> nano.specs 选项</h2>\n<p><code>nano.specs</code>  是一个特殊的 specs 文件，它是为了在资源受限的环境中使用而优化的，比如在嵌入式系统或微控制器中。当你使用  <code>--specs=nano.specs</code>  选项时，编译器会使用 “nano” 版本的 C 库，而这个版本的库被设计为比标准的 GNU C 库 (glibc) 更小，占用更少的 ROM 和 RAM。</p>\n<p><strong>主要特点</strong>:</p>\n<ul>\n<li><strong>体积小</strong>：nano 版本的库被优化以减小体积，适合那些对存储空间有严格限制的系统。</li>\n<li><strong>资源使用低</strong>：这些库在设计时考虑到了内存使用，以尽可能减少动态内存分配。</li>\n<li><strong>功能减少</strong>：为了减小体积，某些不常用的功能可能被移除或替换为更简单的实现。</li>\n</ul>\n<p>在  <code>Makefile</code>  上加上 option ：</p>\n<figure class=\"highlight makefile\"><figcaption data-lang=\"makefile\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>CLIBS <span class=\"token operator\">=</span> -specs<span class=\"token operator\">=</span>nano.specs</pre></td></tr></table></figure><h2 id=\"-wrap-选项\"><a class=\"anchor\" href=\"#-wrap-选项\">#</a> -wrap 选项</h2>\n<p><code>-wrap</code>  选项可以使 GCC 在编译链接的时候，转而调用  <code>__wrap_symbol</code>  的定义，另外还有一个相关函数  <code>__real_symbol</code> ，对于只声明不定义的 symbol，会对其调用到真正的 symbol 符号。</p>\n<p>以下是 GCC linker option  <code>–wrap</code>  的描述：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Use a wrapper function for symbol. Any undefined reference to symbol will be resolved to</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>__wrap_symbol. Any undefined reference to __real_symbol will be resolved to symbol. This </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>can be used to provide a wrapper for a system function. The wrapper function should be </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>called __wrap_symbol. If it wishes to call the system function, it should call __real_symbol.</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>Here is a trivial example:</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>void *</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>__wrap_malloc (int c)</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>&#123;</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    printf (\"malloc called with %ld\\n\", c);</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    return __real_malloc (c);</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>&#125;</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>If you link other code with this file using --wrap malloc, then all calls to malloc will</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>call the function __wrap_malloc instead. The call to __real_malloc in __wrap_malloc will</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>call the real malloc function. You may wish to provide a __real_malloc function as well, </pre></td></tr><tr><td data-num=\"15\"></td><td><pre>so that links without the --wrap option will succeed. If you do this, you should not put </pre></td></tr><tr><td data-num=\"16\"></td><td><pre>the definition of __real_malloc in the same file as __wrap_malloc; if you do, the assembler </pre></td></tr><tr><td data-num=\"17\"></td><td><pre>may resolve the call before the linker has a chance to wrap it to malloc.</pre></td></tr></table></figure><p>像一般对 malloc、free、printf 进行调换：</p>\n<p>在  <code>Makefile</code>  上加上 option ：</p>\n<figure class=\"highlight makefile\"><figcaption data-lang=\"makefile\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>WRAP <span class=\"token operator\">=</span> -Wl,-wrap,malloc -Wl,-wrap,free</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>WRAP <span class=\"token operator\">+=</span> -Wl,-wrap,printf</pre></td></tr></table></figure><p>在函数里：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">__attribute__</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>weak<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span><span class=\"token function\">__wrap_malloc</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">size_t</span> sz<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"__wrap_malloc: size = %d\\n\"</span><span class=\"token punctuation\">,</span> sz<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token function\">pvPortMalloc</span><span class=\"token punctuation\">(</span>sz<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">__attribute__</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>weak<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">void</span> <span class=\"token function\">__wrap_free</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"__wrap_free: addr = %p\\n\"</span><span class=\"token punctuation\">,</span> ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token function\">vPortFree</span><span class=\"token punctuation\">(</span>ptr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">__real_printf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>format<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">__wrap_printf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>format<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token function\">__real_printf</span><span class=\"token punctuation\">(</span>format<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>上面实现了对  <code>malloc</code>  的引用转换成调用  <code>__wrap_malloc</code>  函数了，同样的  <code>__wrap_free</code>  和  <code>__wrap_printf</code>  也一样；但是有区别的是， <code>__wrap_printf</code>  里面调用了  <code>__real_printf</code> ，因此，可以理解对  <code>printf</code>  的引用其实是不变的；而由于  <code>__wrap_malloc</code>  和  <code>__wrap_free</code>  分别实现打印和调用  <code>pvPortMalloc</code>  及  <code>vPortFree</code>  新的接口，所以在对  <code>malloc</code>  和  <code>free</code>  引用的时候，是有打印输出并转而执行新的函数接口。</p>\n<p><strong>note：</strong></p>\n<p>在针对所有 “undefined reference to symbol” 中引用 symbol 的源文件里面不能有 symbol 的定义，否则汇编器在处理源文件的时候就会解析这个 symbol，链接器也就没有机会 wrap 这个 symbol 了；嘛简单点说就是需要 wrap 的函数不要跟原函数同时定义在一个源文件。</p>\n<h2 id=\"-wunused-选项\"><a class=\"anchor\" href=\"#-wunused-选项\">#</a> -Wunused 选项</h2>\n<p>在 GCC 中，如果你想要检查程序中未使用的变量，函数或标签，可以使用以下编译参数：</p>\n<p><code>-Wunused-variable</code>  ：此选项会让 GCC 发出警告，如果你的代码中定义了一个变量，但从未使用过它。</p>\n<p><code>-Wunused-function</code>  ：此选项会让 GCC 发出警告，如果你的代码中定义了一个静态函数，但从未使用过它。</p>\n<p><code>-Wunused-label</code> ：此选项会让 GCC 发出警告，如果你的代码中定义了一个标签，但从未使用过它。</p>\n<p>你也可以使用  <code>-Wunused</code>  参数来启用所有未使用相关的警告，这相当于  <code>-Wunused-variable -Wunused-function -Wunused-label</code>  。</p>\n<p><strong>note：</strong></p>\n<p>如果说  <code>unused</code>  关键字是作用于指定的函数，那么  <code>-Wunused</code>  的这些选项就是作用于整个编译范围。</p>\n<h1 id=\"预处理命令\"><a class=\"anchor\" href=\"#预处理命令\">#</a> 预处理命令</h1>\n<h2 id=\"error\"><a class=\"anchor\" href=\"#error\">#</a> #error</h2>\n<p>在编译遇到  <code>#error</code>  指令时，它会停止编译过程，并显示一个错误消息，同时包含该指令的文件名和行号；这通常用于当编译器检查到不满足特定条件时，强制编译失败。</p>\n<h2 id=\"warning\"><a class=\"anchor\" href=\"#warning\">#</a> #warning</h2>\n<p>在编译遇到  <code>#warning</code>  指令时，它会继续编译，但会在编译输出中显示一个警告消息，同时包含该指令的文件名和行号。</p>\n<h1 id=\"预定义宏\"><a class=\"anchor\" href=\"#预定义宏\">#</a> 预定义宏</h1>\n<p><code>__LINE__</code>  和  <code>__FILE__</code>  分别用来显示当前的行号和文件名。</p>\n",
            "tags": [
                "gcc"
            ]
        },
        {
            "id": "https://arachnid.cc/gcc-compiler-collection/",
            "url": "https://arachnid.cc/gcc-compiler-collection/",
            "title": "GCC 编译器套件说明",
            "date_published": "2023-02-10T15:28:36.000Z",
            "content_html": "<h1 id=\"gcc-简述\"><a class=\"anchor\" href=\"#gcc-简述\">#</a> GCC 简述</h1>\n<p>The GNU Compiler Collection，通常简称 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9nY2MuZ251Lm9yZy8=\">GCC</span> ，是一套由 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ251Lm9yZy8=\">GNU</span> 开发的编译器集合。</p>\n<p>为什么是编辑器集合而不是编译器呢？</p>\n<p>那是因为 GNU 编译器集合包括 C、C++、Objective-C，Fortran，Ada、Go 和 D 等，以及这些语言的库 （libstdc++,...）。 GCC 最初是作为 GNU 操作系统的编译器编写的。 GNU 系统被开发为 100% 的<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ251Lm9yZy9waGlsb3NvcGh5L2ZyZWUtc3cuaHRtbA==\">自由软件</span> ，即从某种意义上说它是自由的，尊重用户的自由。另外 GCC 对硬件平台的支持，可以说无所不在，它不仅支持 x86 处理器架构，还支持 ARM, Motorola 68000, Motorola 8800，AtmelAVR，MIPS 等处理器架构。</p>\n<h1 id=\"gcc-主要构成\"><a class=\"anchor\" href=\"#gcc-主要构成\">#</a> GCC 主要构成</h1>\n<ol>\n<li>gcc-core：顾明之意是 GCC 的核心部分，这部分是只包含 c 的编译器及公共部分，而对其他语言（C++、Ada 等）的支持包需要另外安装，这也是 GCC 为何如此强大的重要原因 。gcc-core 依赖于 Binutils。</li>\n<li>Binutils：它是一组开发工具，包括连接器，汇编器和其他用于目标文件和档案的工具。关于 Binutils 的介绍可以参考官方的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9iaW51dGlscy8=\">Binutils</span> 介绍。这个软件包依赖于不同的目标机平台，因为不同目标机的指令集是不一样的，比如 arm 跟 x86 就不一样。<br />\n常用的工具有：\n<ul>\n<li>as：汇编器，把汇编语言代码转换为机器码（目标文件）。</li>\n<li>ld：链接器，把编译生成的多个目标文件组织成最终的可执行程序文件。</li>\n<li>readelf：可用于查看目标文件或可执行程序文件的信息。</li>\n<li>objcopy： 可用于目标文件格式转换，如  <code>.elf</code>  转换成  <code>.bin</code>  。</li>\n<li>objdump：可用于查看目标文件的信息，最主要的作用是反汇编。</li>\n<li>addr2line：可用于将程序指令地址转换为所对应的函数名、以及函数所在的源文件名和行号。</li>\n</ul>\n</li>\n<li>Glibc：包含了主要的 c 库，这个库提供了基本的例程，用于分配内存，搜索目录，读写文件，字符串处理等等。</li>\n</ol>\n<h1 id=\"arm-编译工具链\"><a class=\"anchor\" href=\"#arm-编译工具链\">#</a> ARM 编译工具链</h1>\n<p>编译器主要用来编译源文件，而在编译一个源文件时需要经过以下 4 步：</p>\n<ol>\n<li>预处理：为把头文件的代码、宏之类的内容转换成生成的  <code>.i</code>  文件，还是 C 代码。</li>\n<li>编译：把预处理后的  <code>.i</code>  文件通过编译成  <code>.s</code>  文件，汇编语言。</li>\n<li>汇编：将汇编语言文件生成目标文件  <code>.o</code>  文件，机器码。</li>\n<li>链接：将每个源文件对应的  <code>.o</code>  文件链接起来，就生成一个可执行程序文件。</li>\n</ol>\n<p>交叉编译器：如果我们希望编译器运行在 x86 架构平台上，然后编译生成 ARM 架构的可执行程序，这种编译器和目标程序运行在不同架构的编译过程，被称为 “交叉编译”，而对应使用的编译工具就成为交叉编译器。</p>\n<p>GNU 交叉编译器的命名规则：</p>\n<p><code>arch [-vendor] [-os] [-(gnu)abi] [-language]</code></p>\n<ul>\n<li>arch：体系架构，如  <code>arm</code>  、  <code>aarch64</code>  或者  <code>mips</code>  等；</li>\n<li>vendor：工具链提供商，没有 vendor 时，用  <code>none</code>  代替；</li>\n<li>os：目标操作系统，没有 os 支持时，用  <code>none</code>  代替；</li>\n<li>abi：应用二进制接口（Application Binary Interface），对于嵌入式平台命名为  <code>eabi</code>  ，  <code>e</code>  表示 Embedded；</li>\n<li>language：编译器支持的语言，如： <code>gcc</code>  、  <code>g++</code>  。</li>\n</ul>\n<p>note：如果同时没有 vendor 和 os 支持，则只用一个 none 代替。例如 arm-none-eabi 中的 none 表示既没有 vendor 也没有 os 支持。</p>\n<p><strong>关于 ABI 和 EABI 的区别</strong></p>\n<p>ABI：应用二进制接口（Application Binary Interface）。在计算机中，应用二进制接口描述了应用程序（或者其他类型）和操作系统之间或其他应用程序的低级接口。</p>\n<p>EABI：嵌入式应用二进制接口（Embedded Application Binary Interface）。嵌入式应用二进制接口指定了文件格式、数据类型、寄存器使用、堆积组织优化和在一个嵌入式软件中的参数的标准约定。开发者使用自己的汇编语言也可以使用 EABI 作为与兼容的编译器生成的汇编语言的接口。</p>\n<p>两者主要区别是：ABI 是计算机上的，EABI 是嵌入式平台上（如 ARM，MIPS 等）的；EABI 去掉了用户代码和系统内核之间的抽象，可以让用户代码直接访问硬件，提高了性能。</p>\n<p><strong>关于 gcc 和 g++ 的区别</strong></p>\n<p>实际上，只要是 gcc 编译器支持的语言都可以使用 gcc 编译器完成编译，而 g++ 编译器只会按照 C++ 的风格编译代码。虽然很多情况下我们都认为 C++ 是对 C 语言兼容的，但是实际上在一些具体的语法规则上，C++ 在编译过程中的语法检查会更加严格。此外，C++ 语言本身在编译 过程中也会引入 C++ 的标准库，如果使用 gcc 编译器直接编译 C++ 语言会在编译过程中添加额外的参数，这样会显得编译过程较为繁琐（因为大部分情况下我们希望标准库可以直接引入，而不是再需要手动指定，否则对于初级使用者会带来额外的学习负担）。为了更方便使用编译器，我们选择 g++ 来编译 C++ 代码。总结一下，gcc 可以完成 C++ 语言的编译，但是使用过程会较为繁琐，而 g++ 就是简化后的编译指令。</p>\n<p><strong>与 gnueabi 相关的 gnueabi 和 gnueabihf 的区别</strong></p>\n<p><code>gcc-arm-linux-gnueabi – The GNU C compiler for armel architecture</code></p>\n<p>AND</p>\n<p><code>gcc-arm-linux-gnueabihf – The GNU C compiler for armhf architecture</code></p>\n<p>这两个交叉编译器分别适用于 armel 和 armhf 两个不同的架构，armel 和 armhf 这两种架构在对待浮点运算采取了不同的策略（有 fpu 的 ARM 才能支持这两种浮点运算策略）。</p>\n<p>这两个交叉编译器是 gcc 的选项  <code>-mfloat-abi</code>  的默认值不同；该选项有三种值 soft、softfp、hard（其中后两者都要求 ARM 里有 fpu 浮点运算单元，soft 与后两者是兼容的，但 softfp 和 hard 两种模式互不兼容）：</p>\n<ul>\n<li>\n<p>soft： 不用 fpu 进行浮点计算，即使有 fpu 浮点运算单元也不用，而是使用软件模式。</p>\n</li>\n<li>\n<p>softfp： armel 架构（对应的编译器为 arm-linux-gnueabi-gcc ）采用的默认值，用 fpu 计算，但是传参数用普通寄存器传，这样中断的时候，只需要保存普通寄存器，中断负荷小，但是参数需要转换成浮点的再计算。</p>\n</li>\n<li>\n<p>hard： armhf 架构（对应的编译器 arm-linux-gnueabihf-gcc ）采用的默认值，用 fpu 计算，传参数也用 fpu 中的浮点寄存器传，省去了转换，性能最好，但是中断负荷高。</p>\n</li>\n</ul>\n<p>几种常见的编译 ARM 的交叉编译器：</p>\n<p>arm-none-eabi：用于编译裸机程序或系统，这个是没有操作系统的，不支持那些系统调用等系列接口，可调用  <code>newlib</code>  库，适用于 ARM7/Cortex-M/Cortex-R。</p>\n<p>arm-none-linux-gnueabi：用于编译 ARM 架构的 u-boot、Linux 内核、Linux 应用等，使用  <code>glibc</code>  库，适用于 ARM9/ARM11/Cortex-A。</p>\n<p>arm-eabi： 用于安卓程序编译。</p>\n<p>armcc：早期 Keil 软件公司（现已被 ARM 公司收购）出品的支持<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cua2VpbC5jb20vZGQv\">相应器件</span>的编译工具，可以编译裸机程序，一般和 ARM 开发工具一起，Keil MDK 内置。</p>\n<h1 id=\"基于-gcc-的-arm-编译工具链提供商\"><a class=\"anchor\" href=\"#基于-gcc-的-arm-编译工具链提供商\">#</a> 基于 GCC 的 ARM 编译工具链提供商</h1>\n<p>目前，为 ARM 平台提供交叉编译工具链的提供商，本人所找到的只有两家：ARM 官方和 Linaro 公司。</p>\n<h2 id=\"arm-gnu-toolchain\"><a class=\"anchor\" href=\"#arm-gnu-toolchain\">#</a> Arm GNU Toolchain</h2>\n<p>ARM 除了有自己的专用编译器之外，还维护了一套基于 GCC 的交叉编译工具链，被称为 Arm GNU Toolchain。截至于 2022 年，<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYXJtLmNvbS9kb3dubG9hZHMvLS9hcm0tZ251LXRvb2xjaGFpbi1kb3dubG9hZHM=\">Arm GNU Toolchain</span> 被分为了 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYXJtLmNvbS9kb3dubG9hZHMvLS9nbnUtYQ==\">A family</span>（GNU Toolchain for the Cortex-A Family） 和 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIuYXJtLmNvbS9kb3dubG9hZHMvLS9nbnUtcm0=\">R &amp; M family</span>（GNU Arm Embedded Toolchain）两大类，但是自 2022 年开始，ARM 对其进行了统一。</p>\n<p>编译器的目标平台：</p>\n<ul>\n<li>AArch32 bare-metal target：32 位纯裸机平台</li>\n<li>AArch64 ELF bare-metal target：64 位纯裸机平台</li>\n<li>AArch64 ELF bare-metal, big-endian target：64 位纯裸机平台（大端模式）</li>\n<li>AArch64 GNU/Linux target：64 位 Linux 平台</li>\n<li>AArch64 GNU/Linux big-endian target：64 位 Linux 平台（大端模式）</li>\n<li>AArch32 target with soft float：32 位带软件模式浮点运算</li>\n<li>AArch32 target with hard float：32 位带硬件模式浮点运算</li>\n</ul>\n<h2 id=\"linaro-toolchain\"><a class=\"anchor\" href=\"#linaro-toolchain\">#</a> Linaro Toolchain</h2>\n<p>Linaro 是一间非营利性质的开放源代码软件工程公司，主要的目标在于开发不同半导体公司系统单片机（SoC）平台的共通软件。其维护的工具链下载地址为：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zbmFwc2hvdHMubGluYXJvLm9yZy9nbnUtdG9vbGNoYWluLw==\">https://snapshots.linaro.org/gnu-toolchain/</span> 。另外，从 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubGluYXJvLm9yZy9kb3dubG9hZHMv\">https://www.linaro.org/downloads/</span> 的描述上看，目前 Linaro 仅针对于 Cortex-A 内核的编译工具链进行维护，而对用于 ARM 嵌入式处理器的 Cortex-R 和 Cortex-M 的最新裸机编译工具链，则需要去 ARM 官网下载！旧版可以在 <span class=\"exturl\" data-url=\"aHR0cDovL3JlbGVhc2VzLmxpbmFyby5vcmcvY29tcG9uZW50cy90b29sY2hhaW4vYmluYXJpZXMv\">http://releases.linaro.org/components/toolchain/binaries/</span> 中下载。</p>\n<h2 id=\"yocto-toolchain\"><a class=\"anchor\" href=\"#yocto-toolchain\">#</a> Yocto Toolchain</h2>\n<p>Yocto 为构建定制化的嵌入式 Linux 发行版提供一系列模板、工具和方法来简化定制 Linux 开发，允许更换软件配置和构建，避免重复工作 以及不必要的维护。Yocto 鼓励跨各种应用程序和设备类型的创新，支持多种硬件架构，包括 X86 (32 bit 和 64 bit)、ARM (32 bit 和 64 bit) 、RISC-V、PPC 和 MIPS 等。</p>\n<p>Yocto 构建的交叉编译工具，蕴含了众多的第三方组件，因此在构建完整的系统的中，不需要花太多的时间去编译添加第三方组件；像 NXP 的 <span class=\"exturl\" data-url=\"aHR0cDovL2kuTVg=\">i.MX</span> 系列的 SDK 固件包，就推荐使用 Yocto 搭建，同时给出基于 Yocto 定制的 <span class=\"exturl\" data-url=\"aHR0cDovL2kuTVg=\">i.MX</span> 搭建环境。除此如果想用 Yocto 原生 Toolchain 可以到 <span class=\"exturl\" data-url=\"aHR0cDovL2Rvd25sb2Fkcy55b2N0b3Byb2plY3Qub3JnL3JlbGVhc2VzL3lvY3RvLz9DPU0mYW1wO089RA==\">http://downloads.yoctoproject.org/releases/yocto/?C=M&amp;O=D</span> 进行下载，先选择需要版本，在  <code>./toolchain/</code>  路径下选择相应的平台，一般后缀  <code>.sh</code>  文件为 Yocto Toolchain 的安装脚本。</p>\n<h1 id=\"reference\"><a class=\"anchor\" href=\"#reference\">#</a> Reference</h1>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veGlhb3RsaWxpL3AvMzMwNjEwMC5odG1s\">https://www.cnblogs.com/xiaotlili/p/3306100.html</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pDU2hvdUNTRE4vYXJ0aWNsZS9kZXRhaWxzLzg5NTUzMzIz\">https://blog.csdn.net/ZCShouCSDN/article/details/89553323</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb21tdW5pdHkuYXJtLmNvbS9hcm0tY29tbXVuaXR5LWJsb2dzL2IvZW1iZWRkZWQtYmxvZy9wb3N0cy9zaHJpbmsteW91ci1tY3UtY29kZS1zaXplLXdpdGgtZ2NjLWFybS1lbWJlZGRlZC00LTc=\">https://community.arm.com/arm-community-blogs/b/embedded-blog/posts/shrink-your-mcu-code-size-with-gcc-arm-embedded-4-7</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTQ3MzcxMDQvd2hhdC1pcy10aGUtZGVmYXVsdC1jLXN0ZC1zdGFuZGFyZC12ZXJzaW9uLWZvci10aGUtY3VycmVudC1nY2MtZXNwZWNpYWxseS1vbi11\">https://stackoverflow.com/questions/14737104/what-is-the-default-c-std-standard-version-for-the-current-gcc-especially-on-u</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly91YnVudHVxYS5jb20vYXJ0aWNsZS8xMDQzMi5odG1s\">https://ubuntuqa.com/article/10432.html</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYW1vYmJzLmNvbS9mb3J1bS5waHA/bW9kPXZpZXd0aHJlYWQmYW1wO3RpZD01NzA5NDAw\">https://www.amobbs.com/forum.php?mod=viewthread&amp;tid=5709400</span></p>\n<h1 id=\"附\"><a class=\"anchor\" href=\"#附\">#</a> 附</h1>\n<p>GNU win：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9nbnV3aW4zMi5zb3VyY2Vmb3JnZS5uZXQv\">https://gnuwin32.sourceforge.net/</span></p>\n<p>GNU software：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9zb2Z0d2FyZS56aC1jbi5odG1s\">https://www.gnu.org/software/software.zh-cn.html</span></p>\n",
            "tags": [
                "gcc"
            ]
        }
    ]
}