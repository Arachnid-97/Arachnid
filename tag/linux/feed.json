{
    "version": "https://jsonfeed.org/version/1",
    "title": "命运转轮 • All posts by \"linux\" tag",
    "description": "不曾亏欠, 不曾辜负, 如此足矣",
    "home_page_url": "https://arachnid.cc",
    "items": [
        {
            "id": "https://arachnid.cc/virtual-network-setup/",
            "url": "https://arachnid.cc/virtual-network-setup/",
            "title": "vmware 下 ubuntu 双网卡设置",
            "date_published": "2023-02-25T09:28:19.345Z",
            "content_html": "<blockquote>\n<p>背景：主机电脑通过 WiFi 上网，网口用于跟开发板等设备有线连接；为此需要实现虚拟机内对系统可以进行外网访问网页或下载工具包等（避免切换主机操作），同时具备通过网线访问内网设备机器进行控制调试等操作。</p>\n<p>环境：VMware® Workstation 15 Pro</p>\n<p>平台：Ubuntu 18.04.6</p>\n</blockquote>\n<h1 id=\"step-1添加网卡\"><a class=\"anchor\" href=\"#step-1添加网卡\">#</a> step 1：添加网卡</h1>\n<p>在虚拟机窗口栏，依次点击  <code>编辑</code>  -&gt;  <code>虚拟网络编辑器</code>  ，可以看到原有默认的 VMnet 接口：</p>\n<p><img src=\"image-20230225172822709.png\" alt=\"image-20230225172822709\" /></p>\n<p>它们分别对应主机 ip 地址。</p>\n<p>然后我们建立一个桥接模式的 VMnet 虚拟网络，并指定响应网卡（如出现灰屏无法设置，需要<strong>以管理员身份打开</strong> VMware，或在当前窗口点击  <code>更改设置</code>  来赋予权限），然后选择对应需要进行桥接的网卡（即网口网卡）：</p>\n<p><img src=\"image-20230225193931835.png\" alt=\"image-20230225193931835\" /></p>\n<h1 id=\"setp-2配置网络设备器\"><a class=\"anchor\" href=\"#setp-2配置网络设备器\">#</a> setp 2：配置网络设备器</h1>\n<p>在 ubuntu 虚拟机右键点击  <code>设置</code>  -&gt;  <code>添加</code>  -&gt;  <code>网络适配器</code>  ，然后指定上面配置为桥接模式的  VMnet 虚拟网络：</p>\n<p><img src=\"image-20230225194908857.png\" alt=\"image-20230225194908857\" /></p>\n<h2 id=\"拓展\"><a class=\"anchor\" href=\"#拓展\">#</a> 拓展</h2>\n<p>关于 NAT（网络地址转换模式）、Host-only（主机模式）及 bridged（桥接模式）：</p>\n<p><img src=\"Perbedaan-NAT-Bridge-Dan-Host-Only-Di-Vmware-Dan-Virtualbox-1170x731.jpg\" alt=\"Perbedaan NAT Bridge Dan Host Only\" /></p>\n<ul>\n<li>\n<p>NAT 模式：使用 NAT 模式，就是让虚拟机借助 NAT （网络地址转换）功能，通过宿主机器所在的网络来访问外部网络，即：使用 NAT 模式可以实现在虚拟系统里访问互联网。</p>\n<p>优点：是从虚拟机访问外部网络的最简单方法；通常，它会自动设置网络地址转换到虚拟机上，不需要在宿主机器的网络信息上配置或通过访客操作系统上进行配置。</p>\n<p>缺点：就像路由器后面的专用网络一样，虚拟机是不可见的，无法从外部网络访问。</p>\n<p><img src=\"Virtual_network_switch_in_nat_mode.png\" alt=\"vmware-network-nat\" /></p>\n</li>\n<li>\n<p>Host-only 模式：构建一个与外界断开连接的内部网络，只允许使用 host-only 方法的虚拟机才能通信，因此无法与外部网络或其他 PC 主机通信，只能相互通信。</p>\n<p>优点：与内部网络一样，其不需要存在物理网络接口，相当于使用 host-only 方法的虚拟机通过双绞线直连形成网络节点进行通讯；由于无法访问外部网络，因此对于安全性来讲，比其余两种相对要高。</p>\n<p>缺点：如其名，无法与主机外部的网络通信，同时外部网络设备也无法与其通讯。</p>\n<p><img src=\"Virtual_network_switch_in_host-only_mode.png\" alt=\"vmware-network-hostonly\" /></p>\n</li>\n<li>\n<p>bridged 模式：在这种模式下，虚拟系统就像是局域网中的一台独立的主机，具有自己的 MAC 和 IP 地址；由于虚拟机和宿主机器分配了相同网段的 IP，因此宿主机器和虚拟机被识别为同一级别的物理主机。</p>\n<p>优点：虚拟机就像是一台独立的主机，拥有正常主机的网络功能，可以对外部网络进行访问，而外部网络也可以访问进来。</p>\n<p>缺点：由于外部网络可以访问，其安全性比其余两种相对要低；因与宿主机器平等的存在于网络中，需要进行分配网络地址、子网掩码、网关等操作。</p>\n<p><img src=\"Virtual_network_switch_in_bridged_mode.png\" alt=\"vmware-network-bridged\" /></p>\n</li>\n</ul>\n<p>示例：</p>\n<p>一些 VMnet 虚拟机具有特定功能：VMnet0 专用于 bridged 模式，VMnet1 专用于 host-only 模式，而 VMnet8 专用于 NAT 模式；其他的 VMnet2 等，可供虚拟机使用自定义网络模式。如图分析各模式作用：</p>\n<p><img src=\"workstation-networking_thumb1.jpg\" alt=\"工作站网络\" /></p>\n<ul>\n<li>\n<p>VM-1 可以与 host PC 通信，并连接到外部 LAN or internet，但不能与 NAT 和 host-only 网络通信。</p>\n</li>\n<li>\n<p>VM-2 和 VM-3 可以相互通信，也可以与 NAT 网络中的其他 VM 通信，也可以与 host PC 通信。</p>\n</li>\n<li>\n<p>VM-5 和 VM-4 可以相互通信，但不能与主机操作系统和 host-only 网络中的其他 VM 通信。</p>\n</li>\n<li>\n<p>VM-6 和 VM-7 无法相互通信。</p>\n</li>\n</ul>\n<p>参考：</p>\n<p><a href=\"https://superuser.com/questions/227505/what-is-the-difference-between-nat-bridged-host-only-networking\">What is the difference between NAT / Bridged / Host-Only networking?</a></p>\n<p><a href=\"https://pibytes.wordpress.com/2012/11/16/vmware-workstation-networking-basics/\">VMware Workstation Networking Basics</a></p>\n<p><a href=\"https://agussas.wordpress.com/2015/10/28/vmware-networking-concept-bridged-nat-host-only-lan-segment/\">VMWare Networking Concept [Bridged, NAT, Host Only, LAN Segment]</a></p>\n<p><a href=\"https://www.monitorteknologi.com/perbedaan-nat-bridge-dan-host-only/\">Perbedaan NAT Bridge Dan Host Only Di VMware Dan VirtualBox</a></p>\n<p><a href=\"https://wiki.libvirt.org/VirtualNetworking.html\">Virtual Networking</a></p>\n<p><a href=\"https://www.uname.in/60\">Vmware Host-Only, NAT, Bridge 차이</a></p>\n<p><a href=\"https://diarmuidmccarthy.wordpress.com/2011/02/15/hello-world/\">Intro to Virtual Machine Networking</a></p>\n<p><a href=\"https://ryanisagoodguy.blogspot.com/2019/06/vmwarenetwork-typebridgedhost-only-nat.html\">VMware 虛擬機器上網路連線 (Network type) 的三種模式</a></p>\n<h1 id=\"setp-3网络信息配置\"><a class=\"anchor\" href=\"#setp-3网络信息配置\">#</a> setp 3：网络信息配置</h1>\n<p>从上一步可以知道我们目前有两个网络适配器，分别是 NAT 和 桥接模式，然后针对这几个模式的作用也在上面作了介绍了；因此在这里，实际只需要在虚拟机系统中配置桥接模式对应的网卡网络信息就好了；至于 NAT 模式对应的网卡网络信息将由虚拟机借助 NAT （网络地址转换）功能实现自动配置即可实现访问外网功能。</p>\n<ol>\n<li>\n<p>查看所有网卡信息：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td data-command=\"[root@localhost] $\"></td><td><pre><span class=\"token function\">ifconfig</span> <span class=\"token parameter variable\">-a</span></pre></td></tr><tr><td data-num=\"2\"></td><td data-command=\"\"></td><td><pre>ens33: <span class=\"token assign-left variable\">flags</span><span class=\"token operator\">=</span><span class=\"token number\">416</span><span class=\"token operator\"><span class=\"token file-descriptor important\">3</span>&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class=\"token operator\">></span>  mtu <span class=\"token number\">1500</span></pre></td></tr><tr><td data-num=\"3\"></td><td data-command=\"\"></td><td><pre>        inet <span class=\"token number\">192.168</span>.154.133  netmask <span class=\"token number\">255.255</span>.255.0  broadcast <span class=\"token number\">192.168</span>.154.255</pre></td></tr><tr><td data-num=\"4\"></td><td data-command=\"\"></td><td><pre>        inet6 fe80::b52c:a0e6:1419:116b  prefixlen <span class=\"token number\">64</span>  scopeid 0x2<span class=\"token operator\"><span class=\"token file-descriptor important\">0</span>&lt;</span>link<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"5\"></td><td data-command=\"\"></td><td><pre>        ether 00:0c:29:f0:76:35  txqueuelen <span class=\"token number\">1000</span>  <span class=\"token punctuation\">(</span>以太网<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"6\"></td><td data-command=\"\"></td><td><pre>        RX packets <span class=\"token number\">102259</span>  bytes <span class=\"token number\">150687397</span> <span class=\"token punctuation\">(</span><span class=\"token number\">150.6</span> MB<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"7\"></td><td data-command=\"\"></td><td><pre>        RX errors <span class=\"token number\">0</span>  dropped <span class=\"token number\">0</span>  overruns <span class=\"token number\">0</span>  frame <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"8\"></td><td data-command=\"\"></td><td><pre>        TX packets <span class=\"token number\">13950</span>  bytes <span class=\"token number\">938511</span> <span class=\"token punctuation\">(</span><span class=\"token number\">938.5</span> KB<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"9\"></td><td data-command=\"\"></td><td><pre>        TX errors <span class=\"token number\">0</span>  dropped <span class=\"token number\">0</span> overruns <span class=\"token number\">0</span>  carrier <span class=\"token number\">0</span>  collisions <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"10\"></td><td data-command=\"\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td data-command=\"\"></td><td><pre>ens36: <span class=\"token assign-left variable\">flags</span><span class=\"token operator\">=</span><span class=\"token number\">416</span><span class=\"token operator\"><span class=\"token file-descriptor important\">3</span>&lt;</span>UP,BROADCAST,RUNNING,MULTICAST<span class=\"token operator\">></span>  mtu <span class=\"token number\">1500</span></pre></td></tr><tr><td data-num=\"12\"></td><td data-command=\"\"></td><td><pre>        inet <span class=\"token number\">192.168</span>.17.218  netmask <span class=\"token number\">255.255</span>.255.0  broadcast <span class=\"token number\">192.168</span>.17.255</pre></td></tr><tr><td data-num=\"13\"></td><td data-command=\"\"></td><td><pre>        inet6 240e:47c:680:2899:56c0:dff:d5fe:b1aa  prefixlen <span class=\"token number\">64</span>  scopeid 0x<span class=\"token operator\"><span class=\"token file-descriptor important\">0</span>&lt;</span>global<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"14\"></td><td data-command=\"\"></td><td><pre>        inet6 240e:47c:680:2899:18e7:3cfa:5fad:bbe  prefixlen <span class=\"token number\">64</span>  scopeid 0x<span class=\"token operator\"><span class=\"token file-descriptor important\">0</span>&lt;</span>global<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"15\"></td><td data-command=\"\"></td><td><pre>        inet6 fe80::a25b:a66f:67e7:3e67  prefixlen <span class=\"token number\">64</span>  scopeid 0x2<span class=\"token operator\"><span class=\"token file-descriptor important\">0</span>&lt;</span>link<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"16\"></td><td data-command=\"\"></td><td><pre>        ether 00:0c:29:f0:76:3f  txqueuelen <span class=\"token number\">1000</span>  <span class=\"token punctuation\">(</span>以太网<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"17\"></td><td data-command=\"\"></td><td><pre>        RX packets <span class=\"token number\">426</span>  bytes <span class=\"token number\">474569</span> <span class=\"token punctuation\">(</span><span class=\"token number\">474.5</span> KB<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"18\"></td><td data-command=\"\"></td><td><pre>        RX errors <span class=\"token number\">0</span>  dropped <span class=\"token number\">0</span>  overruns <span class=\"token number\">0</span>  frame <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"19\"></td><td data-command=\"\"></td><td><pre>        TX packets <span class=\"token number\">403</span>  bytes <span class=\"token number\">44762</span> <span class=\"token punctuation\">(</span><span class=\"token number\">44.7</span> KB<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"20\"></td><td data-command=\"\"></td><td><pre>        TX errors <span class=\"token number\">0</span>  dropped <span class=\"token number\">0</span> overruns <span class=\"token number\">0</span>  carrier <span class=\"token number\">0</span>  collisions <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"21\"></td><td data-command=\"\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td data-command=\"\"></td><td><pre>lo: <span class=\"token assign-left variable\">flags</span><span class=\"token operator\">=</span><span class=\"token number\">7</span><span class=\"token operator\"><span class=\"token file-descriptor important\">3</span>&lt;</span>UP,LOOPBACK,RUNNING<span class=\"token operator\">></span>  mtu <span class=\"token number\">65536</span></pre></td></tr><tr><td data-num=\"23\"></td><td data-command=\"\"></td><td><pre>        inet <span class=\"token number\">127.0</span>.0.1  netmask <span class=\"token number\">255.0</span>.0.0</pre></td></tr><tr><td data-num=\"24\"></td><td data-command=\"\"></td><td><pre>        inet6 ::1  prefixlen <span class=\"token number\">128</span>  scopeid 0x1<span class=\"token operator\"><span class=\"token file-descriptor important\">0</span>&lt;</span>host<span class=\"token operator\">></span></pre></td></tr><tr><td data-num=\"25\"></td><td data-command=\"\"></td><td><pre>        loop  txqueuelen <span class=\"token number\">1000</span>  <span class=\"token punctuation\">(</span>本地环回<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"26\"></td><td data-command=\"\"></td><td><pre>        RX packets <span class=\"token number\">308</span>  bytes <span class=\"token number\">26853</span> <span class=\"token punctuation\">(</span><span class=\"token number\">26.8</span> KB<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"27\"></td><td data-command=\"\"></td><td><pre>        RX errors <span class=\"token number\">0</span>  dropped <span class=\"token number\">0</span>  overruns <span class=\"token number\">0</span>  frame <span class=\"token number\">0</span></pre></td></tr><tr><td data-num=\"28\"></td><td data-command=\"\"></td><td><pre>        TX packets <span class=\"token number\">308</span>  bytes <span class=\"token number\">26853</span> <span class=\"token punctuation\">(</span><span class=\"token number\">26.8</span> KB<span class=\"token punctuation\">)</span></pre></td></tr><tr><td data-num=\"29\"></td><td data-command=\"\"></td><td><pre>        TX errors <span class=\"token number\">0</span>  dropped <span class=\"token number\">0</span> overruns <span class=\"token number\">0</span>  carrier <span class=\"token number\">0</span>  collisions <span class=\"token number\">0</span></pre></td></tr></table></figure></li>\n<li>\n<p>启用网卡（如已启用则跳过该步骤），其中  <code>ens36</code>  是设置 bridged 模式的网卡。</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td data-command=\"[root@localhost] $\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">ifconfig</span> ens36 up</pre></td></tr></table></figure></li>\n<li>\n<p>修改网络信息配置</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td data-command=\"[root@localhost] $\"></td><td><pre><span class=\"token function\">cp</span> /etc/netplan/01-network-manager-all.yaml /etc/netplan/01-network-manager-all.yaml.back <span class=\"token comment\"># 备份</span></pre></td></tr><tr><td data-num=\"2\"></td><td data-command=\"[root@localhost] $\"></td><td><pre><span class=\"token function\">vim</span> /etc/netplan/01-network-manager-all.yaml</pre></td></tr><tr><td data-num=\"3\"></td><td data-command=\"\"></td><td><pre><span class=\"token comment\"># Let NetworkManager manage all devices on this system</span></pre></td></tr><tr><td data-num=\"4\"></td><td data-command=\"\"></td><td><pre>network:</pre></td></tr><tr><td data-num=\"5\"></td><td data-command=\"\"></td><td><pre>  ethernets:</pre></td></tr><tr><td data-num=\"6\"></td><td data-command=\"\"></td><td><pre>    ens33:</pre></td></tr><tr><td data-num=\"7\"></td><td data-command=\"\"></td><td><pre>      dhcp4: <span class=\"token boolean\">true</span></pre></td></tr><tr><td data-num=\"8\"></td><td data-command=\"\"></td><td><pre>      dhcp4-overrides:</pre></td></tr><tr><td data-num=\"9\"></td><td data-command=\"\"></td><td><pre>        route-metric: <span class=\"token number\">100</span></pre></td></tr><tr><td data-num=\"10\"></td><td data-command=\"\"></td><td><pre>      <span class=\"token comment\"># addresses: [192.168.1.110/24]</span></pre></td></tr><tr><td data-num=\"11\"></td><td data-command=\"\"></td><td><pre>      <span class=\"token comment\"># gateway4: 192.168.1.1</span></pre></td></tr><tr><td data-num=\"12\"></td><td data-command=\"\"></td><td><pre>      <span class=\"token comment\"># nameservers:</span></pre></td></tr><tr><td data-num=\"13\"></td><td data-command=\"\"></td><td><pre>       <span class=\"token comment\"># addresses: [192.168.1.1]</span></pre></td></tr><tr><td data-num=\"14\"></td><td data-command=\"\"></td><td><pre>    ens36:</pre></td></tr><tr><td data-num=\"15\"></td><td data-command=\"\"></td><td><pre>      dhcp4: <span class=\"token boolean\">true</span></pre></td></tr><tr><td data-num=\"16\"></td><td data-command=\"\"></td><td><pre>  version: <span class=\"token number\">2</span></pre></td></tr><tr><td data-num=\"17\"></td><td data-command=\"\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td data-command=\"\"></td><td><pre>  bridges:</pre></td></tr><tr><td data-num=\"19\"></td><td data-command=\"\"></td><td><pre>    br0:</pre></td></tr><tr><td data-num=\"20\"></td><td data-command=\"\"></td><td><pre>     interfaces: <span class=\"token punctuation\">[</span>ens36<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"21\"></td><td data-command=\"\"></td><td><pre>     dhcp4: no</pre></td></tr><tr><td data-num=\"22\"></td><td data-command=\"\"></td><td><pre>     addresses:</pre></td></tr><tr><td data-num=\"23\"></td><td data-command=\"\"></td><td><pre>      - <span class=\"token number\">192.168</span>.1.110/24</pre></td></tr><tr><td data-num=\"24\"></td><td data-command=\"\"></td><td><pre>     nameservers:</pre></td></tr><tr><td data-num=\"25\"></td><td data-command=\"\"></td><td><pre>       addresses: <span class=\"token punctuation\">[</span><span class=\"token number\">8.8</span>.8.8<span class=\"token punctuation\">]</span></pre></td></tr><tr><td data-num=\"26\"></td><td data-command=\"\"></td><td><pre>     routes:</pre></td></tr><tr><td data-num=\"27\"></td><td data-command=\"\"></td><td><pre>      - to: <span class=\"token number\">0.0</span>.0.0/0</pre></td></tr><tr><td data-num=\"28\"></td><td data-command=\"\"></td><td><pre>        via: <span class=\"token number\">192.168</span>.1.1</pre></td></tr><tr><td data-num=\"29\"></td><td data-command=\"\"></td><td><pre>        metric: <span class=\"token number\">1000</span></pre></td></tr><tr><td data-num=\"30\"></td><td data-command=\"\"></td><td><pre></pre></td></tr><tr><td data-num=\"31\"></td><td data-command=\"\"></td><td><pre><span class=\"token comment\">#  renderer: NetworkManager</span></pre></td></tr><tr><td data-num=\"32\"></td><td data-command=\"\"></td><td><pre></pre></td></tr><tr><td data-num=\"33\"></td><td data-command=\"\"></td><td><pre>netplan apply</pre></td></tr><tr><td data-num=\"34\"></td><td data-command=\"\"></td><td><pre><span class=\"token function\">reboot</span></pre></td></tr></table></figure></li>\n<li>\n<p>重启后查看验证网路</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td data-command=\"[root@localhost] $\"></td><td><pre>route <span class=\"token parameter variable\">-n</span></pre></td></tr><tr><td data-num=\"2\"></td><td data-command=\"\"></td><td><pre>内核 IP 路由表</pre></td></tr><tr><td data-num=\"3\"></td><td data-command=\"\"></td><td><pre>目标            网关            子网掩码        标志  跃点   引用  使用 接口</pre></td></tr><tr><td data-num=\"4\"></td><td data-command=\"\"></td><td><pre><span class=\"token number\">0.0</span>.0.0         <span class=\"token number\">192.168</span>.154.2   <span class=\"token number\">0.0</span>.0.0         UG    <span class=\"token number\">100</span>    <span class=\"token number\">0</span>        <span class=\"token number\">0</span> ens33</pre></td></tr><tr><td data-num=\"5\"></td><td data-command=\"\"></td><td><pre><span class=\"token number\">0.0</span>.0.0         <span class=\"token number\">192.168</span>.1.1     <span class=\"token number\">0.0</span>.0.0         UG    <span class=\"token number\">1000</span>   <span class=\"token number\">0</span>        <span class=\"token number\">0</span> br0</pre></td></tr><tr><td data-num=\"6\"></td><td data-command=\"\"></td><td><pre><span class=\"token number\">192.168</span>.1.0     <span class=\"token number\">0.0</span>.0.0         <span class=\"token number\">255.255</span>.255.0   U     <span class=\"token number\">0</span>      <span class=\"token number\">0</span>        <span class=\"token number\">0</span> br0</pre></td></tr><tr><td data-num=\"7\"></td><td data-command=\"\"></td><td><pre><span class=\"token number\">192.168</span>.154.0   <span class=\"token number\">0.0</span>.0.0         <span class=\"token number\">255.255</span>.255.0   U     <span class=\"token number\">0</span>      <span class=\"token number\">0</span>        <span class=\"token number\">0</span> ens33</pre></td></tr><tr><td data-num=\"8\"></td><td data-command=\"\"></td><td><pre><span class=\"token number\">192.168</span>.154.2   <span class=\"token number\">0.0</span>.0.0         <span class=\"token number\">255.255</span>.255.255 UH    <span class=\"token number\">100</span>    <span class=\"token number\">0</span>        <span class=\"token number\">0</span> ens33</pre></td></tr><tr><td data-num=\"9\"></td><td data-command=\"[root@localhost] $\"></td><td><pre></pre></td></tr><tr><td data-num=\"10\"></td><td data-command=\"[root@localhost] $\"></td><td><pre><span class=\"token function\">ping</span> baidu.com</pre></td></tr><tr><td data-num=\"11\"></td><td data-command=\"\"></td><td><pre><span class=\"token punctuation\">..</span>.</pre></td></tr><tr><td data-num=\"12\"></td><td data-command=\"[root@localhost] $\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td data-command=\"[root@localhost] $\"></td><td><pre><span class=\"token function\">ping</span> <span class=\"token function\">host</span> <span class=\"token function\">ip</span></pre></td></tr><tr><td data-num=\"14\"></td><td data-command=\"\"></td><td><pre><span class=\"token punctuation\">..</span>.</pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"关于双网卡无法上网问题\"><a class=\"anchor\" href=\"#关于双网卡无法上网问题\">#</a> 关于双网卡无法上网问题</h1>\n<p>当在虚拟机网络中设置完 VMnet0 桥接的 IP 地址等信息，打开网络后，发现网络不通。</p>\n<p>但如果关闭 VMnet0，只保留 VMnet8，网络又是可行的，由此考虑到可能是网卡优先级的配置问题。</p>\n<p>通过上面可以发现  <code>br0</code>  的跃点比  <code>ens33</code>  的 metric 要高，而 metric 越低，其优先级越高，因此按上面操作来一般没问题的；如果这两个网卡的 metric 值反过来，那么会造成无法上网的问题，因为本身我们的有线网口是没有联网的，但优先级又比联网的网卡优先级高，所以会出现 ping 不通外网的情况。</p>\n<p>假设需要临时调整 ip /gateway/metric 等，可以使用  <code>route</code>  命令，而避免更改网络配置表文件，关于  <code>route</code>  命令使用可看 <a href=\"http://arachnid.cc/linux-routing-table\">Linux 路由表说明</a> 。</p>\n",
            "tags": [
                "Linux"
            ]
        },
        {
            "id": "https://arachnid.cc/uboot-starting/",
            "url": "https://arachnid.cc/uboot-starting/",
            "title": "uboot 引导启动分析",
            "date_published": "2023-02-22T13:19:51.653Z",
            "content_html": "<h1 id=\"uboot-命令\"><a class=\"anchor\" href=\"#uboot-命令\">#</a> uboot 命令</h1>\n<h2 id=\"命令支持\"><a class=\"anchor\" href=\"#命令支持\">#</a> 命令支持</h2>\n<p>当不清楚 uboot 支持什么命令时， 可输入  <code>help</code>  或  <code>?</code>  可查看 uboot 支持的命令列表；当需要具体使用哪个命令时，可使用  <code>help [命令]</code>  或  <code>? [命令]</code>  的方式查看具体命令的使用说明，eg： <code>help printenv</code>  。</p>\n<h2 id=\"常用命令行命令\"><a class=\"anchor\" href=\"#常用命令行命令\">#</a> 常用命令行命令</h2>\n<p><strong>A、环境变量操作</strong></p>\n<ol>\n<li>\n<p>printenv</p>\n<p>功能：打印环境变量</p>\n<p>用法： <code>printenv &lt;name&gt;</code>  ，其中 name 为相应的环境变量名，不填则打印所有环境变量配置。</p>\n</li>\n<li>\n<p>setenv</p>\n<p>功能：设置环境变量</p>\n<p>用法： <code>setenv &lt;key&gt; &lt;value&gt;</code>  ，其中 key 是变量名，value 是变量值。如果 value 为空，则表示删除对应的环境变量。</p>\n</li>\n<li>\n<p>saveenv</p>\n<p>功能：保存环境变量修改，使用 setenv 设置环境变量后不会掉电保存，需要保存后才不会丢失。</p>\n<p>用法： <code>saveenv</code>  。</p>\n</li>\n<li>\n<p>run</p>\n<p>功能：执行指定的环境变量里的语句。</p>\n<p>用法： <code>run &lt;var&gt;</code>  ，其中 key 是指定的环境变量。</p>\n</li>\n</ol>\n<p><strong>B、mmc 存储介质操作</strong></p>\n<ol>\n<li>\n<p>mmc</p>\n<p>功能：对 mmc 存储介质进行操作，包括 EMMC 和 SD 卡</p>\n<p>用法：</p>\n<ul>\n<li><code>mmc list</code>  ，用于查看板子上 mmc 设备。</li>\n<li><code>mmc dev &lt;dev&gt; &lt;part&gt;</code>  ，用于切换当前 mmc 设备，其中 dev 用来设置要切换的 mmc 设备号，part 是分区号（可以不写，默认为分区 0）。</li>\n<li><code>mmc info</code>  ，查看当前 mmc 设备信息。</li>\n<li><code>mmc part</code>  ，查看当前 mmc 设备分区。</li>\n<li><code>mmc read / write &lt;addr&gt; &lt;blk#&gt; &lt;cnt&gt;</code>  ，读取 or 写入当前 mmc 设备数据，其中 addr 是数据读取 / 写入到 DRAM 中的地址， blk# 是要读取 / 写入的块起始地址 (十六进制)，一个块是 512 字节，这里的块和扇区是一个意思，在 mmc 设备中我们通常说扇区， cnt 是要读取 / 写入的块数量 (十六进制)。</li>\n<li><code>mmc erase &lt;blk#&gt; &lt;cnt&gt;</code>  ，擦除当前 mmc 设备数据，其中 blk# 为要擦除的起始块， cnt 是要擦除的数量。</li>\n</ul>\n</li>\n</ol>\n<p><strong>C、网络操作</strong></p>\n<ol>\n<li>\n<p>ping</p>\n<p>功能：发送 ICMP_ECHO 请求到网络主机</p>\n<p>用法： <code>ping &lt;hostaddr&gt;</code>  ，其中 hostaddr 是目标发送请求主机 IP。</p>\n</li>\n<li>\n<p>dhcp</p>\n<p>功能：获取 ip 地址及通过 tftp 下载到内存。</p>\n<p>用法：</p>\n<ul>\n<li><code>dhcp</code>  ，单纯用于自动获取 ip 地址。</li>\n<li><code>dhcp &lt;loadaddr&gt; &lt;[hostIPaddr:]filename&gt;</code>  ，其中 loadaddr 是加载内存地址，hostIPaddr 是获取链接的主机 IP，filename 是要下载的文件名。</li>\n</ul>\n</li>\n<li>\n<p>nfs</p>\n<p>功能：通过 nfs (Network File System) 下载到内存。</p>\n<p>用法： <code>nfs &lt;loadaddr&gt; &lt;[hostIPaddr:]filename&gt;</code>  ，其中 loadaddr 是加载内存地址，hostIPaddr 是获取链接的主机 ip，filename 是要下载的文件名。</p>\n</li>\n<li>\n<p>tftpboot</p>\n<p>功能：通过 tftp 下载到内存</p>\n<p>用法： <code>tftpboot &lt;loadaddr&gt; &lt;[hostIPaddr:]filename&gt;</code>  ，其中 loadaddr 是加载内存地址，hostIPaddr 是获取链接的主机 ip，filename 是要下载的文件名。</p>\n</li>\n</ol>\n<p><strong>D、文件系统操作</strong></p>\n<ol>\n<li>\n<p>fatinfo</p>\n<p>功能：查询指定 mmc 设置指定分区的文件系统信息。</p>\n<p>用法： <code>fatinfo &lt;interface&gt; &lt;dev&gt;:&lt;part&gt;</code>  ，其中 interface 表示接口（mmc 等），dev 是查询的设备号， part 是要查询的分区。</p>\n</li>\n<li>\n<p>fatls / ext4ls</p>\n<p>功能：查询 FAT /ext4 格式设备的目录和文件信息。</p>\n<p>用法： <code>fatls / ext4ls &lt;interface&gt; &lt;dev&gt;:&lt;part&gt; &lt;directory&gt;</code>  ，其中 interface 表示接口（mmc 等），dev 是查询的设备号， part 是要查询的分区，directory 是要查询的目录（默认为根目录  <code>/</code>  ）。</p>\n</li>\n<li>\n<p>fatload / ext4load</p>\n<p>功能：查询 FAT /ext4 格式设备的目录和文件信息。</p>\n<p>用法： <code>fatload / ext4load &lt;interface&gt; &lt;dev&gt;:&lt;part&gt; &lt;addr&gt; &lt;filename&gt; &lt;bytes&gt; &lt;pos&gt;</code>  ，其中 interface 表示接口（mmc 等），dev 是查询的设备号， part 是要查询的分区，addr 是保存在 DRAM 中的起始地址， filename 是要读取的文件名字，bytes 表示读取多少字节的数据（0 或者省略表示读取整个文件），pos 是要读的文件相对于文件首地址的偏移（0 或者省略表示从文件首地址开始读取）。</p>\n</li>\n</ol>\n<p><strong>E、启动内核</strong></p>\n<ol>\n<li>\n<p>bootz</p>\n<p>功能：从指定内存位置加载启动 <strong>zImage 镜像文件</strong> 。</p>\n<p>用法： <code>bootm &lt;zImageaddr&gt; - &lt;fdtaddr&gt;</code>  ，其中，kerneladdr 是 zImage 镜像地址，fdtaddr 是设备树文件地址。</p>\n</li>\n<li>\n<p>bootm</p>\n<p>功能：从指定内存位置加载启动 <strong>uImage 镜像文件</strong> 。</p>\n<p>用法： <code>bootm &lt;uImageaddr&gt; &lt;- arg...&gt;</code>  ，其中，kerneladdr 是 uImage 镜像地址，arg 是为可选子命令，具体可看  <code>? bootm</code>  。</p>\n</li>\n<li>\n<p>boot</p>\n<p>功能：通过读取环境变量  <code>bootcmd</code>  来启动 linux 系统。</p>\n<p>用法： <code>boot</code>  。</p>\n</li>\n</ol>\n<h1 id=\"环境变量\"><a class=\"anchor\" href=\"#环境变量\">#</a> 环境变量</h1>\n<p>需要注意的是，环境变量的名字并不是统一的，除部分重要变量名外，主要是由芯片厂商或开发者自行协定的。</p>\n<h2 id=\"默认环境变量\"><a class=\"anchor\" href=\"#默认环境变量\">#</a> 默认环境变量</h2>\n<p>默认环境变量可以在  <code>include/configs/</code>  文件夹中找到对应的芯片配置头文件及在  <code>include/env_default.h</code>  文件中查看定义。一般其默认环境变量参数整体被定义在  <code>CONFIG_EXTRA_ENV_SETTINGS</code>  宏参数中，在 README 文件中可找到说明：</p>\n<figure class=\"highlight markdown\"><figcaption data-lang=\"markdown\"><span>README</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token list punctuation\">-</span> Default Environment:</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t\tCONFIG_EXTRA_ENV_SETTINGS</pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token code keyword\">\t\tDefine this to contain any number of null terminated</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\tstrings (variable = value pairs) that will be part of</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\tthe default environment compiled into the boot image.</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token code keyword\">\t\tFor example, place something like this in your</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\tboard's config file:</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token code keyword\">\t\t#define CONFIG_EXTRA_ENV_SETTINGS \\</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\t\t\"myvar1=value1\\0\" \\</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t\t\t\"myvar2=value2\\0\"</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre></pre></td></tr><tr><td data-num=\"15\"></td><td><pre><span class=\"token code keyword\">\t\tWarning: This method is based on knowledge about the</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\tinternal format how the environment is stored by the</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t\tU-Boot code. This is NOT an official, exported</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t\tinterface! Although it is unlikely that this format</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t\twill change soon, there is no guarantee either.</pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\t\tYou better know what you are doing here.</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre></pre></td></tr><tr><td data-num=\"22\"></td><td><pre><span class=\"token code keyword\">\t\tNote: overly (ab)use of the default environment is</pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\t\tdiscouraged. Make sure to check other ways to preset</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\t\tthe environment like the \"source\" command or the</pre></td></tr><tr><td data-num=\"25\"></td><td><pre>\t\tboot command first.</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token code keyword\">\t\tCONFIG_DELAY_ENVIRONMENT</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token code keyword\">\t\tNormally the environment is loaded when the board is</pre></td></tr><tr><td data-num=\"30\"></td><td><pre>\t\tinitialised so that it is available to U-Boot. This inhibits</pre></td></tr><tr><td data-num=\"31\"></td><td><pre>\t\tthat so that the environment is not available until</pre></td></tr><tr><td data-num=\"32\"></td><td><pre>\t\texplicitly loaded later by U-Boot code. With CONFIG_OF_CONTROL</pre></td></tr><tr><td data-num=\"33\"></td><td><pre>\t\tthis is instead controlled by the value of</pre></td></tr><tr><td data-num=\"34\"></td><td><pre>\t\t/config/load-environment.</span></pre></td></tr></table></figure><h2 id=\"常用环境变量\"><a class=\"anchor\" href=\"#常用环境变量\">#</a> 常用环境变量</h2>\n<p>在  <code>include/env_default.h</code>  文件定义的环境变量，可通过读取宏来配置相应值，也可从  <code>CONFIG_EXTRA_ENV_SETTINGS</code>  宏参数重新定义，其中有几个变量是比较重要，这里结合 NXP 厂商的定义进行如下参考分析：</p>\n<p><strong>1、console 变量（固有）</strong></p>\n<p>功能：表示控制台输出设备。</p>\n<p><strong>2、baudrate 变量（固有）</strong></p>\n<p>功能：指定 linux 系统启动过程中串口控制台打印的波特率。</p>\n<p><strong>3、bootdelay 变量（固有）</strong></p>\n<p>功能：设置 uboot 启动时等待用户输入的延时，单位是秒。</p>\n<p><strong>4、fdt_addr 变量（私人）</strong></p>\n<p>功能：设备树加载启动的地址。</p>\n<p><strong>5、fdt_file 变量（私人）</strong></p>\n<p>功能：设备树加载显示的名称，如果 uboot 中配置的名称对应不上获取的设备树文件，将显示 undefined。</p>\n<p><strong>6、image 变量（私人）</strong></p>\n<p>功能：内核加载启动读取的文件名。</p>\n<p><strong>7、loadaddr 变量（固有）</strong></p>\n<p>功能：内核加载启动的地址。</p>\n<p><strong>8、ipaddr/serverip/gatewayip/netmask 变量（固有）</strong></p>\n<p>功能：用于设置网络信息，分别对应开发板 ip、服务器 ip、网关、子网掩码；设置完成后可用 ping 命令测试网络连通性。</p>\n<p><strong>9、bootcmd 变量（固有）</strong></p>\n<p>功能： <code>bootcmd</code>  变量是用来存储启动命令的环境变量，它定义了 uboot 启动 linux 系统的具体步骤。当 uboot 倒计时结束以后就会执行  <code>bootcmd</code>  中的命令。这些命令一般都是用来启动 linux 内核的，比如读取 EMMC 或者 NAND Flash 中的 linux 内核镜像文件和设备树文件到 DRAM 中，然后启动 linux 内核。</p>\n<p>也可以在 uboot 启动以后进入命令行设置  <code>bootcmd</code>  环境变量的值。如果 EMMC 或者 NAND 中没有保存  <code>bootcmd</code>  的值，那么 uboot 就会使用默认的值。</p>\n<p>应用： <code>bootcmd</code>  变量的内容通常是一系列 uboot 命令和参数的组合，例如：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token assign-left variable\">bootcmd</span><span class=\"token operator\">=</span>run load_kernel<span class=\"token punctuation\">;</span> run load_dtb<span class=\"token punctuation\">;</span> bootz <span class=\"token variable\">$&#123;kernel_addr_r&#125;</span> - <span class=\"token variable\">$&#123;fdt_addr_r&#125;</span></pre></td></tr></table></figure><p>上述  <code>bootcmd</code>  变量定义了两个命令： <code>load_kernel</code>  和  <code>load_dtb</code> ，并最后执行了  <code>bootz</code>  命令来启动 linux 内核。这里的  <code>run</code>  命令表示执行一个之前定义好的环境变量，例如：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token assign-left variable\">load_kernel</span><span class=\"token operator\">=</span>mmc dev <span class=\"token variable\">$&#123;mmc_dev&#125;</span><span class=\"token punctuation\">;</span> fatload mmc <span class=\"token variable\">$&#123;mmc_dev&#125;</span><span class=\"token builtin class-name\">:</span><span class=\"token variable\">$&#123;mmc_part&#125;</span> <span class=\"token variable\">$&#123;kernel_addr&#125;</span> zImage</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token assign-left variable\">load_dtb</span><span class=\"token operator\">=</span>fatload mmc <span class=\"token variable\">$&#123;mmc_dev&#125;</span><span class=\"token builtin class-name\">:</span><span class=\"token variable\">$&#123;mmc_part&#125;</span> <span class=\"token variable\">$&#123;fdt_addr&#125;</span> devicetree.dtb</pre></td></tr></table></figure><p>在上述命令中， <code>load_kernel</code>  和  <code>load_dtb</code>  分别使用  <code>fatload</code>  命令从 mmc 设备  <code>$&#123;mmc_dev&#125;</code>  的  <code>$&#123;mmc_part&#125;</code>  分区（ <code>mmc $&#123;mmc_dev&#125;:$&#123;mmc_part&#125;</code> ）中加载内核和设备树； <code>$&#123;kernel_addr&#125;</code>  和  <code>$&#123;fdt_addr&#125;</code>  是在 uboot 中预定义的环境变量，分别表示内核和设备树在内存中的地址。</p>\n<p>在实际应用中， <code>bootcmd</code>  变量的内容需要根据硬件平台和具体应用场景来设置，以确保系统能够正确启动。可以使用  <code>printenv bootcmd</code>  命令来查看当前的  <code>bootcmd</code>  命令，使用  <code>setenv bootcmd &lt;cmd&gt;</code>  命令来手动设置  <code>bootcmd</code>  变量，例如，把上述命令定义并保存到  <code>bootcmd</code>  变量中：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>setenv bootcmd <span class=\"token string\">'run load_kernel; run load_dtb; run load_rootfs; bootm'</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>saveenv</pre></td></tr></table></figure><p><strong>10、bootargs 变量（固有）</strong></p>\n<p>功能： <code>bootargs</code>  变量是用来存储内核启动参数的环境变量，它在启动 linux 内核时会被传递给内核。bootargs 变量可以在 uboot 命令行中手动设置，也可以通过脚本自动设置。下面是一些常见的  <code>bootargs</code>  参数：</p>\n<ul>\n<li>\n<p>console：指定内核输出信息的终端设备，可以是串口、LCD 显示屏等。</p>\n</li>\n<li>\n<p>root：指定根文件系统所在的设备和分区。</p>\n</li>\n<li>\n<p>rootfstype：指定根文件系统的文件系统类型，例如  <code>ext4</code> 、 <code>jffs2</code> 、 <code>nfs</code>  等。</p>\n</li>\n<li>\n<p>ip：指定 IP 地址和网络参数，用于网络启动。</p>\n</li>\n<li>\n<p>mem：指定系统可用内存的大小，用于系统启动时内存的自适应分配。</p>\n</li>\n<li>\n<p>quiet：设置内核启动时不显示冗长的信息。</p>\n</li>\n<li>\n<p>debug：开启内核调试模式，用于调试内核代码。</p>\n</li>\n</ul>\n<p>应用：在设置  <code>bootargs</code>  变量时，需要根据硬件平台和具体应用场景来选择合适的参数，并确保参数的正确性。例如， <code>console</code>  参数需要根据硬件平台的串口地址和波特率来设置， <code>root</code>  参数需要根据具体的文件系统类型和分区来设置。例如：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>setenv bootargs <span class=\"token assign-left variable\">console</span><span class=\"token operator\">=</span><span class=\"token variable\">$&#123;console&#125;</span>,<span class=\"token variable\">$&#123;baudrate&#125;</span> <span class=\"token assign-left variable\">root</span><span class=\"token operator\">=</span><span class=\"token variable\">$&#123;mmc_root&#125;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>saveenv</pre></td></tr></table></figure><h2 id=\"环境变量设置\"><a class=\"anchor\" href=\"#环境变量设置\">#</a> 环境变量设置</h2>\n<p>环境变量的设置有两种方法，一种方法是通过修改静态配置，即通过修改 uboot 的文件中相关环境变量的配置。不过此类方法在实际中显然非常不实际，每次需要修改一次环境变量都需要重新编译整个 uboot。</p>\n<p>另一种方法是利用 uboot 提供的  <code>setenv</code>  动态修改环境变量的设置，当设置完成后再通过  <code>saveenv</code>  把相应的环境变量设置保存到 Flash 等非易失性存储设备上。</p>\n<h1 id=\"启动方式\"><a class=\"anchor\" href=\"#启动方式\">#</a> 启动方式</h1>\n<p>uboot 有两种启动 linux 内核和 rootfs 的方法，一种是直接从 flash (nand 或 emmc) 启动，一种是从网络启动。这里面用到了两个非常重要的环境变量  <code>bootcmd</code>  和  <code>bootargs</code>  。</p>\n<h2 id=\"从-emmc-启动\"><a class=\"anchor\" href=\"#从-emmc-启动\">#</a> 从 EMMC 启动</h2>\n<p>从 EMMC 启动也就是将编译出来的 linux 镜像文件 zImage 和设备树文件保存在 EMMC 中， uboot 从 EMMC 中读取这两个文件并启动。</p>\n<p>以 NXP 的 imx-6ull 为例：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>setenv bootargs <span class=\"token string\">'console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw'</span> <span class=\"token comment\"># 设置控制台输出设备为 ttymxc0、波特率为 115200；指明根文件系统存放在 mmcblk1 设备的分区 2 中，EMMC 版本的核心板启动 linux 以后会存在 /dev/mmcblk0、/dev/mmcblk1、 /dev/mmcblk0p1、/dev/mmcblk0p2、 /dev/mmcblk1p1 和 /dev/mmcblk1p2 这样的文件，其中 /dev/mmcblkx (x=0~ n) 表示 mmc 设备，而 /dev/mmcblkxpy (x=0~ n,y=1~ n) 表示 mmc 设备 x 的分区 y；rootwait 表示等待 mmc 设备初始化完成以后再挂载，否则的话 mmc 设备还没初始化完成就挂载根文件系统会出错的，rw 表示根文件系统是可以读写的，不加 rw 的话可能无法在根文件系统中进行写操作，只能进行读操作。</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>mmc dev <span class=\"token number\">1</span> <span class=\"token comment\"># 切换到 EMMC</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>fatload mmc <span class=\"token number\">1</span>:1 0x80800000 zImage <span class=\"token comment\"># 读取 zImage 到 0x80800000 处</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>fatload mmc <span class=\"token number\">1</span>:1 0x83000000 imx6ull-14x14-evk.dtb <span class=\"token comment\"># 读取设备树到 0x83000000 处</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>bootz 0x80800000 - 0x83000000 <span class=\"token comment\"># 启动内核</span></pre></td></tr></table></figure><h2 id=\"从网络启动\"><a class=\"anchor\" href=\"#从网络启动\">#</a> 从网络启动</h2>\n<p>从网络启动最主要的是用来调试，试想，假设你更改了部分 linux 驱动，如果是使用 EMMC 进行烧录下载，那么就得每次都对其镜像烧写到 EMMC 中，这样就太麻烦，因此我们可以使用网络对其进行烧录替换镜像。其前提条件是必须配置好网络设备及设备树，能正常连通，否者一切都是扯淡。</p>\n<p>以 NXP 的 imx-6ull 为例：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>setenv ipaddr <span class=\"token number\">192.168</span>.1.xxx</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>setenv gatewayip <span class=\"token number\">192.168</span>.1.1</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>setenv netmask <span class=\"token number\">255.255</span>.255.0</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>setenv serverip <span class=\"token number\">192.168</span>.1.xxx</pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>setenv bootargs <span class=\"token string\">'console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw'</span> <span class=\"token comment\"># 解释同上</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>tftpboot <span class=\"token number\">80800000</span> zImage</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>tftp <span class=\"token number\">83000000</span> imx6ull-14x14-evk.dtb</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>bootz <span class=\"token number\">80800000</span> - <span class=\"token number\">83000000</span></pre></td></tr></table></figure>",
            "tags": [
                "Linux"
            ]
        },
        {
            "id": "https://arachnid.cc/linux-routing-table/",
            "url": "https://arachnid.cc/linux-routing-table/",
            "title": "Linux 路由表说明",
            "date_published": "2023-02-05T06:32:47.036Z",
            "content_html": "<h1 id=\"route-命令\"><a class=\"anchor\" href=\"#route-命令\">#</a> route 命令</h1>\n<p>选项：</p>\n<ul>\n<li>\n<p><code>-v</code>  ：显示详细信息。</p>\n</li>\n<li>\n<p><code>-n</code>  ：不执行 DNS 反向查找（即不解析名称），直接显示数字形式的 IP 地址。</p>\n</li>\n<li>\n<p><code>-e</code>  ：netstat 格式显示路由表。</p>\n</li>\n<li>\n<p><code>-C</code>  ：打印 Linux 内核的路由缓存。</p>\n</li>\n<li>\n<p><code>add</code>  ：增加路由记录 /  <code>del</code>  ：删除路由记录</p>\n<ul>\n<li><code>-net</code>  ：目的地址是一个网络。</li>\n<li><code>-host</code>  ：目的地址是一台主机。</li>\n<li><code>netmask</code>  ：目的地址的网络掩码。</li>\n<li><code>gw</code>  ：路由数据包通过的网关。</li>\n<li><code>metric</code>  ：设置路由跃点。</li>\n</ul>\n</li>\n</ul>\n<p>eg：</p>\n<p>1、添加主机路由</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>添加主机路由</span></figcaption><table><tr><td data-num=\"1\"></td><td data-command=\"[root@localhost] $\"></td><td><pre>route <span class=\"token function\">add</span> <span class=\"token parameter variable\">-net</span> <span class=\"token number\">10.0</span>.0.10 netmask <span class=\"token number\">255.255</span>.255.255 gw <span class=\"token number\">10.139</span>.128.1 dev eth0</pre></td></tr><tr><td data-num=\"2\"></td><td data-command=\"[root@localhost] $\"></td><td><pre>route <span class=\"token parameter variable\">-n</span></pre></td></tr><tr><td data-num=\"3\"></td><td data-command=\"\"></td><td><pre>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</pre></td></tr><tr><td data-num=\"4\"></td><td data-command=\"\"></td><td><pre><span class=\"token number\">10.0</span>.0.10       <span class=\"token number\">10.139</span>.128.1    <span class=\"token number\">255.255</span>.255.255 UGH   <span class=\"token number\">0</span>      <span class=\"token number\">0</span>        <span class=\"token number\">0</span> eth0</pre></td></tr><tr><td data-num=\"5\"></td><td data-command=\"\"></td><td><pre><span class=\"token punctuation\">..</span>.</pre></td></tr></table></figure><p>2、添加网络路由</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>添加网络路由</span></figcaption><table><tr><td data-num=\"1\"></td><td data-command=\"[root@localhost] $\"></td><td><pre>route <span class=\"token function\">add</span> <span class=\"token parameter variable\">-net</span> <span class=\"token number\">10.0</span>.0.0 netmask <span class=\"token number\">255.255</span>.255.0 gw <span class=\"token number\">10.139</span>.128.1 dev eth0</pre></td></tr><tr><td data-num=\"2\"></td><td data-command=\"[root@localhost] $\"></td><td><pre>route <span class=\"token parameter variable\">-n</span></pre></td></tr><tr><td data-num=\"3\"></td><td data-command=\"\"></td><td><pre>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</pre></td></tr><tr><td data-num=\"4\"></td><td data-command=\"\"></td><td><pre><span class=\"token number\">10.0</span>.0.0        <span class=\"token number\">10.139</span>.128.1    <span class=\"token number\">255.255</span>.255.0   UG    <span class=\"token number\">0</span>      <span class=\"token number\">0</span>        <span class=\"token number\">0</span> eth0</pre></td></tr><tr><td data-num=\"5\"></td><td data-command=\"\"></td><td><pre><span class=\"token punctuation\">..</span>.</pre></td></tr></table></figure><p>3、添加设置默认网关跃点为 80</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>添加设置默认网关</span></figcaption><table><tr><td data-num=\"1\"></td><td data-command=\"[root@localhost] $\"></td><td><pre>route <span class=\"token function\">add</span> default gw <span class=\"token number\">192.168</span>.1.1 metric <span class=\"token number\">80</span></pre></td></tr><tr><td data-num=\"2\"></td><td data-command=\"[root@localhost] $\"></td><td><pre>route <span class=\"token parameter variable\">-n</span></pre></td></tr><tr><td data-num=\"3\"></td><td data-command=\"\"></td><td><pre>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</pre></td></tr><tr><td data-num=\"4\"></td><td data-command=\"\"></td><td><pre><span class=\"token number\">0.0</span>.0.0         <span class=\"token number\">192.168</span>.1.1     <span class=\"token number\">0.0</span>.0.0         UG    <span class=\"token number\">0</span>      <span class=\"token number\">0</span>        <span class=\"token number\">0</span> eth0</pre></td></tr><tr><td data-num=\"5\"></td><td data-command=\"\"></td><td><pre><span class=\"token punctuation\">..</span>.</pre></td></tr></table></figure><p>4、删除路由</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>删除路由</span></figcaption><table><tr><td data-num=\"1\"></td><td data-command=\"[root@localhost] $\"></td><td><pre>route del default gw <span class=\"token number\">192.168</span>.1.1 metric <span class=\"token number\">80</span></pre></td></tr></table></figure><h1 id=\"字段分析\"><a class=\"anchor\" href=\"#字段分析\">#</a> 字段分析</h1>\n<p>使用  <code>route</code>  or  <code>route -n</code>  命令查看内核路由表：</p>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>命令行提示符</span></figcaption><table><tr><td data-num=\"1\"></td><td data-command=\"[root@localhost] $\"></td><td><pre>route</pre></td></tr><tr><td data-num=\"2\"></td><td data-command=\"\"></td><td><pre>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</pre></td></tr><tr><td data-num=\"3\"></td><td data-command=\"\"></td><td><pre>default         _gateway        <span class=\"token number\">0.0</span>.0.0         UG    <span class=\"token number\">100</span>    <span class=\"token number\">0</span>        <span class=\"token number\">0</span> ens33</pre></td></tr><tr><td data-num=\"4\"></td><td data-command=\"\"></td><td><pre>default         _gateway        <span class=\"token number\">0.0</span>.0.0         UG    <span class=\"token number\">1000</span>   <span class=\"token number\">0</span>        <span class=\"token number\">0</span> br0</pre></td></tr><tr><td data-num=\"5\"></td><td data-command=\"\"></td><td><pre><span class=\"token number\">192.168</span>.10.0    <span class=\"token number\">0.0</span>.0.0         <span class=\"token number\">255.255</span>.255.0   U     <span class=\"token number\">0</span>      <span class=\"token number\">0</span>        <span class=\"token number\">0</span> br0</pre></td></tr><tr><td data-num=\"6\"></td><td data-command=\"\"></td><td><pre><span class=\"token number\">192.168</span>.29.0    <span class=\"token number\">0.0</span>.0.0         <span class=\"token number\">255.255</span>.255.0   U     <span class=\"token number\">0</span>      <span class=\"token number\">0</span>        <span class=\"token number\">0</span> ens33</pre></td></tr><tr><td data-num=\"7\"></td><td data-command=\"\"></td><td><pre>_gateway        <span class=\"token number\">0.0</span>.0.0         <span class=\"token number\">255.255</span>.255.255 UH    <span class=\"token number\">100</span>    <span class=\"token number\">0</span>        <span class=\"token number\">0</span> ens33</pre></td></tr><tr><td data-num=\"8\"></td><td data-command=\"[root@localhost] $\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td data-command=\"[root@localhost] $\"></td><td><pre>route <span class=\"token parameter variable\">-n</span></pre></td></tr><tr><td data-num=\"10\"></td><td data-command=\"\"></td><td><pre>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</pre></td></tr><tr><td data-num=\"11\"></td><td data-command=\"\"></td><td><pre><span class=\"token number\">0.0</span>.0.0         <span class=\"token number\">192.168</span>.29.2    <span class=\"token number\">0.0</span>.0.0         UG    <span class=\"token number\">100</span>    <span class=\"token number\">0</span>        <span class=\"token number\">0</span> ens33</pre></td></tr><tr><td data-num=\"12\"></td><td data-command=\"\"></td><td><pre><span class=\"token number\">0.0</span>.0.0         <span class=\"token number\">192.168</span>.10.1    <span class=\"token number\">0.0</span>.0.0         UG    <span class=\"token number\">1000</span>   <span class=\"token number\">0</span>        <span class=\"token number\">0</span> br0</pre></td></tr><tr><td data-num=\"13\"></td><td data-command=\"\"></td><td><pre><span class=\"token number\">192.168</span>.10.0    <span class=\"token number\">0.0</span>.0.0         <span class=\"token number\">255.255</span>.255.0   U     <span class=\"token number\">0</span>      <span class=\"token number\">0</span>        <span class=\"token number\">0</span> br0</pre></td></tr><tr><td data-num=\"14\"></td><td data-command=\"\"></td><td><pre><span class=\"token number\">192.168</span>.29.0    <span class=\"token number\">0.0</span>.0.0         <span class=\"token number\">255.255</span>.255.0   U     <span class=\"token number\">0</span>      <span class=\"token number\">0</span>        <span class=\"token number\">0</span> ens33</pre></td></tr><tr><td data-num=\"15\"></td><td data-command=\"\"></td><td><pre><span class=\"token number\">192.168</span>.29.2    <span class=\"token number\">0.0</span>.0.0         <span class=\"token number\">255.255</span>.255.255 UH    <span class=\"token number\">100</span>    <span class=\"token number\">0</span>        <span class=\"token number\">0</span> ens33</pre></td></tr></table></figure><p>字段分类说明：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">字段</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Destination</td>\n<td style=\"text-align:left\">目标网络或目标主机。Destination 为 default（ <code>0.0.0.0</code> ）时，表示这个是默认网关，所有数据都发到这个网关（这里是  <code>10.139.128.1</code> ）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Gateway</td>\n<td style=\"text-align:left\">网关地址， <code>0.0.0.0</code>  表示当前记录对应的 Destination 跟本机在同一个网段，通信时不需要经过网关（同一个局域网内 2 台主机通信不需要经过网关）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Genmask</td>\n<td style=\"text-align:left\">Destination 字段的网络掩码，Destination 是主机时需要设置为  <code>255.255.255.255</code>  ，是默认路由时会设置为  <code>0.0.0.0</code>  。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Flags</td>\n<td style=\"text-align:left\">见下文说明。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Metric</td>\n<td style=\"text-align:left\">跃点，指到达指定网络所需的中转数，是大型局域网和广域网设置所必需的 （不在 Linux 内核中使用）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Ref</td>\n<td style=\"text-align:left\">路由项引用次数 （不在 Linux 内核中使用）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Use</td>\n<td style=\"text-align:left\">此路由项被路由软件查找的次数。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Iface</td>\n<td style=\"text-align:left\">网卡名字，例如  <code>eth0</code>  ；要去往这个网段需要使用哪一个网络接口。也就是  <code>eth0</code>  这张网卡。</td>\n</tr>\n</tbody>\n</table>\n<p>可以看到 Flags 下面有许多字母组合，他们分别的含义是：</p>\n<ul>\n<li>\n<p><strong>U (route is up)</strong> ：该路由处于活跃；</p>\n</li>\n<li>\n<p><strong>H (target is a host)</strong> ：目标是一部主机 (IP) 而非网域（子网掩码是 255.255.255.255）；</p>\n</li>\n<li>\n<p><strong>G (use gateway)</strong> ：需要透过外部的主机 (gateway) 来转递封包（一般指向默认网关）；</p>\n</li>\n<li>\n<p><strong>R (reinstate route for dynamic routing)</strong> ：使用动态路由时，恢复路由资讯的旗标；</p>\n</li>\n<li>\n<p><strong>D (dynamically installed by daemon or redirect)</strong> ：已经由服务或转 port 功能设定为动态路由</p>\n</li>\n<li>\n<p><strong>M (modified from routing daemon or redirect)</strong> ：路由已经被修改了；</p>\n</li>\n<li>\n<p><strong>! (reject route)</strong> ：这个路由将不会被接受（用来抵挡不安全的网域）。</p>\n</li>\n</ul>\n<h1 id=\"路由种类\"><a class=\"anchor\" href=\"#路由种类\">#</a> 路由种类</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">路由类型</th>\n<th style=\"text-align:left\">子网掩码</th>\n<th style=\"text-align:left\">Flag 字段</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">主机路由</td>\n<td style=\"text-align:left\">255.255.255.255</td>\n<td style=\"text-align:left\">UH</td>\n<td style=\"text-align:left\">指向单个 IP 地址或主机名的路由记录</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">网络路由</td>\n<td style=\"text-align:left\">255.255.255.0</td>\n<td style=\"text-align:left\">U</td>\n<td style=\"text-align:left\">代表主机可以到达的网络，比如说目的地址是  <code>192.168.10.xxx</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">默认路由</td>\n<td style=\"text-align:left\">0.0.0.0</td>\n<td style=\"text-align:left\">UG</td>\n<td style=\"text-align:left\">当主机不能在路由表中查找到目标主机的 IP 时，数据包就发到默认路由上</td>\n</tr>\n</tbody>\n</table>\n",
            "tags": [
                "Linux"
            ]
        },
        {
            "id": "https://arachnid.cc/linux-system-constitute/",
            "url": "https://arachnid.cc/linux-system-constitute/",
            "title": "Linux 系统构成：bootloader、kernel、rootfs",
            "date_published": "2023-02-02T11:34:26.713Z",
            "content_html": "<h1 id=\"前言\"><a class=\"anchor\" href=\"#前言\">#</a> 前言</h1>\n<p>完整的 linux 系統需要以下部分：</p>\n<ul>\n<li>Bootloader\n<ul>\n<li>boot.img</li>\n</ul>\n</li>\n<li>Linux Kernel（Linux 内核）\n<ul>\n<li>Device tree blob</li>\n</ul>\n</li>\n<li>Root Filesystem（根目录文件系統）</li>\n</ul>\n<h1 id=\"bootloader\"><a class=\"anchor\" href=\"#bootloader\">#</a> bootloader</h1>\n<p>bootloader（引导装载程序）就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境设置成一个合适的状态，以便为最终调用操作系统内核准备好正确的环境。</p>\n<p>常见的 bootloader 有 PC 平台的 Grub；嵌入式平台的 vivi, RedBoot, u-boot 等，其中 u-boot 在使用上最广泛，因此在嵌入式中又常称 linux 系统构成为 u-boot、kernel、rootfs。</p>\n<p>bootloader 是严重地依赖于硬件而实现的，特别是在嵌入式系统。因此，在嵌入式系统里建立一个通用的 bootloader 几乎是不可能的。尽管如此，我们仍然可以对 bootloader 归纳出一些通用的概念来，以指导用户进行特定的 bootloader 设计与实现。</p>\n<p>在嵌入式系统中，bootloader 的意义与作用相当于 PC 平台中的 BIOS + Grub，它对开发板上的主要部件如 CPU、SDRAM、FLASH、串口等进行了初始化，可以使用 bootloader 下载文件到开发板，可以浏览目录，可以烧录 flash，可以启动系统等，实际上，一个功能比较强大的 bootloader 已经相当于一个微型的操作系统了。</p>\n<p>总体上 bootloader 需要完成以下工作：</p>\n<ul>\n<li>\n<p>初始化 CPU 速度；</p>\n</li>\n<li>\n<p>初始化内存，包括初始化内存配置寄存器等；</p>\n</li>\n<li>\n<p>初始化中断控制器，在系统启动时，关闭中断，关闭看门狗；</p>\n</li>\n<li>\n<p>初始化串行端口（如果在目标上有的话）；</p>\n</li>\n<li>\n<p>启用指令 / 数据高速缓存；</p>\n</li>\n<li>\n<p>设置堆栈指针；</p>\n</li>\n<li>\n<p>设置参数区域并构造参数结构和标记（这是重要的一步，因为内核在标识根设备、页面大小、内存大小以及更多内容时可能需要使用引导参数）；</p>\n</li>\n<li>\n<p>执行 POST（加电自检）来标识存在的设备并报告有何问题；</p>\n</li>\n<li>\n<p>为电源管理提供挂起 / 恢复支持；</p>\n</li>\n<li>\n<p>传输操作系统内核镜像文件到目标机。也可以将操作系统内核镜像文件事先存放在 Flash 中，这样就不需要 bootLoader 和主机传输操作系统内核镜像文件，这通常是在做成产品的情况下使用。而一般在开发过程中，为了调试内核的方便，不将操作系统内核镜像文件固化在 Flash 中，这就需要主机和目标机进行文件传输；</p>\n</li>\n<li>\n<p>跳转到内核的开始，在此又分为 ROM 启动和 RAM 启动。所谓 ROM 启动就是用 XIP 技术直接在 Flash 中执行操作系统镜像文件；所谓 RAM 启动就是指把内核镜像从 Flash 复制到 RAM 中，然后再将 PC 指针跳转到 RAM 中的操作系统启动地址。</p>\n</li>\n</ul>\n<p>目前使用的主流<strong>嵌入式平台</strong>，几乎都是用 u-boot 作为启动引导，u-boot 有哪些突出的优点呢？</p>\n<p>① 开放源码：<a href=\"https://github.com/u-boot/u-boot%EF%BC%9B\">https://github.com/u-boot/u-boot；</a></p>\n<p>② 支持多种嵌入式操作系统内核，如 Linux、NetBSD, VxWorks, QNX, RTEMS, ARTOS, LynxOS, android；</p>\n<p>③ 支持多个处理器系列，如 PowerPC、ARM、x86、MIPS；</p>\n<p>④ 较高的可靠性和稳定性；</p>\n<p>⑤ 高度灵活的功能设置，适合 u-boot 调试、操作系统不同引导要求、产品发布等；</p>\n<p>⑥ 丰富的设备驱动源码，如串口、以太网、SDRAM、FLASH、LCD、NVRAM、EEPROM、RTC、键盘等；</p>\n<p>⑦ 较为丰富的开发调试文档与强大的网络技术支持。</p>\n<h1 id=\"kernel\"><a class=\"anchor\" href=\"#kernel\">#</a> kernel</h1>\n<p>kernel 即 linux 内核。内核源代码可以免费从<a href=\"https://www.kernel.org/\">官网</a>获取，这是一个通用的内核，里面包含着内核支持的所有的硬件平台及驱动的所有代码，是一个大而全的内核源代码。</p>\n<p>在使用层面上，当嵌入式平台使用 linux 系统，那么最重要的就是 kernel 中驱动的移植；一般都不会从一个纯净的 kernel 中去进行移植操作，而是根据芯片厂商提供的 kernel 对特定的硬件平台及设备进行各种外设驱动相关的适配工作。</p>\n<h2 id=\"device-tree\"><a class=\"anchor\" href=\"#device-tree\">#</a> Device Tree</h2>\n<p>设备树（Device Tree）是描述计算机的特定硬件设备信息的数据结构，以便于操作系统的内核可以管理和使用这些硬件，包括 CPU 或 CPU，内存，总线和其他一些外设。</p>\n<p>老版本的 linux kernel 是没有设备树概念的，后来因为 SOC 的发展，kernel 中需要对这些新增的 SOC 进行支持，而这些代码都会编译到 kernel 中，会导致 kernel 日渐臃肿，于是后面就引入了在 PowerPC 等架构就已经采用的设备树。</p>\n<p><strong>1、dts (device tree source 设备树源文件)</strong><br />\n dts 文件是一种 ASCII 文本格式的设备树描述文件，此文件适合人类阅读主要是给用户看的。一个  <code>.dts</code>  文件对应一个 ARM 的设备，一般放置在  <code>arch/arm/boot/dts/</code>  中。</p>\n<p><strong>2、dtsi (device tree source include 设备树头文件)</strong><br />\n 由于  <code>.dts</code>  中包含了很多公共部分，linux 内核为了简化，将 Soc 公共部分提炼为  <code>.dtsi</code>  文件，类似 c 语言中的  <code>.h</code>  文件。当然，和 C 语言的头文件类似，.dtsi 也可以 include 其他的  <code>.dtsi</code>  ，譬如几乎所有的 ARM SoC 的  <code>.dtsi</code>  都引用了 <code>skeleton.dtsi</code>  。对于同一个节点的设置情况， <code>.dts</code>  中的配置会覆盖  <code>.dtsi</code>  中的配置；因此， <code>.dtsi</code>  一般写 Soc 共性部分，而  <code>.dts</code>  一般写目标单板特性部分，所以一般  <code>.dts</code>  包含并重写部分  <code>.dtsi</code> 。</p>\n<p><strong>3、dtb (device tree blob 设备树二进制文件)</strong><br />\n <code>.dts</code>  通过 dtc 编译工具编译成  <code>.dtb</code>  文件，被编译后的设备树文件与内核一同放入到存储介质中，当内核启动时读取设备树文件，就可以动态的将板级信息写入到内核中。</p>\n<h1 id=\"rootfs\"><a class=\"anchor\" href=\"#rootfs\">#</a> rootfs</h1>\n<p>rootfs（Root Filesystem）即根目录文件系统，是 kernel 启动后挂载的第一个文件系统。rootfs 和 kernel 是分开的，但单独的 kernel 没有 rootfs 是没法正常工作的。在系统终端执行  <code>cd /</code>  即可看到当前的文件系统内容了。</p>\n<p>现在有许多制作 rootfs 的工具，如 busybox，buildroot，Yocto 等。其中 buildroot 中包含了 busybox 的功能，只需要简单的操作就可以生成一个 rootfs 了。</p>\n<h1 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h1>\n<p><a href=\"https://q248269673.pixnet.net/blog/post/69570279\">完整的 linux 系統：bootloader、linux kernel（linux 內核）、rootfile（根文件系統）</a></p>\n<p><a href=\"http://www.embeddedlinux.org.cn/emblinuxappdev/\">嵌入式 linux 应用开发</a></p>\n<p><a href=\"https://hackmd.io/@a29654068/HJ1uUYE8r\">Linux 筆記 2</a></p>\n<p><a href=\"https://stackoverflow.com/questions/48420126/what-is-the-difference-between-dts-file-and-dtsi-file\">What is the difference between .dts file and .dtsi file?</a></p>\n",
            "tags": [
                "Linux"
            ]
        },
        {
            "id": "https://arachnid.cc/ubuntu-ftp-create/",
            "url": "https://arachnid.cc/ubuntu-ftp-create/",
            "title": "Ubuntu下 FTP的搭建配置",
            "date_published": "2022-11-03T13:13:57.653Z",
            "content_html": "<blockquote>\n<p>平台：Ubuntu 18.04.6</p>\n<p>vsftpd 官网：<a href=\"https://security.appspot.com/vsftpd.html\">https://security.appspot.com/vsftpd.html</a></p>\n</blockquote>\n<h1 id=\"安装\"><a class=\"anchor\" href=\"#安装\">#</a> 安装</h1>\n<p>安装 FTP 服务，命令行输入：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> vsftpd</pre></td></tr></table></figure><h1 id=\"配置\"><a class=\"anchor\" href=\"#配置\">#</a> 配置</h1>\n<p>先备份配置文件：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">cp</span> /etc/vsftpd.conf /etc/vsftpd.conf.back</pre></td></tr></table></figure><p>vim 进入编辑信息：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> <span class=\"token function\">vim</span> /etc/vsftpd.conf</pre></td></tr></table></figure><p>然后增加或修改以下信息：</p>\n<figure class=\"highlight makefile\"><figcaption data-lang=\"makefile\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\"># Example config file /etc/vsftpd.conf</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">#</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token comment\"># The default compiled in settings are fairly paranoid. This sample file</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token comment\"># loosens things up a bit, to make the ftp daemon more usable.</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\"># Please see vsftpd.conf.5 for all compiled in defaults.</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token comment\">#</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\"># READ THIS: This example file is NOT an exhaustive list of vsftpd options.</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token comment\"># Please read the vsftpd.conf.5 manual page to get a full idea of vsftpd's</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre><span class=\"token comment\"># capabilities.</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre><span class=\"token comment\">#</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre><span class=\"token comment\">#</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token comment\"># Run standalone?  vsftpd can run either from an inetd or as a standalone</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token comment\"># daemon started from an initscript.</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>listen<span class=\"token operator\">=</span>NO <span class=\"token comment\">#是否开启侦听状态</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token comment\"># This directive enables listening on IPv6 sockets. By default, listening</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre><span class=\"token comment\"># on the IPv6 \"any\" address (::) will accept connections from both IPv6</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token comment\"># and IPv4 clients. It is not necessary to listen on *both* IPv4 and IPv6</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token comment\"># sockets. If you want that (perhaps because you want to listen on specific</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre><span class=\"token comment\"># addresses) then you must run two copies of vsftpd with two configuration</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token comment\"># files.</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>listen_ipv6<span class=\"token operator\">=</span>YES <span class=\"token comment\">#如果能使用 ipv6 的可以打开使用；只能用 ipv4 的必须注释掉，不然重启不了</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre></pre></td></tr><tr><td data-num=\"24\"></td><td><pre><span class=\"token comment\"># Allow anonymous FTP? (Disabled by default).</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>anonymous_enable<span class=\"token operator\">=</span>YES <span class=\"token comment\">#允许匿名用户登录</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token comment\"># Uncomment this to allow local users to log in.</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre>local_enable<span class=\"token operator\">=</span>YES <span class=\"token comment\">#允许实名登录</span></pre></td></tr><tr><td data-num=\"29\"></td><td><pre></pre></td></tr><tr><td data-num=\"30\"></td><td><pre><span class=\"token comment\"># Uncomment this to enable any form of FTP write command.</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>write_enable<span class=\"token operator\">=</span>YES <span class=\"token comment\">#允许实名用户进行写操作</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre></pre></td></tr><tr><td data-num=\"33\"></td><td><pre><span class=\"token comment\"># Default umask for local users is 077. You may wish to change this to 022,</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre><span class=\"token comment\"># if your users expect that (022 is used by most other ftpd's)</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre><span class=\"token comment\">#local_umask=022</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre></pre></td></tr><tr><td data-num=\"37\"></td><td><pre><span class=\"token comment\"># Uncomment this to allow the anonymous FTP user to upload files. This only</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre><span class=\"token comment\"># has an effect if the above global write enable is activated. Also, you will</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre><span class=\"token comment\"># obviously need to create a directory writable by the FTP user.</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>anon_upload_enable<span class=\"token operator\">=</span>YES <span class=\"token comment\">#允许匿名用户上传文件</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre></pre></td></tr><tr><td data-num=\"42\"></td><td><pre><span class=\"token comment\"># Uncomment this if you want the anonymous FTP user to be able to create</span></pre></td></tr><tr><td data-num=\"43\"></td><td><pre><span class=\"token comment\"># new directories.</span></pre></td></tr><tr><td data-num=\"44\"></td><td><pre>anon_mkdir_write_enable<span class=\"token operator\">=</span>YES <span class=\"token comment\">#允许匿名用户创建目录</span></pre></td></tr><tr><td data-num=\"45\"></td><td><pre></pre></td></tr><tr><td data-num=\"46\"></td><td><pre><span class=\"token comment\"># Activate directory messages - messages given to remote users when they</span></pre></td></tr><tr><td data-num=\"47\"></td><td><pre><span class=\"token comment\"># go into a certain directory.</span></pre></td></tr><tr><td data-num=\"48\"></td><td><pre>dirmessage_enable<span class=\"token operator\">=</span>YES</pre></td></tr><tr><td data-num=\"49\"></td><td><pre></pre></td></tr><tr><td data-num=\"50\"></td><td><pre><span class=\"token comment\"># If enabled, vsftpd will display directory listings with the time</span></pre></td></tr><tr><td data-num=\"51\"></td><td><pre><span class=\"token comment\"># in  your  local  time  zone.  The default is to display GMT. The</span></pre></td></tr><tr><td data-num=\"52\"></td><td><pre><span class=\"token comment\"># times returned by the MDTM FTP command are also affected by this</span></pre></td></tr><tr><td data-num=\"53\"></td><td><pre><span class=\"token comment\"># option.</span></pre></td></tr><tr><td data-num=\"54\"></td><td><pre>use_localtime<span class=\"token operator\">=</span>YES</pre></td></tr><tr><td data-num=\"55\"></td><td><pre></pre></td></tr><tr><td data-num=\"56\"></td><td><pre><span class=\"token comment\"># Activate logging of uploads/downloads.</span></pre></td></tr><tr><td data-num=\"57\"></td><td><pre>xferlog_enable<span class=\"token operator\">=</span>YES</pre></td></tr><tr><td data-num=\"58\"></td><td><pre></pre></td></tr><tr><td data-num=\"59\"></td><td><pre><span class=\"token comment\"># Make sure PORT transfer connections originate from port 20 (ftp-data).</span></pre></td></tr><tr><td data-num=\"60\"></td><td><pre>connect_from_port_20<span class=\"token operator\">=</span>YES</pre></td></tr><tr><td data-num=\"61\"></td><td><pre></pre></td></tr><tr><td data-num=\"62\"></td><td><pre><span class=\"token comment\"># If you want, you can arrange for uploaded anonymous files to be owned by</span></pre></td></tr><tr><td data-num=\"63\"></td><td><pre><span class=\"token comment\"># a different user. Note! Using \"root\" for uploaded files is not</span></pre></td></tr><tr><td data-num=\"64\"></td><td><pre><span class=\"token comment\"># recommended!</span></pre></td></tr><tr><td data-num=\"65\"></td><td><pre><span class=\"token comment\">#chown_uploads=YES</span></pre></td></tr><tr><td data-num=\"66\"></td><td><pre><span class=\"token comment\">#chown_username=whoever</span></pre></td></tr><tr><td data-num=\"67\"></td><td><pre></pre></td></tr><tr><td data-num=\"68\"></td><td><pre><span class=\"token comment\"># You may override where the log file goes if you like. The default is shown</span></pre></td></tr><tr><td data-num=\"69\"></td><td><pre><span class=\"token comment\"># below.</span></pre></td></tr><tr><td data-num=\"70\"></td><td><pre><span class=\"token comment\">#xferlog_file=/var/log/vsftpd.log</span></pre></td></tr><tr><td data-num=\"71\"></td><td><pre></pre></td></tr><tr><td data-num=\"72\"></td><td><pre><span class=\"token comment\"># If you want, you can have your log file in standard ftpd xferlog format.</span></pre></td></tr><tr><td data-num=\"73\"></td><td><pre><span class=\"token comment\"># Note that the default log file location is /var/log/xferlog in this case.</span></pre></td></tr><tr><td data-num=\"74\"></td><td><pre><span class=\"token comment\">#xferlog_std_format=YES</span></pre></td></tr><tr><td data-num=\"75\"></td><td><pre></pre></td></tr><tr><td data-num=\"76\"></td><td><pre><span class=\"token comment\"># You may change the default value for timing out an idle session.</span></pre></td></tr><tr><td data-num=\"77\"></td><td><pre><span class=\"token comment\">#idle_session_timeout=600</span></pre></td></tr><tr><td data-num=\"78\"></td><td><pre></pre></td></tr><tr><td data-num=\"79\"></td><td><pre><span class=\"token comment\"># You may change the default value for timing out a data connection.</span></pre></td></tr><tr><td data-num=\"80\"></td><td><pre><span class=\"token comment\">#data_connection_timeout=120</span></pre></td></tr><tr><td data-num=\"81\"></td><td><pre></pre></td></tr><tr><td data-num=\"82\"></td><td><pre><span class=\"token comment\"># It is recommended that you define on your system a unique user which the</span></pre></td></tr><tr><td data-num=\"83\"></td><td><pre><span class=\"token comment\"># ftp server can use as a totally isolated and unprivileged user.</span></pre></td></tr><tr><td data-num=\"84\"></td><td><pre><span class=\"token comment\">#nopriv_user=ftpsecure</span></pre></td></tr><tr><td data-num=\"85\"></td><td><pre></pre></td></tr><tr><td data-num=\"86\"></td><td><pre><span class=\"token comment\"># Enable this and the server will recognise asynchronous ABOR requests. Not</span></pre></td></tr><tr><td data-num=\"87\"></td><td><pre><span class=\"token comment\"># recommended for security (the code is non-trivial). Not enabling it,</span></pre></td></tr><tr><td data-num=\"88\"></td><td><pre><span class=\"token comment\"># however, may confuse older FTP clients.</span></pre></td></tr><tr><td data-num=\"89\"></td><td><pre><span class=\"token comment\">#async_abor_enable=YES</span></pre></td></tr><tr><td data-num=\"90\"></td><td><pre></pre></td></tr><tr><td data-num=\"91\"></td><td><pre><span class=\"token comment\"># By default the server will pretend to allow ASCII mode but in fact ignore</span></pre></td></tr><tr><td data-num=\"92\"></td><td><pre><span class=\"token comment\"># the request. Turn on the below options to have the server actually do ASCII</span></pre></td></tr><tr><td data-num=\"93\"></td><td><pre><span class=\"token comment\"># mangling on files when in ASCII mode.</span></pre></td></tr><tr><td data-num=\"94\"></td><td><pre><span class=\"token comment\"># Beware that on some FTP servers, ASCII support allows a denial of service</span></pre></td></tr><tr><td data-num=\"95\"></td><td><pre><span class=\"token comment\"># attack (DoS) via the command \"SIZE /big/file\" in ASCII mode. vsftpd</span></pre></td></tr><tr><td data-num=\"96\"></td><td><pre><span class=\"token comment\"># predicted this attack and has always been safe, reporting the size of the</span></pre></td></tr><tr><td data-num=\"97\"></td><td><pre><span class=\"token comment\"># raw file.</span></pre></td></tr><tr><td data-num=\"98\"></td><td><pre><span class=\"token comment\"># ASCII mangling is a horrible feature of the protocol.</span></pre></td></tr><tr><td data-num=\"99\"></td><td><pre><span class=\"token comment\">#ascii_upload_enable=YES</span></pre></td></tr><tr><td data-num=\"100\"></td><td><pre><span class=\"token comment\">#ascii_download_enable=YES</span></pre></td></tr><tr><td data-num=\"101\"></td><td><pre></pre></td></tr><tr><td data-num=\"102\"></td><td><pre><span class=\"token comment\"># You may fully customise the login banner string:</span></pre></td></tr><tr><td data-num=\"103\"></td><td><pre><span class=\"token comment\">#ftpd_banner=Welcome to blah FTP service.</span></pre></td></tr><tr><td data-num=\"104\"></td><td><pre></pre></td></tr><tr><td data-num=\"105\"></td><td><pre><span class=\"token comment\"># You may specify a file of disallowed anonymous e-mail addresses. Apparently</span></pre></td></tr><tr><td data-num=\"106\"></td><td><pre><span class=\"token comment\"># useful for combatting certain DoS attacks.</span></pre></td></tr><tr><td data-num=\"107\"></td><td><pre><span class=\"token comment\">#deny_email_enable=YES</span></pre></td></tr><tr><td data-num=\"108\"></td><td><pre><span class=\"token comment\"># (default follows)</span></pre></td></tr><tr><td data-num=\"109\"></td><td><pre><span class=\"token comment\">#banned_email_file=/etc/vsftpd.banned_emails</span></pre></td></tr><tr><td data-num=\"110\"></td><td><pre></pre></td></tr><tr><td data-num=\"111\"></td><td><pre><span class=\"token comment\"># You may restrict local users to their home directories.  See the FAQ for</span></pre></td></tr><tr><td data-num=\"112\"></td><td><pre><span class=\"token comment\"># the possible risks in this before using chroot_local_user or</span></pre></td></tr><tr><td data-num=\"113\"></td><td><pre><span class=\"token comment\"># chroot_list_enable below.</span></pre></td></tr><tr><td data-num=\"114\"></td><td><pre>chroot_local_user<span class=\"token operator\">=</span>YES <span class=\"token comment\">#用户访问将被限制在当前目录</span></pre></td></tr><tr><td data-num=\"115\"></td><td><pre></pre></td></tr><tr><td data-num=\"116\"></td><td><pre><span class=\"token comment\"># You may specify an explicit list of local users to chroot() to their home</span></pre></td></tr><tr><td data-num=\"117\"></td><td><pre><span class=\"token comment\"># directory. If chroot_local_user is YES, then this list becomes a list of</span></pre></td></tr><tr><td data-num=\"118\"></td><td><pre><span class=\"token comment\"># users to NOT chroot().</span></pre></td></tr><tr><td data-num=\"119\"></td><td><pre><span class=\"token comment\"># (Warning! chroot'ing can be very dangerous. If using chroot, make sure that</span></pre></td></tr><tr><td data-num=\"120\"></td><td><pre><span class=\"token comment\"># the user does not have write access to the top level directory within the</span></pre></td></tr><tr><td data-num=\"121\"></td><td><pre><span class=\"token comment\"># chroot)</span></pre></td></tr><tr><td data-num=\"122\"></td><td><pre><span class=\"token comment\">#chroot_local_user=YES</span></pre></td></tr><tr><td data-num=\"123\"></td><td><pre><span class=\"token comment\">#chroot_list_enable=YES</span></pre></td></tr><tr><td data-num=\"124\"></td><td><pre><span class=\"token comment\"># (default follows)</span></pre></td></tr><tr><td data-num=\"125\"></td><td><pre><span class=\"token comment\">#chroot_list_file=/etc/vsftpd.chroot_list</span></pre></td></tr><tr><td data-num=\"126\"></td><td><pre></pre></td></tr><tr><td data-num=\"127\"></td><td><pre><span class=\"token comment\"># You may activate the \"-R\" option to the builtin ls. This is disabled by</span></pre></td></tr><tr><td data-num=\"128\"></td><td><pre><span class=\"token comment\"># default to avoid remote users being able to cause excessive I/O on large</span></pre></td></tr><tr><td data-num=\"129\"></td><td><pre><span class=\"token comment\"># sites. However, some broken FTP clients such as \"ncftp\" and \"mirror\" assume</span></pre></td></tr><tr><td data-num=\"130\"></td><td><pre><span class=\"token comment\"># the presence of the \"-R\" option, so there is a strong case for enabling it.</span></pre></td></tr><tr><td data-num=\"131\"></td><td><pre><span class=\"token comment\">#ls_recurse_enable=YES</span></pre></td></tr><tr><td data-num=\"132\"></td><td><pre></pre></td></tr><tr><td data-num=\"133\"></td><td><pre><span class=\"token comment\"># Customization</span></pre></td></tr><tr><td data-num=\"134\"></td><td><pre><span class=\"token comment\">#</span></pre></td></tr><tr><td data-num=\"135\"></td><td><pre><span class=\"token comment\"># Some of vsftpd's settings don't fit the filesystem layout by</span></pre></td></tr><tr><td data-num=\"136\"></td><td><pre><span class=\"token comment\"># default.</span></pre></td></tr><tr><td data-num=\"137\"></td><td><pre><span class=\"token comment\">#</span></pre></td></tr><tr><td data-num=\"138\"></td><td><pre><span class=\"token comment\"># This option should be the name of a directory which is empty.  Also, the</span></pre></td></tr><tr><td data-num=\"139\"></td><td><pre><span class=\"token comment\"># directory should not be writable by the ftp user. This directory is used</span></pre></td></tr><tr><td data-num=\"140\"></td><td><pre><span class=\"token comment\"># as a secure chroot() jail at times vsftpd does not require filesystem</span></pre></td></tr><tr><td data-num=\"141\"></td><td><pre><span class=\"token comment\"># access.</span></pre></td></tr><tr><td data-num=\"142\"></td><td><pre>secure_chroot_dir<span class=\"token operator\">=</span>/var/run/vsftpd/empty</pre></td></tr><tr><td data-num=\"143\"></td><td><pre></pre></td></tr><tr><td data-num=\"144\"></td><td><pre><span class=\"token comment\"># This string is the name of the PAM service vsftpd will use.</span></pre></td></tr><tr><td data-num=\"145\"></td><td><pre>pam_service_name<span class=\"token operator\">=</span>vsftpd</pre></td></tr><tr><td data-num=\"146\"></td><td><pre></pre></td></tr><tr><td data-num=\"147\"></td><td><pre><span class=\"token comment\"># This option specifies the location of the RSA certificate to use for SSL</span></pre></td></tr><tr><td data-num=\"148\"></td><td><pre><span class=\"token comment\"># encrypted connections.</span></pre></td></tr><tr><td data-num=\"149\"></td><td><pre>rsa_cert_file<span class=\"token operator\">=</span>/etc/ssl/certs/ssl-cert-snakeoil.pem</pre></td></tr><tr><td data-num=\"150\"></td><td><pre>rsa_private_key_file<span class=\"token operator\">=</span>/etc/ssl/<span class=\"token keyword\">private</span>/ssl-cert-snakeoil.key</pre></td></tr><tr><td data-num=\"151\"></td><td><pre>ssl_enable<span class=\"token operator\">=</span>NO</pre></td></tr><tr><td data-num=\"152\"></td><td><pre></pre></td></tr><tr><td data-num=\"153\"></td><td><pre></pre></td></tr><tr><td data-num=\"154\"></td><td><pre><span class=\"token comment\"># Uncomment this to indicate that vsftpd use a utf8 filesystem.</span></pre></td></tr><tr><td data-num=\"155\"></td><td><pre>utf8_filesystem<span class=\"token operator\">=</span>YES</pre></td></tr><tr><td data-num=\"156\"></td><td><pre></pre></td></tr><tr><td data-num=\"157\"></td><td><pre></pre></td></tr><tr><td data-num=\"158\"></td><td><pre>no_anon_password<span class=\"token operator\">=</span>YES <span class=\"token comment\">#匿名登录是否需要密码</span></pre></td></tr><tr><td data-num=\"159\"></td><td><pre>anon_root<span class=\"token operator\">=</span>/home/frd_lzy <span class=\"token comment\">#匿名登录访问的文件路径</span></pre></td></tr><tr><td data-num=\"160\"></td><td><pre></pre></td></tr><tr><td data-num=\"161\"></td><td><pre>local_root<span class=\"token operator\">=</span>/projects <span class=\"token comment\">#实名登录访问的文件路径</span></pre></td></tr><tr><td data-num=\"162\"></td><td><pre></pre></td></tr><tr><td data-num=\"163\"></td><td><pre>allow_writeable_chroot<span class=\"token operator\">=</span>YES</pre></td></tr></table></figure><p>编辑完成后， <code>:wq</code>  保存退出。</p>\n<h1 id=\"重新加载配置文件\"><a class=\"anchor\" href=\"#重新加载配置文件\">#</a> 重新加载配置文件</h1>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> /etc/init.d/vsftpd restart</pre></td></tr></table></figure><h1 id=\"启动服务\"><a class=\"anchor\" href=\"#启动服务\">#</a> 启动服务</h1>\n<p>在加载完后，重启服务器：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> systemctl restart vsftpd</pre></td></tr></table></figure><p>查看服务启动状态：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> systemctl status vsftpd</pre></td></tr></table></figure><p><img src=\"image-20221106152005206.png\" alt=\"image-20221106152005206\" /></p>\n<p>设置开机启动：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> systemctl <span class=\"token builtin class-name\">enable</span> vsftpd</pre></td></tr></table></figure><p>如果想关闭开机启动：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">sudo</span> systemctl disable vsftpd</pre></td></tr></table></figure><h1 id=\"ftp连接\"><a class=\"anchor\" href=\"#ftp连接\">#</a> FTP 连接</h1>\n<p>本机连接：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">ftp</span> <span class=\"token number\">127.0</span>.0.1</pre></td></tr></table></figure><p>其它电脑连接：</p>\n<figure class=\"highlight shell\"><figcaption data-lang=\"Bash\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">ftp</span> <span class=\"token function\">ip</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\"># eg:ftp 192.168.0.3</span></pre></td></tr></table></figure><p>1、输入用户名：（1）匿名：anonymous 或 ftp （2）主机用户名：即你当前主机名。</p>\n<p>2、回车。</p>\n<p>3、如果需要密码则进行相应输入，这里上面配置设了匿名登录不需要密码，所以以匿名登录时没有提示输入密码。</p>\n<p>4、进入到相应的用户访问根目录里（ps：即进入到配置文件中设置的登录访问的文件路径，可以用  <code>ls</code>  查看是否对应上访问的文件目录），这样就可以愉快的玩耍了；输入：  <code>quit</code>  退出。</p>\n<p>eg：本地连接并退出，如下图：</p>\n<p><img src=\"image-20221106164252568.png\" alt=\"image-20221106164252568\" /></p>\n<p>windows 下可视化文件访问：按  <code>Win</code>  +  <code>E</code>  快捷键，调用文件资源管理器，输入访问地址，回车：</p>\n<p><img src=\"image-20221106160826118.png\" alt=\"image-20221106160826118\" /></p>\n<p>windows 下命令行文件访问：同样按  <code>Win</code>  +  <code>E</code>  快捷键，调用文件资源管理器，然后在输写框跟上面 linux 访问连接一样输入  <code>ftp ip</code>  ，即可跳到 ftp 操作控制台中：</p>\n<p><img src=\"image-20221106161411644.png\" alt=\"image-20221106161411644\" /></p>\n<h1 id=\"ftp客户端常用命令\"><a class=\"anchor\" href=\"#ftp客户端常用命令\">#</a> FTP 客户端常用命令</h1>\n<p>在登录进入 ftp 后，可以使用  <code>help</code>  查看可以使用哪些指令操作：</p>\n<p><img src=\"image-20221106163512272.png\" alt=\"image-20221106163512272\" /></p>\n<ul>\n<li>\n<p>ls：和 linux 上的 ls 命令类似</p>\n</li>\n<li>\n<p>Ctrl+Shift + L：清屏</p>\n</li>\n<li>\n<p>put：使用  <code>put [本地文件路径+名称]</code>  上传</p>\n</li>\n<li>\n<p>get：使用  <code>get [远程文件路径+名称]</code>  下载</p>\n</li>\n<li>\n<p>mput：批量上传多个文件  <code>mput 文件名1 文件名2</code></p>\n</li>\n<li>\n<p>mget：批量获取多个文件  <code>mget 文件名1 文件名2</code></p>\n</li>\n<li>\n<p>prompt：屏蔽批量输出信息，批量上传下载文件就不需要一直回车确认了</p>\n</li>\n<li>\n<p>quit：退出 ftp 访问</p>\n</li>\n</ul>\n",
            "tags": [
                "history",
                "Linux",
                "Ubuntu"
            ]
        },
        {
            "id": "https://arachnid.cc/arch-linux-install/",
            "url": "https://arachnid.cc/arch-linux-install/",
            "title": "基于官方指导安装 Arch Linux",
            "date_published": "2022-04-12T03:02:19.000Z",
            "content_html": "<blockquote>\n<p>官方 wiki 安装中文指导：<a href=\"https://wiki.archlinux.org/title/Installation_guide_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)\">https://wiki.archlinux.org/title/Installation_guide_(简体中文)</a></p>\n<p>最好还是以<strong>英文版</strong>的为基准，因为 ArchLinux 是一个激进的系统，更新比较快，可能刚写完这篇笔记，转头已经有些对应不上了，哈哈哈。</p>\n</blockquote>\n<h2 id=\"系统镜像\"><a class=\"anchor\" href=\"#系统镜像\">#</a> 系统镜像</h2>\n<p>官方镜像下载地址：<a href=\"https://archlinux.org/download/\">https://archlinux.org/download/</a></p>\n<p>当然，也可以去各大高校提供的镜像源网站下载。</p>\n<h2 id=\"启动盘制作\"><a class=\"anchor\" href=\"#启动盘制作\">#</a> 启动盘制作</h2>\n<p><strong>1、windows 平台</strong></p>\n<p>可以使用 Rufus：<a href=\"https://rufus.ie/zh/\">https://rufus.ie/zh/</a></p>\n<p>这是一款开源、免费、小巧（1.1mb）纯粹的系统启动盘制作工具。<br />\n目前所支持的 ISO 镜像如下：</p>\n<p><img src=\"image-20220412112425056.png\" alt=\"image-20220412112425056\" /></p>\n<p><strong>2、Uinx 平台</strong></p>\n<p>类 Unix 系统可以直接使用  <code>dd</code>  命令来制作启动盘。</p>\n<p><code>dd</code>  命令使用可参考：<a href=\"https://www.runoob.com/linux/linux-comm-dd.html\">https://www.runoob.com/linux/linux-comm-dd.html</a></p>\n<p><strong>3、多平台</strong></p>\n<p>可以使用开源的 etcher：<a href=\"https://www.balena.io/etcher/\">https://www.balena.io/etcher/</a></p>\n<blockquote>\n<p>然后本篇文章是基于官方指导的总结分析安装的笔记，如下开始正式安装配置，因为是以官方 wiki 安装为指导，所以下面用到的操作的标题将一一对应官方 wiki 的标题，没用到的将忽略不写，以及需要增加的将给出说明。目前使用的镜像版本： <code>archlinux-2022.04.01-x86_64.iso</code></p>\n</blockquote>\n<h2 id=\"引导安装\"><a class=\"anchor\" href=\"#引导安装\">#</a> 引导安装</h2>\n<p>Arch 的启动引导过程有两种：<a href=\"https://en.wikipedia.org/wiki/BIOS\">BIOS</a> 和 <a href=\"https://wiki.archlinux.org/title/UEFI\">UEFI</a> 系统，这两者的引导过程是完全不同的。在 Arch 中它们的引导加载及区别可看：<a href=\"https://wiki.archlinux.org/title/Arch_boot_process\">https://wiki.archlinux.org/title/Arch_boot_process</a></p>\n<p>目前大部分设备的引导方式主要分为  <code>UEFI 引导 + GPT 分区表</code>  和  <code>BIOS(LEGACY) 引导 + MBR 分区表</code>  这两种，而在新的机器里大部分都采用了  <code>UEFI/GPT</code>  引导的方式，当然，同时也兼容  <code>BIOS/MBR</code>  。</p>\n<p>UEFI 进入：</p>\n<p><img src=\"image-20220412115757611.png\" alt=\"image-20220412115757611\" /></p>\n<p>BIOS 进入：</p>\n<p><img src=\"image-20220412120426116.png\" alt=\"image-20220412120426116\" /></p>\n<p>启动安装后，最终界面出现的效果是一样的：</p>\n<p><img src=\"image-20220412153955531.png\" alt=\"image-20220412153955531\" /></p>\n<h2 id=\"验证引导模式\"><a class=\"anchor\" href=\"#验证引导模式\">#</a> 验证引导模式</h2>\n<p>键入如下命令：（ <code>ls</code> ：表示列出目录内容；后面的路径可以利用 Tab 键 自动补全，即键入命令或文件名的前几个字符，然后按 [Tab] 键）</p>\n<pre><code>ls /sys/firmware/efi/efivars\n</code></pre>\n<p>如果命令结果显示了目录且没有报告错误，则系统以 UEFI 模式引导。</p>\n<p>如果目录不存在，则系统可能 <strong>（注意是可能，并不一定确是 BIOS 模式）</strong> 以 <a href=\"https://en.wikipedia.org/wiki/zh:BIOS\">BIOS</a> 模式 (或 <a href=\"https://en.wikipedia.org/wiki/Compatibility_Support_Module\">CSM</a> 模式) 引导，如显示：</p>\n<pre><code>ls: cannot access '/sys/firmware/efi/efivars': No such file or directory\n</code></pre>\n<p>对于一些不是新的 / 格式过的磁盘，可能就不太适用了，当然，最好方法就是查看安装的主分区磁盘的属性。</p>\n<h2 id=\"连接到因特网\"><a class=\"anchor\" href=\"#连接到因特网\">#</a> 连接到因特网</h2>\n<p>1、检查网络接口是否启用</p>\n<pre><code>ip link\n</code></pre>\n<p>2、连接到网络</p>\n<ul>\n<li>有线：连接网线，并保证上级路由有网。</li>\n<li>无线：使用 <a href=\"https://wiki.archlinux.org/title/Iwd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#iwctl\">iwctl</a> 验证无线网络，具体操作点击链接查看。</li>\n</ul>\n<p>3、配置网络连接</p>\n<ul>\n<li>\n<p>动态：需要支持 DHCP，然后执行以下命令。</p>\n<pre><code>dhcpcd\n</code></pre>\n</li>\n<li>\n<p>静态：直接按照 <a href=\"https://wiki.archlinux.org/title/Network_configuration_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E9%9D%99%E6%80%81_IP_%E5%9C%B0%E5%9D%80\">静态 IP 地址</a> 这个链接进行操作。</p>\n</li>\n</ul>\n<p>4、检查网络连接</p>\n<p>在确认无误完成上面的操作后，通过 PING IP 来检查：</p>\n<pre><code>ping archlinux.org\n</code></pre>\n<p><strong>note：</strong> 关于网络部分的，详情请看 <a href=\"https://wiki.archlinux.org/title/Network_configuration\">https://wiki.archlinux.org/title/Network_configuration</a></p>\n<h2 id=\"更新系统时间\"><a class=\"anchor\" href=\"#更新系统时间\">#</a> 更新系统时间</h2>\n<p>执行：</p>\n<pre><code>timedatectl set-ntp true\n</code></pre>\n<p>然后正常情况下是并没有输出的，所谓没有消息就是最好的消息，这就是 Linux/Unix 系统的设计思想。</p>\n<p>最后，执行如下命令来检查服务状态：</p>\n<pre><code>timedatectl status\n</code></pre>\n<h2 id=\"建立硬盘分区\"><a class=\"anchor\" href=\"#建立硬盘分区\">#</a> 建立硬盘分区</h2>\n<p>系统如果识别到磁盘，就会将其分配为一个块设备，如  <code>/dev/sda</code> 、 <code>/dev/nvme0n1</code>  或  <code>/dev/mmcblk0</code>  等等。然后可以执行如下命令查看：</p>\n<pre><code>fdisk -l\n</code></pre>\n<p>然后，针对不同的引导方式，其分区布局是不一样的，以官方给出的分区为例：</p>\n<ul>\n<li>\n<p><strong>UEFI 与</strong> <a href=\"https://wiki.archlinux.org/title/Partitioning_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#GUID_%E5%88%86%E5%8C%BA%E8%A1%A8\">GPT</a></p>\n<table>\n<thead>\n<tr>\n<th>挂载点</th>\n<th>分区</th>\n<th>分区类型</th>\n<th>建议大小</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/mnt/boot</td>\n<td>/dev/<em>efi_system_partition</em></td>\n<td>EFI 系统分区</td>\n<td>至少 300 MiB</td>\n</tr>\n<tr>\n<td>[SWAP]</td>\n<td>/dev/<em>swap_partition</em></td>\n<td>Linux swap (交换空间)</td>\n<td>大于 512 MiB</td>\n</tr>\n<tr>\n<td>/mnt</td>\n<td>/dev/<em>root_partition</em></td>\n<td>Linux x86-64 根目录 (/)</td>\n<td>剩余空间</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p><strong>BIOS 与</strong> <a href=\"https://wiki.archlinux.org/title/Partitioning_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#Master_Boot_Record\">MBR</a></p>\n<table>\n<thead>\n<tr>\n<th>挂载点</th>\n<th>分区</th>\n<th>分区类型</th>\n<th>建议大小</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[SWAP]</td>\n<td>/dev/<em>swap_partition</em></td>\n<td>Linux swap (交换空间)</td>\n<td>大于 512 MiB</td>\n</tr>\n<tr>\n<td>/mnt</td>\n<td>/dev/<em>root_partition</em></td>\n<td>Linux x86-64 根目录 (/)</td>\n<td>剩余空间</td>\n</tr>\n</tbody>\n</table>\n<p>然后在这里拓展一下  <code>MiB</code>  跟  <code>MB</code>  这两个单位， <code>MB</code>  是国际单位制 SI 制定的十进制标准单位制，这个 M 是 1000K，而  <code>MiB</code>  是国际电工委员会 IEC 制定的二进制标准，这个 M 是 1024K 。参看：<a href=\"https://physics.nist.gov/cuu/Units/binary.html\">https://physics.nist.gov/cuu/Units/binary.html</a></p>\n</li>\n<li>\n<p>其它的布局实例可看：<a href=\"https://wiki.archlinux.org/title/Partitioning_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%B8%83%E5%B1%80%E7%A4%BA%E4%BE%8B\">https://wiki.archlinux.org/title/Partitioning_(简体中文)# 布局示例</a></p>\n</li>\n</ul>\n<p>在了解上面的布局后，然后我们常用的引导方式有  <code>UEFI 引导 + GPT 分区表</code>  和  <code>BIOS(LEGACY) 引导 + MBR 分区表</code>  这两种，所以下面分开说明：</p>\n<ol>\n<li>\n<p><strong>BIOS/MBR</strong></p>\n<p>这种方式相对于另一种比较简单，所以就先说了。</p>\n<p>首先，先来了解一下  <code>[SWAP]</code>  挂载点和  <code>/mnt</code>  挂载点：</p>\n<ul>\n<li>\n<p><code>[SWAP]</code> ：swap 分区通常被称为交换分区，这是一块特殊的硬盘空间，即当实际内存（物理内存，可以理解为内存条容量）不够用的时候，操作系统会从内存中取出一部分暂时不用的数据，放在交换分区中，从而为当前运行的程序腾出足够的内存空间（有点类似于 windows 系统下的虚拟内存）。也就是说，当内存不够用时，我们使用 swap 分区来临时顶替，等到那些程序要运行时，再从 swap 中恢复保存的数据到内存中。这种 “拆东墙，补西墙” 的方式应用于几乎所有的操作系统中。</p>\n<p>使用 swap 交换分区，显著的优点是，通过操作系统的调度，应用程序实际可以使用的内存空间将远远超过系统的物理内存。</p>\n<p>那么 swap 分区到底设置成多大才最优？少了又觉得不够，多了又感觉浪费，那么我们可以参考 Redhat 官方文档中 <a href=\"https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/installation_guide/s2-diskpartrecommend-ppc#id4394007\">关于 swap 分区大小设置的建议</a>：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">物理内存</th>\n<th style=\"text-align:center\">建议的交换空间大小</th>\n<th style=\"text-align:center\">如果开启休眠功能建议的交换空间大小</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">⩽ 2GB</td>\n<td style=\"text-align:center\">内存的 2 倍</td>\n<td style=\"text-align:center\">内存的 3 倍</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">&gt; 2GB – 8GB</td>\n<td style=\"text-align:center\">等于内存大小</td>\n<td style=\"text-align:center\">内存的 2 倍</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">&gt; 8GB – 64GB</td>\n<td style=\"text-align:center\">至少 4G</td>\n<td style=\"text-align:center\">内存的 1.5 倍</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">&gt; 64GB</td>\n<td style=\"text-align:center\">至少 4G</td>\n<td style=\"text-align:center\">不建议使用休眠</td>\n</tr>\n</tbody>\n</table>\n<p>最后结合日常使用，一般来说可以按照如下规则设置 swap 大小：</p>\n<ul>\n<li>4G 以内的物理内存，SWAP 设置为内存的 2 倍，不超过 4G。</li>\n<li>4-8G 的物理内存，SWAP 等于内存大小。</li>\n<li>8-64G 的物理内存，SWAP 设置为 8G。</li>\n<li>64-256G 物理内存，SWAP 设置为 16G。</li>\n</ul>\n</li>\n<li>\n<p><code>/mnt</code> ：全称  <code>mount</code>  可直接理解为 “挂载”，用于存放手动挂载的硬件。这部分是根目录 <code>/</code>  下的目录，用来挂载文件系统。</p>\n<p>一般的 Linux 根目录展开如下图：</p>\n<p><img src=\"994198-20160908160724832-375737054.png\" alt=\"img\" /></p>\n<p>然后按照官方的说明，是想把将根磁盘卷挂载到  <code>/mnt</code>  目录下，即  <code>/mnt</code>  变成  <code>/</code>  根目录。</p>\n</li>\n</ul>\n<p><strong>好了，了解完后下面正式开始。</strong></p>\n<p>执行命令：</p>\n<pre><code>fdisk /dev/sdx （sdx可以为sda、sdb等，具体以你实际需要挂载的磁盘名称为准）\n</code></pre>\n<p>接着你就进入了  <code>fdisk</code>  操作环境，为了获取该命令下的操作功能，根据提示输入  <code>m</code>  并回车查看各命令的作用：</p>\n<p><img src=\"image-20220414144302934.png\" alt=\"image-20220414144302934\" /></p>\n<p>在  <code>fdisk</code>  操作环境下：</p>\n<p>1、对于一个全新的磁盘（格式化了），输入  <code>o</code>  来创建一个全新的  <code>MBR</code>  分区表（因为这里是 BIOS 引导）；如果是旧磁盘（要么原本有  <code>MBR</code>  分区表，要么不是  <code>MBR</code>  属性  <code>DOS</code>  的），那对于非  <code>MBR</code>  分区表可能得更改分区表或者格式化，而已有  <code>MBR</code>  分区表的直接执行第 2 步。</p>\n<p>2、输入  <code>n</code>  创建一个新的分区，首先会让你选择类型分区，输入  <code>p</code>  选择主分区，回车接着选择分区号，这里一般直接回车使用默认数值，这样可以避免自己定义出现冲突；紧接着选择开始起扇区地址，如果不知道原有区域划分情况，那一般直接回车使用默认数值即可；随后，输入结束扇区地址或者容量大小，这里决定了你为该分区创建的容量大小；我们按照表格顺序创建分区，那这第一个就是  <code>swap</code>  交换分区，例如我分配的是 8G 容量，那可以直接输入容量大小： <code>+8G</code>  。</p>\n<p>3、创建完毕后，可以输入  <code>p</code>  来查看创建的分区。</p>\n<p>4、重复第 2 项创建根目录分区和第 3 项确认最后的分区信息，至此就有两个分区（对应表格）。</p>\n<p>5、最后输入  <code>w</code>  将之前所有的操作写入磁盘并生效。</p>\n</li>\n<li>\n<p><strong>UEFI/GPT</strong></p>\n<p>与上一种引导方式相比，根据表格显示，只多了一个 <strong>EFI 系统分区</strong>，然后了解一下这个挂载点：</p>\n<ul>\n<li><code>/mnt/boot</code> ：上面说了官方是想把将根磁盘卷挂载到  <code>/mnt</code>  目录下，那这个 boot 引导自然就挂载到了新的  <code>/mnt</code>  目录下了。</li>\n</ul>\n<p>在该引导模式下的操作就如下。</p>\n<p>执行命令如下进入  <code>fdisk</code>  操作环境：</p>\n<pre><code>fdisk /dev/sdx （sdx可以为sda、sdb等，具体以你实际需要挂载的磁盘名称为准）\n</code></pre>\n<p>在  <code>fdisk</code>  操作环境下：</p>\n<p>1、对于一个全新的磁盘（格式化了），这里则输入  <code>g</code>  来创建一个全新的  <code>GPT</code>  分区表（因为到这里是 UEFI 引导）；同样的如果是旧磁盘那跟上面的 BIOS 引导操作差不多，只不过这里是  <code>GPT</code>  属性了。</p>\n<p>2、输入  <code>n</code>  创建一个新的分区，让你选择分区号 <strong>（UEFI 比 BIOS 少了类型分区选择）</strong> ，这里一般直接回车使用默认数值，这样可以避免自己定义出现冲突；紧接着选择开始起扇区地址，如果不知道原有区域划分情况，那一般直接回车使用默认数值即可；随后，输入结束扇区地址或者容量大小，这里决定了你为该分区创建的容量大小；我们按照表格顺序创建分区，那这第一个就是  <code>/mnt/boot</code>  引导分区，例如我取的是 512MiB 容量，那可以直接输入容量大小： <code>+512M</code>  。</p>\n<p>3、创建完毕后，可以输入  <code>p</code>  来查看创建的分区。</p>\n<p>4、重复第 2 项和第 3 项两次，分别创建  <code>[SWAP]</code>  和  <code>/mnt</code> ，至此就有三个分区（对应表格）。</p>\n<p>5、最后输入  <code>w</code>  将之前所有的操作写入磁盘并生效。</p>\n</li>\n</ol>\n<h2 id=\"格式化分区\"><a class=\"anchor\" href=\"#格式化分区\">#</a> 格式化分区</h2>\n<ul>\n<li>\n<p><strong>EFI 系统分区（仅对于 UEFI/GPT 引导方式）</strong></p>\n<p>使用  <code>mkfs.fat</code>  命令将其格式化为 Fat32：</p>\n<pre><code>mkfs.fat -F 32 /dev/sdxY （sdxY为上面创建的 EFI 系统分区符）\n</code></pre>\n</li>\n<li>\n<p><strong>swap 交换分区</strong></p>\n<p>如果有创建，则请使用  <code>mkswap</code>  命令将其初始化：</p>\n<pre><code>mkswap /dev/sdxY （sdxY为上面创建的交换空间分区符）\n</code></pre>\n</li>\n<li>\n<p><strong> <code>/mnt</code>  根目录分区</strong></p>\n<p>执行以下命令创建一个 Ext4 文件系统：</p>\n<pre><code>mkfs.ext4 /dev/sdxY （sdxY为上面创建的根分区符）\n</code></pre>\n</li>\n</ul>\n<h2 id=\"挂载分区\"><a class=\"anchor\" href=\"#挂载分区\">#</a> 挂载分区</h2>\n<p>1、将根磁盘卷挂载到  <code>/mnt</code> ，执行：</p>\n<pre><code>mount /dev/sdxY /mnt （把 sdxY替换为上面创建根分区符）\n</code></pre>\n<p>2、如果创建了  <code>swap</code>  交换空间卷，执行：</p>\n<pre><code>swapon /dev/sdxY （把 sdxY替换为上面创建的交换空间分区符）\n</code></pre>\n<p>3、对于 UEFI 系统，挂载 EFI 系统分区：</p>\n<pre><code>mkdir /mnt/boot\nmount /dev/sdxY /mnt/boot （把 sdxY替换为上面创建的 EFI 系统分区符）\n</code></pre>\n<h2 id=\"选择镜像\"><a class=\"anchor\" href=\"#选择镜像\">#</a> 选择镜像</h2>\n<p>文件  <code>/etc/pacman.d/mirrorlist</code>  定义了软件包会从哪个镜像源下载。在列表中越前的镜像在下载软件包时有越高的优先权。</p>\n<p>各地区镜像源获取：<a href=\"https://archlinux.org/mirrorlist/\">https://archlinux.org/mirrorlist/</a> ，然后点击生成：</p>\n<p><img src=\"image-20220415095310180.png\" alt=\"image-20220415095310180\" /></p>\n<p>编辑  <code>/etc/pacman.d/mirrorlist</code>  文件，执行：</p>\n<pre><code>vim /etc/pacman.d/mirrorlist\n</code></pre>\n<p>然后进入 VIM 环境，输入  <code>i</code>  进入编辑状态，然后根据上面生成提供的镜像表，选择几个放到文件最顶端，在这里笔者选择阿里云镜像：</p>\n<p><img src=\"image-20220415103048537.png\" alt=\"image-20220415103048537\" /></p>\n<p>如果其速度不佳，可以手动指定其他镜像源，像中科大或者清华的放在最上面即可：</p>\n<pre><code>Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch\nServer = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch\n</code></pre>\n<p>然后，按  <code>Esc</code>  键退出编程，最后输入  <code>:wq</code>  保存退出。</p>\n<p>关于 vim 命令的使用，可看：<a href=\"https://www.runoob.com/linux/linux-vim.html\">https://www.runoob.com/linux/linux-vim.html</a></p>\n<h2 id=\"安装必需的软件包\"><a class=\"anchor\" href=\"#安装必需的软件包\">#</a> 安装必需的软件包</h2>\n<p>使用  <code>pacstrap</code>  脚本，安装 <a href=\"https://archlinux.org/packages/?name=base\">base</a> 软件包和 Linux <a href=\"https://wiki.archlinux.org/title/Kernel_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)\">内核</a>以及常规硬件的固件：</p>\n<pre><code>pacstrap /mnt base base-devel linux linux-headers linux-firmware （base-devel在 AUR包的安装是必须的）\n</code></pre>\n<h2 id=\"fstab配置\"><a class=\"anchor\" href=\"#fstab配置\">#</a> Fstab 配置</h2>\n<p>生成自动挂载分区的  <code>fstab</code>  文件，执行命令：</p>\n<pre><code>genfstab -U /mnt &gt;&gt; /mnt/etc/fstab\n</code></pre>\n<p>然后  <code>cat</code>  一下检查生成的  <code>/mnt/etc/fstab</code>  文件是否正确：</p>\n<pre><code>cat /mnt/etc/fstab\n</code></pre>\n<p>执行后将显示各分区挂载情况及属性信息。</p>\n<h2 id=\"chroot配置\"><a class=\"anchor\" href=\"#chroot配置\">#</a> Chroot 配置</h2>\n<p><a href=\"https://wiki.archlinux.org/title/Change_root_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)\">Change root</a> 到新安装的系统：</p>\n<pre><code>arch-chroot /mnt\n</code></pre>\n<p>执行了这步以后，我们的操作都相当于在磁盘上新装的系统中进行。</p>\n<h2 id=\"时区配置\"><a class=\"anchor\" href=\"#时区配置\">#</a> 时区配置</h2>\n<p>设置时区：</p>\n<pre><code>ln -sf /usr/share/zoneinfo/Region（地区名）/City（城市名） /etc/localtime\n</code></pre>\n<p>eg：以上海为例，执行  <code>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></p>\n<p>然后运行  <code>hwclock</code>  以生成  <code>/etc/adjtime</code> ：</p>\n<pre><code>hwclock --systohc\n</code></pre>\n<h2 id=\"本地化配置\"><a class=\"anchor\" href=\"#本地化配置\">#</a> 本地化配置</h2>\n<p>程序和库如果需要本地化文本，则需要根据区域设置 Locale，以明确规定地域、货币、时区日期的格式、字符排列方式和其他本地化标准。</p>\n<p>需在这两个文件设置： <code>locale.gen</code>  与  <code>locale.conf</code> 。</p>\n<p>通过前面的 Chroot 配置，我们已经处于 chroot 环境下了，这就意味这现在所在的系统中只有一些最基本的包（组件），而 VIM 组件并未包含在里面，这时候就需要自己安装组件包了。利用 Archlinux 下非常强大的包管理工具  <code>pacman</code> ，其安装包的命令格式为  <code>pacman -S 包名</code> ， <code>pacman</code>  会自动检查这个包所需要的其他包（即为依赖）并一起装上。</p>\n<p>然后我们安装 VIM 组件，执行：</p>\n<pre><code>pacman -S vim\n</code></pre>\n<p>1、利用刚安装的  <code>vim</code>  ，编辑  <code>locale.gen</code>  文件：</p>\n<pre><code>vim /etc/locale.gen\n</code></pre>\n<p>找到  <code>zh_CN.UTF-8 UTF-8</code> 、 <code>en_US.UTF-8 UTF-8</code>  这两行，去掉注释并保存。</p>\n<p>紧接着执行  <code>locale-gen</code>  以生成 locale 信息：</p>\n<pre><code>locale-gen\n</code></pre>\n<p>2、然后创建 <a href=\"https://man.archlinux.org/man/locale.conf.5\">locale.conf</a> 文件，并 <a href=\"https://wiki.archlinux.org/title/Locale_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E7%B3%BB%E7%BB%9F%E5%8C%BA%E5%9F%9F%E8%AE%BE%E7%BD%AE\">编辑设定 LANG 变量</a>，</p>\n<pre><code>echo LANG=en_US.UTF-8 &gt; /etc/locale.conf\n</code></pre>\n<h2 id=\"网络配置\"><a class=\"anchor\" href=\"#网络配置\">#</a> 网络配置</h2>\n<p>创建  <code>/etc/hostname</code>  文件，并设定的一个  <code>myhostname</code> ：</p>\n<pre><code>echo myhostname &gt; /etc/hostname （myhostname是你想要为该系统设置的名称）\n</code></pre>\n<p>这步在我目前使用的功能里好像没用到。。。</p>\n<p>然后，在官方文档中有一条说明：</p>\n<blockquote>\n<p>请注意，目前的 <a href=\"https://archlinux.org/packages/?name=base\">base</a> 不含有任何网络管理工具。对于新安装的系统环境，请接着完成<a href=\"https://wiki.archlinux.org/title/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE\">网络配置</a>，配置过程中可能包括要安装合适的<a href=\"https://wiki.archlinux.org/title/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86\">网络管理</a>软件。</p>\n</blockquote>\n<p>因此，我们需要安装网络配置管理包（<a href=\"https://wiki.archlinux.org/title/Dhcpcd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)\">DHCP</a> 客户端和 <a href=\"https://wiki.archlinux.org/title/Netctl_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)\">netctl</a> 网络管理器）：</p>\n<pre><code>pacman -S dhcpcd netctl\n</code></pre>\n<h2 id=\"root-密码\"><a class=\"anchor\" href=\"#root-密码\">#</a> Root 密码</h2>\n<p><code>Root</code>  是  <code>Linux</code>  中具有最高权限帐户，有些敏感的操作必须通过  <code>Root</code>  用户进行，比如使用 <code>pacman</code>  命令。</p>\n<p>执行以下命令，然后根据提示输入两次密码即可（注意输入是不显示出来）：</p>\n<pre><code>passwd root\n</code></pre>\n<h2 id=\"安装引导程序\"><a class=\"anchor\" href=\"#安装引导程序\">#</a> 安装引导程序</h2>\n<p>如果是 Intel 或 AMD 的 CPU，启用 <a href=\"https://wiki.archlinux.org/title/Microcode_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)\">微码</a> 更新：</p>\n<ul>\n<li>\n<p>Intel</p>\n<pre><code>pacman -S intel-ucode\n</code></pre>\n</li>\n<li>\n<p>AMD</p>\n<pre><code>pacman -S amd-ucode\n</code></pre>\n</li>\n</ul>\n<p>接着，官方推荐的引导加载是 <a href=\"https://wiki.archlinux.org/title/GRUB_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)\">GRUB</a> （其他的引导加载可看：<a href=\"https://wiki.archlinux.org/title/Arch_boot_process_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%8A%9F%E8%83%BD%E6%AF%94%E8%BE%83\">引导功能比较</a>），因此我们对其安装并配置，不同的引导系统，其操作不一样：</p>\n<ul>\n<li>\n<p><strong>BIOS/MBR</strong></p>\n<p>1、安装  <code>grub</code> ：</p>\n<pre><code>pacman -S grub\n</code></pre>\n<p>2、部署  <code>grub</code> ：</p>\n<pre><code>grub-install --target=i386-pc /dev/sdx （sdx为要安装 GRUB 的磁盘，注意不是分区）\n</code></pre>\n</li>\n<li>\n<p><strong>UEFI/GPT</strong></p>\n<p>1、安装  <code>grub</code>  和  <code>efibootmgr</code> ：</p>\n<pre><code>pacman -S grub efibootmgr\n</code></pre>\n<p>2、部署  <code>grub</code> ：</p>\n<pre><code>grub-install --target=x86_64-efi --efi-directory=esp --bootloader-id=GRUB （这里的 esp 替换成挂载点）\n</code></pre>\n<p>像在这里，那就是：</p>\n<pre><code>grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUB\n</code></pre>\n</li>\n</ul>\n<p><strong>最后，不管是哪个引导方式，都执行第三步：</strong></p>\n<p>3、生成配置文件：</p>\n<pre><code>grub-mkconfig -o /boot/grub/grub.cfg\n</code></pre>\n<p>执行后，最后显示  <code>done</code>  即完成操作。</p>\n<p><strong>note：这一步是至关重要的一步，请检查是否正确安装好引导加载程序后再重新启动，否则下次重启后将无法正常进入系统。</strong></p>\n<h2 id=\"重启\"><a class=\"anchor\" href=\"#重启\">#</a> 重启</h2>\n<p>最最最后，你需要进行重启来启动已经安装好的系统。</p>\n<p>1、输入以下命令退出 chroot 环境：</p>\n<pre><code>exit\n</code></pre>\n<p>2、手动取消挂载的分区（这有助于发现任何「繁忙」的分区）：</p>\n<p><strong>如果挂载了  <code>/mnt/boot</code> ，先  <code>umount -r /mnt/boot</code> ，再  <code>umount -r /mnt</code> ，否则直接  <code>umount /mnt</code> 。</strong></p>\n<pre><code>umount -r /mnt/boot\numount -r /mnt\n</code></pre>\n<p>3、执行重启：</p>\n<pre><code>reboot\n</code></pre>\n<h2 id=\"other\"><a class=\"anchor\" href=\"#other\">#</a> Other</h2>\n<p>另外一些比较详细的安装教程：</p>\n<p><a href=\"https://archlinuxstudio.github.io/ArchLinuxTutorial/#/?id=arch-linux-%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-archtutorial-arch-linux-studio\">Arch Linux 安装使用教程</a></p>\n<p><a href=\"https://www.viseator.com/2017/05/17/arch_install/\">以官方 Wiki 的方式安装 ArchLinux</a></p>\n",
            "tags": [
                "history",
                "Linux"
            ]
        }
    ]
}